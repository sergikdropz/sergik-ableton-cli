<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Cache Control: Prevent caching of old versions with Mix/Arrange/Automate tabs -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>SERGIK AI Controller - Device Preview</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Ableton Dark Palette */
            --bg-dark: #1a1a1a;
            --bg-device: #1f1f1f;
            --bg-panel: #2a2a2a;
            --bg-hover: #333333;
            --bg-active: #3a3a3a;
            --bg-input: #1f1f1f;
            
            /* Ableton Accents */
            --accent-orange: #ff764d;
            --accent-cyan: #00d4aa;
            --accent-purple: #a855f7;
            --accent-yellow: #ffb800;
            --accent-red: #ff3b30;
            
            /* Text Colors */
            --text-primary: #ffffff;
            --text-secondary: #999999;
            --text-tertiary: #666666;
            --text-disabled: #444444;
            
            /* Borders */
            --border-color: #3a3a3a;
            --border-light: #2a2a2a;
            --border-active: #00d4aa;
            --border-hover: #4a4a4a;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'JetBrains Mono', monospace;
            background: #1a1a1a;
            min-height: 100vh;
            padding: 12px;
            color: var(--text-primary);
            font-size: 11px;
            line-height: 1.3;
        }
        
        /* Screen reader only - visually hidden but accessible */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(90deg, var(--accent-orange), var(--accent-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        
        .header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }
        
        /* Device Container */
        .device-wrapper {
            background: var(--bg-dark);
            border-radius: 3px;
            padding: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            margin-bottom: 12px;
        }
        
        .device {
            background: var(--bg-device);
            border-radius: 2px;
            padding: 8px;
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }
        
        .device::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-orange), var(--accent-cyan), var(--accent-purple));
        }
        
        /* Device Header */
        .device-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .device-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .device-title .logo {
            font-size: 1.5rem;
        }
        
        .device-title h2 {
            font-size: 1rem;
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        .device-status {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .status-led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-cyan);
            box-shadow: 0 0 6px var(--accent-cyan);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-text {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--accent-cyan);
        }
        
        /* Main Grid */
        .device-grid {
            display: grid;
            gap: 4px;
        }
        
        /* Panel Styles */
        .panel {
            background: var(--bg-panel);
            border-radius: 2px;
            padding: 6px;
            border: 1px solid var(--border-color);
        }
        
        .panel-title {
            font-size: 9px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .panel-actions {
            display: flex;
            gap: 3px;
        }
        
        /* Button Grid */
        .button-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3px;
        }
        
        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            font-weight: 600;
            padding: 5px 6px;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.15s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            background: var(--bg-dark);
            color: var(--text-primary);
        }
        
        .btn:hover {
            background: var(--bg-hover);
            border-color: var(--border-active);
        }
        
        .btn-orange {
            background: linear-gradient(180deg, #ff6b35 0%, #cc5429 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
        }
        
        .btn-cyan {
            background: linear-gradient(180deg, #00d4aa 0%, #00a88a 100%);
            color: #1a1a1a;
            box-shadow: 0 2px 8px rgba(0, 212, 170, 0.3);
        }
        
        .btn-purple {
            background: linear-gradient(180deg, #a855f7 0%, #8b44cc 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3);
        }
        
        .btn-yellow {
            background: linear-gradient(180deg, #fbbf24 0%, #d9a520 100%);
            color: #1a1a1a;
            box-shadow: 0 2px 8px rgba(251, 191, 36, 0.3);
        }
        
        .btn-gray {
            background: linear-gradient(180deg, #5a5a5a 0%, #4a4a4a 100%);
            color: white;
        }
        
        /* AI Generate Button Colors (Ableton-like) */
        .btn-kicks {
            background: linear-gradient(180deg, #ff6b35 0%, #e55a2b 100%);
            color: white;
        }
        
        .btn-claps {
            background: linear-gradient(180deg, #fbbf24 0%, #d9a520 100%);
            color: #1a1a1a;
        }
        
        .btn-hats {
            background: linear-gradient(180deg, #00d4aa 0%, #00a88a 100%);
            color: #1a1a1a;
        }
        
        .btn-perc {
            background: linear-gradient(180deg, #a855f7 0%, #9333ea 100%);
            color: white;
        }
        
        .btn-bass {
            background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
            color: white;
        }
        
        .btn-synths {
            background: linear-gradient(180deg, #ec4899 0%, #db2777 100%);
            color: white;
        }
        
        .btn-vocals {
            background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }
        
        .btn-fx {
            background: linear-gradient(180deg, #14b8a6 0%, #0d9488 100%);
            color: white;
        }
        
        .btn-generate:disabled {
            background: #4a4a4a !important;
            color: var(--text-secondary) !important;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .btn:hover:not(:disabled) {
            background: var(--bg-hover);
            border-color: var(--border-active);
        }
        
        .btn:active:not(:disabled) {
            background: var(--bg-active);
        }
        
        /* Toggle Switches */
        .toggle-row {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
            justify-content: center;
        }
        
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
        }
        
        .toggle-switch input[type="checkbox"] {
            display: none;
        }
        
        .toggle-slider {
            position: relative;
            width: 36px;
            height: 20px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            transition: all 0.2s ease;
        }
        
        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: all 0.2s ease;
        }
        
        .toggle-switch input[type="checkbox"]:checked + .toggle-slider {
            background: var(--accent-cyan);
        }
        
        .toggle-switch input[type="checkbox"]:checked + .toggle-slider::before {
            transform: translateX(16px);
        }
        
        .toggle-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .toggle-switch input[type="checkbox"]:checked ~ .toggle-label {
            color: var(--accent-cyan);
        }
        
        /* Center Display Panel */
        .center-panel {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        /* Display Screen with Dropdowns */
        .display-screen {
            background: var(--bg-dark);
            border-radius: 2px;
            padding: 6px;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid var(--border-color);
            min-height: 80px;
        }
        
        .display-line {
            font-size: 10px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .display-line .label {
            color: var(--text-secondary);
            min-width: 60px;
            font-size: 9px;
        }
        
        .display-line .value {
            color: var(--accent-cyan);
        }
        
        .display-line .value.orange { color: var(--accent-orange); }
        .display-line .value.purple { color: var(--accent-purple); }
        .display-line .value.yellow { color: var(--accent-yellow); }
        
        /* Dropdown Selects */
        .dropdown-select {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 4px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--accent-cyan);
            cursor: pointer;
            min-width: 100px;
            -webkit-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' fill='%2300d4aa' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 6px center;
            padding-right: 24px;
        }
        
        .dropdown-select:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 8px rgba(0, 212, 170, 0.3);
        }
        
        .dropdown-select.orange {
            color: var(--accent-orange);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23ff6b35' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
        }
        
        .dropdown-select.purple {
            color: var(--accent-purple);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23a855f7' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
        }
        
        .dropdown-select.yellow {
            color: var(--accent-yellow);
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23fbbf24' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
        }
        
        /* Tabbed Input Interface */
        .input-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 4px;
            background: var(--bg-panel);
            padding: 3px;
            border-radius: 2px;
        }
        
        .tab-btn {
            flex: 1;
            padding: 4px 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            font-weight: 600;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.15s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1px;
        }
        
        .tab-btn .icon {
            font-size: 10px;
        }
        
        .tab-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .tab-btn.active {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        /* Tab Content */
        .tab-content {
            display: none;
            min-height: 80px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* File Upload Drop Zone */
        .drop-zone {
            border: 2px dashed var(--border-color);
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            background: rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .drop-zone:hover, .drop-zone.dragover {
            border-color: var(--accent-cyan);
            background: rgba(0, 212, 170, 0.1);
        }
        
        .drop-zone .icon {
            font-size: 2rem;
            color: var(--text-secondary);
        }
        
        .drop-zone p {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        
        .drop-zone input[type="file"] {
            display: none;
        }
        
        /* URL Input */
        .url-input-wrapper {
            display: flex;
            gap: 8px;
        }
        
        .url-input {
            flex: 1;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 4px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-primary);
        }
        
        .url-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
        }
        
        /* Mic Button */
        .mic-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            min-height: 80px;
        }
        
        .mic-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--accent-orange);
            background: rgba(255, 107, 53, 0.1);
            color: var(--accent-orange);
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .mic-btn:hover {
            background: var(--accent-orange);
            color: white;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.5);
        }
        
        .mic-btn.recording {
            background: var(--accent-red);
            border-color: var(--accent-red);
            color: white;
            animation: recording-pulse 1s infinite;
        }
        
        @keyframes recording-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            50% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
        }
        
        .mic-status {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        
        /* Command Text Input */
        .prompt-input {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 4px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-primary);
            width: 100%;
            resize: none;
            height: 60px;
        }
        
        .prompt-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(0, 212, 170, 0.2);
        }
        
        .prompt-input::placeholder {
            color: var(--text-secondary);
        }
        
        /* Idea Input */
        .idea-input {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 4px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-size: 0.8rem;
            color: var(--text-primary);
            width: 100%;
            flex: 1;
            transition: all 0.2s ease;
        }
        
        .idea-input:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 8px rgba(0, 212, 170, 0.2);
        }
        
        .idea-input::placeholder {
            color: var(--text-secondary);
        }
        
        /* Clipboard Button */
        .clipboard-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            min-height: 80px;
        }
        
        .paste-btn {
            padding: 12px 24px;
            background: linear-gradient(180deg, var(--accent-purple), #7c3aed);
            border: none;
            border-radius: 6px;
            color: white;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }
        
        .paste-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(168, 85, 247, 0.4);
        }
        
        /* Transport Controls */
        .transport {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .transport-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            background: var(--bg-panel);
            color: var(--text-primary);
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }
        
        .transport-btn:hover {
            background: var(--accent-cyan);
            color: #1a1a1a;
            border-color: var(--accent-cyan);
        }
        
        .transport-btn.record:hover {
            background: #ef4444;
            border-color: #ef4444;
            color: white;
        }
        
        /* Analysis Results Panel */
        .results-panel {
            background: var(--bg-panel);
            border-radius: 6px;
            padding: 12px;
            border: 1px solid var(--border-color);
        }
        
        /* DNA Gauge */
        .dna-gauge {
            margin-bottom: 8px;
        }
        
        .gauge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .gauge-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        
        .gauge-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent-cyan);
        }
        
        .gauge-bar {
            height: 12px;
            background: #2a2a2a;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        
        .gauge-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-orange), var(--accent-cyan));
            border-radius: 6px;
            transition: width 0.5s ease;
        }
        
        /* Genre Bars */
        .genre-bars {
            margin-bottom: 8px;
        }
        
        .genre-bar {
            margin-bottom: 4px;
        }
        
        .genre-bar-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            margin-bottom: 3px;
        }
        
        .genre-bar-name {
            color: var(--text-secondary);
        }
        
        .genre-bar-value {
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .genre-bar-track {
            height: 6px;
            background: #2a2a2a;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .genre-bar-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        
        .genre-bar-fill.hiphop { background: var(--accent-orange); }
        .genre-bar-fill.funk { background: var(--accent-yellow); }
        .genre-bar-fill.house { background: var(--accent-cyan); }
        .genre-bar-fill.soul { background: var(--accent-purple); }
        
        /* Suggestions List */
        .suggestions {
            margin-top: 10px;
        }
        
        .suggestion-item {
            font-size: 0.65rem;
            padding: 6px 8px;
            margin-bottom: 4px;
            background: rgba(0, 212, 170, 0.1);
            border-left: 3px solid var(--accent-cyan);
            border-radius: 0 4px 4px 0;
            color: var(--text-secondary);
        }
        
        /* Collaborator Tags */
        .collab-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
        }
        
        .collab-tag {
            font-size: 0.6rem;
            padding: 3px 8px;
            background: rgba(168, 85, 247, 0.2);
            border: 1px solid var(--accent-purple);
            border-radius: 20px;
            color: var(--accent-purple);
        }
        
        /* View Toggle Switch */
        .view-toggle {
            display: flex;
            gap: 2px;
            background: var(--bg-panel);
            padding: 2px;
            border-radius: 2px;
            margin-bottom: 6px;
        }
        
        .toggle-btn {
            flex: 1;
            padding: 4px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            font-weight: 600;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .toggle-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .toggle-btn.active {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        .toggle-btn.active[data-view="musicbrainz"] {
            background: var(--accent-purple);
            color: white;
        }
        
        /* Toggle View Content */
        .view-content {
            display: none;
        }
        
        .view-content.active {
            display: block;
        }
        
        /* MusicBrainz Track Info */
        .mb-track-info {
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid var(--accent-purple);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 12px;
        }
        
        .mb-track-info .track-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        
        .mb-track-info .track-artist {
            font-size: 0.75rem;
            color: var(--accent-purple);
            margin-bottom: 2px;
        }
        
        .mb-track-info .track-album {
            font-size: 0.65rem;
            color: var(--text-secondary);
        }
        
        /* Tags */
        .mb-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
        }
        
        .mb-tag {
            font-size: 0.55rem;
            padding: 2px 6px;
            background: rgba(168, 85, 247, 0.15);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 10px;
            color: var(--accent-purple);
        }
        
        /* Commit Section */
        .commit-section {
            margin-top: 15px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }
        
        .commit-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .placement-indicator {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-secondary);
            background: rgba(0, 212, 170, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid transparent;
        }
        
        .placement-indicator.ready {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }
        
        .placement-indicator.waiting {
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }
        
        .commit-btn {
            width: 100%;
            padding: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .commit-btn:not(:disabled) {
            background: linear-gradient(180deg, var(--accent-cyan) 0%, #00a88a 100%);
            color: #1a1a1a;
            box-shadow: 0 4px 15px rgba(0, 212, 170, 0.4);
        }
        
        .commit-btn:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 170, 0.5);
        }
        
        .commit-btn:disabled {
            background: #4a4a4a;
            color: var(--text-secondary);
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .commit-btn .icon {
            font-size: 1.1rem;
        }
        
        /* Dropdown validation states */
        .dropdown-select.required {
            border: 2px solid var(--accent-yellow);
        }
        
        .dropdown-select.required:focus {
            border-color: var(--accent-yellow);
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.3);
        }
        
        .dropdown-select.valid {
            border: 2px solid var(--accent-cyan);
        }
        
        .dropdown-select.valid:focus {
            border-color: var(--accent-cyan);
        }
        
        /* Status Indicator */
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-led {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-cyan);
            box-shadow: 0 0 8px rgba(0, 212, 170, 0.6);
            animation: pulse 2s infinite;
        }
        
        .status-led.ready { background: var(--accent-cyan); box-shadow: 0 0 8px rgba(0, 212, 170, 0.6); }
        .status-led.processing { background: var(--accent-yellow); box-shadow: 0 0 8px rgba(251, 191, 36, 0.6); animation: pulse 1s infinite; }
        .status-led.analyzing { background: var(--accent-purple); box-shadow: 0 0 8px rgba(168, 85, 247, 0.6); animation: pulse 1s infinite; }
        .status-led.connected { background: var(--accent-cyan); box-shadow: 0 0 8px rgba(0, 212, 170, 0.6); }
        .status-led.error { background: var(--accent-red); box-shadow: 0 0 8px rgba(239, 68, 68, 0.6); }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-text {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-cyan);
        }
        
        /* Inline Status Display in Command Area */
        .status-display-inline {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding: 6px 10px;
            background: rgba(0, 212, 170, 0.1);
            border-left: 3px solid var(--accent-cyan);
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
        }
        
        .status-label {
            color: var(--text-secondary);
        }
        
        .status-value {
            color: var(--accent-cyan);
            font-weight: 600;
        }
        
        /* Generated Media Browser */
        .media-browser {
            min-height: 200px;
        }
        
        .media-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .media-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            background: rgba(0, 212, 170, 0.05);
            border: 1px solid rgba(0, 212, 170, 0.2);
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
        }
        
        .media-item.empty {
            text-align: center;
            color: var(--text-secondary);
            border: none;
            background: transparent;
        }
        
        .media-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }
        
        .media-item-icon {
            font-size: 1rem;
        }
        
        .media-item-name {
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .media-item-type {
            color: var(--text-secondary);
            font-size: 0.65rem;
        }
        
        .media-item-actions {
            display: flex;
            gap: 4px;
        }
        
        .media-item-btn {
            padding: 4px 8px;
            font-size: 0.6rem;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .media-item-btn.insert {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        .media-item-btn.replace {
            background: var(--accent-orange);
            color: white;
        }
        
        .media-item-btn.commit {
            background: var(--accent-purple);
            color: white;
        }
        
        .media-preview {
            min-height: 150px;
            background: #1a1a1a;
            border-radius: 4px;
            padding: 10px;
        }
        
        .media-preview-empty {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
        }
        
        .waveform-container {
            width: 100%;
            height: 80px;
            background: #2a2a2a;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .midi-summary {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-secondary);
        }
        
        /* Right Panel */
        .action-list {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .action-item {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            padding: 4px 6px;
            background: rgba(0, 212, 170, 0.1);
            border-left: 3px solid var(--accent-cyan);
            border-radius: 0 4px 4px 0;
            color: var(--text-secondary);
        }
        
        .action-item.success {
            border-left-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }
        
        .action-item.pending {
            border-left-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }
        
        /* Knobs */
        .knob-row {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
        }
        
        .knob-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .knob {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4a4a4a 0%, #2a2a2a 100%);
            border: 3px solid #5a5a5a;
            position: relative;
            cursor: pointer;
        }
        
        .knob::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 15px;
            background: var(--accent-orange);
            border-radius: 2px;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(45deg);
        }
        
        .knob-label {
            font-size: 0.6rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        
        /* Feature Cards */
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 40px;
        }
        
        .feature-card {
            background: rgba(45, 45, 45, 0.8);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid var(--border-color);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }
        
        .feature-card h3 {
            font-size: 1rem;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .feature-card h3 .icon {
            font-size: 1.3rem;
        }
        
        .feature-card ul {
            list-style: none;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .feature-card li {
            padding: 5px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .feature-card li::before {
            content: '>';
            color: var(--accent-cyan);
        }
        
        /* Command Examples */
        .commands {
            margin-top: 40px;
        }
        
        .commands h2 {
            font-size: 1.3rem;
            margin-bottom: 20px;
            color: var(--accent-orange);
        }
        
        .command-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 12px;
        }
        
        .command {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            border-left: 3px solid var(--accent-purple);
            color: var(--text-secondary);
        }
        
        .command::before {
            content: '> ';
            color: var(--accent-cyan);
        }
        
        /* Footer */
        .footer {
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .footer a {
            color: var(--accent-cyan);
            text-decoration: none;
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .device-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .device-grid {
                grid-template-columns: 1fr;
            }
            
            body {
                padding: 20px;
            }
        }
        
        /* ============================================================================
           MAIN TAB SYSTEM
           ============================================================================ */
        
        .main-tabs {
            display: flex;
            gap: 2px;
            margin-bottom: 8px;
            background: var(--bg-panel);
            padding: 4px;
            border-radius: 2px;
            border: 1px solid var(--border-color);
            position: relative;
        }
        
        .main-tab-btn {
            flex: 1;
            padding: 5px 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            font-weight: 600;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
        }
        
        .main-tab-btn .icon {
            font-size: 1.1rem;
        }
        
        .main-tab-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .main-tab-btn.active {
            background: var(--accent-cyan);
            color: #1a1a1a;
            box-shadow: 0 1px 3px rgba(0, 212, 170, 0.3);
        }
        
        .main-tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid var(--accent-cyan);
        }
        
        /* Tab Content Sections */
        .tab-section {
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .tab-section.active {
            display: block;
        }
        
        /* Ensure tab sections have content visible */
        .tab-section.active .device-grid {
            display: grid !important;
        }
        
        .tab-section.active .panel {
            min-height: 200px;
            display: block !important;
        }
        
        /* Ensure Library and Edit tabs are visible when active */
        #tab-section-library.active {
            display: block !important;
        }
        
        #tab-section-library.active .view-content.active,
        #tab-section-library.active .editor-content.active {
            display: block !important;
        }
        
        @keyframes fadeIn {
            from { 
                opacity: 0; 
                transform: translateY(5px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }
        
        /* Compact grid layouts for different tabs */
        .tab-section .device-grid {
            gap: 12px;
        }
        
        .tab-section.active .panel {
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0; 
                transform: translateX(-10px); 
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
            }
        }
        
        /* Tab-specific grid layouts */
        #tab-section-create .device-grid {
            grid-template-columns: 160px 1fr 200px 140px;
            gap: 4px;
        }
        
        #tab-section-analyze .device-grid {
            grid-template-columns: 1fr 200px;
            gap: 4px;
        }
        
        #tab-section-library .device-grid {
            grid-template-columns: 200px 1fr 140px;
            gap: 4px;
        }
        
        #tab-section-ai .device-grid {
            grid-template-columns: 1fr 200px;
            gap: 4px;
        }
        
        /* Tab indicator badge for notifications */
        .main-tab-btn .badge {
            position: absolute;
            top: 4px;
            right: 4px;
            background: var(--accent-orange);
            color: white;
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 10px;
            min-width: 16px;
            text-align: center;
            display: none;
        }
        
        .main-tab-btn.has-notification .badge {
            display: block;
        }
        
        /* Collapsible Sections */
        .collapsible-section {
            margin-bottom: 10px;
        }
        
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }
        
        .collapsible-header:hover {
            background: rgba(0,0,0,0.3);
            color: var(--text-primary);
        }
        
        .collapsible-header .icon {
            transition: transform 0.2s ease;
        }
        
        .collapsible-section.expanded .collapsible-header .icon {
            transform: rotate(180deg);
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding-top: 0;
        }
        
        .collapsible-section.expanded .collapsible-content {
            max-height: 2000px;
            padding-top: 10px;
        }
        
        /* Quick Actions Bar */
        .quick-actions-bar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
        }
        
        .quick-action-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(180deg, var(--accent-cyan) 0%, #00a88a 100%);
            border: none;
            color: #1a1a1a;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 212, 170, 0.4);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .quick-action-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 212, 170, 0.6);
        }
        
        .quick-action-btn:active {
            transform: scale(0.95);
        }
        
        /* ============================================================================
           EDITOR TABS (Waveform, Piano Roll, Timeline)
           ============================================================================ */
        
        .editor-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 15px;
            background: #2a2a2a;
            padding: 4px;
            border-radius: 6px;
        }
        
        .editor-tab-btn {
            flex: 1;
            padding: 8px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 0.7rem;
            transition: all 0.2s ease;
        }
        
        .editor-tab-btn:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .editor-tab-btn.active {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        .editor-content {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        
        .editor-content.active {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        /* Ensure editors show when Library tab is active */
        #tab-section-library.active .editor-content.active {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        /* Force visibility for active editor in Library tab */
        #tab-section-library.active #editor-waveform.active,
        #tab-section-library.active #editor-piano-roll.active,
        #tab-section-library.active #editor-timeline.active {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            position: relative !important;
        }
        
        /* Waveform Editor */
        .waveform-container {
            background: #1a1a1a;
            border-radius: 6px;
            padding: 15px;
        }
        
        .waveform-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .waveform-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .waveform-controls {
            display: flex;
            gap: 6px;
        }
        
        .waveform-canvas-container {
            position: relative;
            height: 150px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            overflow: hidden;
            cursor: crosshair;
            margin-bottom: 10px;
        }
        
        #waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .waveform-selection {
            position: absolute;
            background: rgba(0, 212, 170, 0.2);
            border: 1px solid var(--accent-cyan);
            pointer-events: none;
            top: 0;
            bottom: 0;
        }
        
        .waveform-cursor {
            position: absolute;
            width: 2px;
            height: 100%;
            background: var(--accent-cyan);
            pointer-events: none;
            top: 0;
        }
        
        .waveform-tools {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .waveform-info {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 0.7rem;
        }
        
        .info-item {
            display: flex;
            gap: 5px;
        }
        
        .info-item .label {
            color: var(--text-secondary);
        }
        
        .info-item .value {
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Piano Roll Editor */
        .piano-roll-container {
            background: #1a1a1a;
            border-radius: 6px;
            padding: 15px;
        }
        
        .piano-roll-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .piano-roll-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .piano-roll-tools {
            display: flex;
            gap: 6px;
        }
        
        .piano-roll-main {
            display: flex;
            height: 400px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .piano-keys {
            width: 60px;
            background: #2a2a2a;
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
        }
        
        .piano-key {
            height: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding-left: 5px;
            font-size: 0.65rem;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .piano-key.black {
            background: #1a1a1a;
            height: 15px;
            margin-top: -7px;
            z-index: 1;
            color: white;
            padding-left: 3px;
        }
        
        .piano-roll-grid {
            flex: 1;
            position: relative;
            overflow: auto;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 19px,
                var(--border-color) 20px
            );
        }
        
        #piano-roll-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .piano-roll-notes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .piano-roll-note {
            position: absolute;
            background: var(--accent-cyan);
            border: 1px solid rgba(0, 212, 170, 0.5);
            border-radius: 2px;
            cursor: move;
            pointer-events: all;
        }
        
        .piano-roll-footer {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
        }
        
        .velocity-editor {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.7rem;
        }
        
        .velocity-editor input[type="range"] {
            width: 100px;
        }
        
        .quantize-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.7rem;
        }
        
        /* Timeline Editor */
        .timeline-container {
            position: relative;
            background: #1a1a1a;
            border-radius: 6px;
            padding: 15px;
            height: 400px;
            overflow: auto;
        }
        
        .timeline-ruler {
            height: 30px;
            background: #2a2a2a;
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
        }
        
        .timeline-tracks {
            position: relative;
        }
        
        .timeline-item {
            position: absolute;
            background: var(--accent-cyan);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.7rem;
            cursor: move;
            border: 1px solid rgba(0, 212, 170, 0.5);
            min-width: 100px;
        }
        
        .timeline-playhead {
            position: absolute;
            width: 2px;
            height: 100%;
            background: var(--accent-orange);
            pointer-events: none;
            z-index: 5;
        }
        
        .timeline-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        /* Mixer Strips */
        .mixer-strips {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px;
        }
        
        .mixer-strip {
            min-width: 80px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .strip-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .strip-name {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .strip-controls {
            display: flex;
            gap: 4px;
        }
        
        .strip-btn {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.6rem;
            cursor: pointer;
        }
        
        .strip-btn:hover {
            background: rgba(255,255,255,0.1);
        }
        
        .strip-fader {
            height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .fader {
            width: 30px;
            height: 180px;
            writing-mode: vertical-lr;
            direction: rtl;
        }
        
        .fader input[type="range"] {
            writing-mode: vertical-lr;
            direction: rtl;
        }
        
        .fader-value {
            font-size: 0.7rem;
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .strip-pan {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .strip-pan label {
            font-size: 0.65rem;
            color: var(--text-secondary);
        }
        
        .pan-slider {
            width: 100%;
        }
        
        .strip-sends {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .send-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .send-item label {
            font-size: 0.65rem;
            color: var(--text-secondary);
        }
        
        .send-slider {
            width: 100%;
        }
        
        /* Effects Rack */
        .effects-rack {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .effect-slot {
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            padding: 10px;
            border: 1px solid var(--border-color);
        }
        
        .effect-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .effect-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .effect-toggle {
            padding: 4px 8px;
            background: var(--accent-cyan);
            border: none;
            border-radius: 3px;
            color: #1a1a1a;
            font-size: 0.65rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        .effect-toggle:not(.active) {
            background: #4a4a4a;
            color: var(--text-secondary);
        }
        
        .effect-params {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .param-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .param-item label {
            font-size: 0.65rem;
            color: var(--text-secondary);
        }
        
        .param-slider {
            width: 100%;
        }
        
        .master-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }
        
        .master-fader {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        /* Arrange View */
        .arrange-panel {
            background: #1a1a1a;
            border-radius: 6px;
            padding: 15px;
            position: relative;
            overflow: auto;
            height: 600px;
        }
        
        .arrange-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .arrange-controls {
            display: flex;
            gap: 6px;
        }
        
        .arrange-tracks {
            display: flex;
            flex-direction: column;
        }
        
        .arrange-track {
            border-bottom: 1px solid var(--border-color);
            min-height: 80px;
        }
        
        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: rgba(0,0,0,0.2);
        }
        
        .track-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .track-controls {
            display: flex;
            gap: 4px;
        }
        
        .track-btn {
            width: 24px;
            height: 24px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.7rem;
            cursor: pointer;
        }
        
        .track-lane {
            position: relative;
            height: 60px;
            background: rgba(0,0,0,0.2);
        }
        
        .clip-region {
            position: absolute;
            background: var(--accent-cyan);
            border: 1px solid rgba(0, 212, 170, 0.5);
            border-radius: 4px;
            padding: 4px 8px;
            cursor: move;
            height: 50px;
            min-width: 100px;
        }
        
        .clip-label {
            font-size: 0.7rem;
            color: #1a1a1a;
            font-weight: 600;
        }
        
        .arrange-playhead {
            position: absolute;
            width: 2px;
            height: 100%;
            background: var(--accent-orange);
            pointer-events: none;
            z-index: 10;
        }
        
        /* Automation Editor */
        .automation-editor {
            background: #1a1a1a;
            border-radius: 6px;
            padding: 15px;
        }
        
        .parameter-selector {
            margin-bottom: 15px;
        }
        
        .automation-lane {
            position: relative;
            height: 200px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .lane-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid var(--border-color);
        }
        
        .lane-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .lane-value {
            font-size: 0.7rem;
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
        }
        
        #automation-canvas {
            width: 100%;
            height: calc(100% - 40px);
            display: block;
        }
        
        .automation-points {
            position: absolute;
            top: 40px;
            left: 0;
            width: 100%;
            height: calc(100% - 40px);
            pointer-events: none;
        }
        
        .automation-point {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-cyan);
            border: 2px solid #1a1a1a;
            cursor: move;
            pointer-events: all;
        }
        
        .automation-tools {
            display: flex;
            gap: 8px;
        }
        
        /* Parameter Mapping */
        .macro-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .macro-item {
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .macro-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .macro-slider {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .macro-fader {
            flex: 1;
        }
        
        .macro-value {
            font-size: 0.7rem;
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
            min-width: 30px;
            text-align: right;
        }
        
        .macro-target {
            width: 100%;
            padding: 6px;
            background: #2a2a2a;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.7rem;
        }
        
        .midi-mapping {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }
        
        .mapping-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 10px;
        }
        
        .mapping-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            font-size: 0.7rem;
        }
        
        .mapping-cc {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-cyan);
            min-width: 50px;
        }
        
        .mapping-arrow {
            color: var(--text-secondary);
        }
        
        .mapping-target {
            flex: 1;
            color: var(--text-primary);
        }
        
        .mapping-remove {
            background: transparent;
            border: none;
            color: var(--accent-red);
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        /* AI Chat Interface */
        .ai-chat {
            display: flex;
            flex-direction: column;
            height: 400px;
            background: rgba(0,0,0,0.2);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .chat-message {
            display: flex;
            gap: 10px;
        }
        
        .chat-message.ai {
            flex-direction: row;
        }
        
        .chat-message.user {
            flex-direction: row-reverse;
        }
        
        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--accent-cyan);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
        }
        
        .chat-message.user .message-avatar {
            background: var(--accent-purple);
        }
        
        .message-content {
            flex: 1;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            max-width: 80%;
        }
        
        .message-text {
            color: var(--text-primary);
            font-size: 0.85rem;
            line-height: 1.4;
        }
        
        .message-time {
            font-size: 0.65rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        .chat-input-area {
            display: flex;
            gap: 8px;
            padding: 10px;
            border-top: 1px solid var(--border-color);
        }
        
        .chat-input {
            flex: 1;
            background: #1a1a1a;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px 12px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
        
        .chat-send {
            padding: 8px 16px;
            background: var(--accent-cyan);
            border: none;
            border-radius: 4px;
            color: #1a1a1a;
            font-weight: 600;
            cursor: pointer;
        }
        
        /* Quick Action Cards */
        .quick-action-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .quick-action-card {
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .quick-action-card:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 212, 170, 0.1);
        }
        
        .action-icon {
            font-size: 1.5rem;
        }
        
        .action-text {
            font-size: 0.7rem;
            color: var(--text-primary);
        }
        
        /* AI Suggestions */
        .ai-suggestions-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .suggestion-card {
            background: rgba(168, 85, 247, 0.1);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 6px;
            padding: 12px;
        }
        
        .suggestion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .suggestion-type {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        
        .suggestion-score {
            font-size: 0.75rem;
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
        }
        
        .suggestion-content {
            font-size: 0.75rem;
            color: var(--text-primary);
            margin-bottom: 8px;
        }
        
        .btn-small {
            padding: 4px 8px;
            font-size: 0.65rem;
        }
        
        /* Workflow Items */
        .workflow-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 10px;
        }
        
        .workflow-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        
        .workflow-name {
            font-size: 0.75rem;
            color: var(--text-primary);
        }
        
        .btn-icon-small {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
        }
        
        /* Performance Analytics */
        .analytics-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .analytics-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .analytics-label {
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        
        .analytics-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .analytics-bar {
            height: 4px;
            background: rgba(0,0,0,0.3);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .analytics-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-orange));
            transition: width 0.3s ease;
        }
        
        /* Tool Buttons */
        .tool-btn {
            padding: 6px 12px;
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tool-btn:hover {
            background: rgba(255,255,255,0.05);
            color: var(--text-primary);
        }
        
        .tool-btn.active {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        .tool-btn-small {
            padding: 4px 8px;
            font-size: 0.65rem;
        }
        
        .tool-palette {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .tool-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .tool-group-title {
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        
        /* Media Search and Filters */
        .media-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }
        
        .media-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .media-search {
            flex: 1;
            background: #1a1a1a;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-primary);
            min-width: 150px;
        }
        
        .media-filter {
            background: #2a2a2a;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--accent-cyan);
            cursor: pointer;
        }
        
        .media-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }
        
        .media-grid-item {
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        
        .media-grid-item:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 212, 170, 0.1);
        }
        
        .media-grid-item.selected {
            border-color: var(--accent-cyan);
            background: rgba(0, 212, 170, 0.2);
        }
        
        /* Features Grid */
        .features-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }
        
        .feature-card {
            background: var(--bg-panel);
            border-radius: 2px;
            padding: 6px;
            text-align: center;
            border: 1px solid var(--border-color);
        }
        
        .feature-label {
            font-size: 9px;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        
        .feature-value {
            font-size: 14px;
            font-weight: 600;
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Selection Info */
        .selection-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        
        .stat-label {
            color: var(--text-secondary);
        }
        
        .stat-value {
            color: var(--accent-cyan);
            font-weight: 600;
        }
        
        /* Library Tab - Browser Panel */
        .browser-panel {
            display: flex;
            flex-direction: column;
        }
        
        .browser-header {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 6px;
        }
        
        .browser-search {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 4px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-primary);
        }
        
        .browser-filter {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 4px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-primary);
        }
        
        /* Enhanced Search Container */
        .search-container {
            position: relative;
            display: flex;
            align-items: center;
        }
        
        .search-clear-btn {
            position: absolute;
            right: 4px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 2px 6px;
            line-height: 1;
        }
        
        .search-clear-btn:hover {
            color: var(--text-primary);
        }
        
        /* Filter Bar */
        .filter-bar {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        
        .filter-chip {
            padding: 3px 8px;
            background: rgba(0, 212, 170, 0.1);
            border: 1px solid rgba(0, 212, 170, 0.3);
            border-radius: 3px;
            font-size: 0.65rem;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }
        
        .filter-chip:hover {
            background: rgba(0, 212, 170, 0.2);
            border-color: var(--accent-cyan);
        }
        
        .filter-chip.active {
            background: var(--accent-cyan);
            color: #1a1a1a;
            border-color: var(--accent-cyan);
        }
        
        /* Search Suggestions */
        .search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            margin-top: 2px;
        }
        
        .search-suggestions.visible {
            display: block;
        }
        
        .suggestion-item {
            padding: 6px 8px;
            cursor: pointer;
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
        }
        
        .suggestion-item:hover {
            background: var(--bg-hover);
        }
        
        .browser-list {
            flex: 1;
            overflow-y: auto;
        }
        
        .browser-item {
            position: relative;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            margin-bottom: 2px;
            background: var(--bg-dark);
            border-radius: 2px;
            cursor: pointer;
            font-size: 9px;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }
        
        .browser-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: transparent;
            transition: background 0.2s ease;
            border-radius: 2px 0 0 2px;
        }
        
        .browser-item:hover {
            background: var(--bg-hover);
        }
        
        /* Visual State Indicators */
        .browser-item.selected {
            background: rgba(0, 212, 170, 0.15);
            border-left-color: var(--accent-cyan);
        }
        
        .browser-item.selected::before {
            background: var(--accent-cyan);
        }
        
        .browser-item.loaded {
            border-left-color: var(--accent-orange);
        }
        
        .browser-item.loaded::before {
            background: var(--accent-orange);
        }
        
        .browser-item.playing {
            animation: pulse-border 1s ease-in-out infinite;
        }
        
        .browser-item.playing::after {
            content: '';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--accent-cyan);
            font-size: 0.8rem;
        }
        
        .browser-item.hover {
            background: rgba(0, 212, 170, 0.1);
        }
        
        .browser-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
            cursor: grabbing;
        }
        
        .browser-item.loading {
            opacity: 0.7;
            pointer-events: none;
        }
        
        .browser-item.loading .item-icon::after {
            content: '';
            margin-left: 4px;
        }
        
        /* Media Thumbnails */
        .item-thumbnail {
            width: 80px;
            height: 24px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 2px;
            overflow: hidden;
            flex-shrink: 0;
        }
        
        .waveform-thumbnail {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .midi-preview {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 0.6rem;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        @keyframes pulse-border {
            0%, 100% { 
                border-color: var(--accent-cyan);
                box-shadow: 0 0 0 0 rgba(0, 212, 170, 0.4);
            }
            50% { 
                border-color: var(--accent-orange);
                box-shadow: 0 0 8px 2px rgba(255, 107, 53, 0.3);
            }
        }
        
        /* Media Status Badge */
        .media-status-badge {
            position: absolute;
            top: 4px;
            right: 4px;
            padding: 2px 6px;
            font-size: 0.6rem;
            border-radius: 3px;
            background: var(--accent-cyan);
            color: #1a1a1a;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            z-index: 1;
        }
        
        .browser-item.loaded .media-status-badge {
            background: var(--accent-orange);
        }
        
        .browser-item.selected .media-status-badge {
            background: var(--accent-cyan);
        }
        
        /* Variable Section */
        .variable-section {
            padding: 6px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            border: 1px solid rgba(0, 212, 170, 0.2);
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .icon-btn {
            width: 20px;
            height: 20px;
            padding: 0;
            border: none;
            background: rgba(0, 212, 170, 0.2);
            border-radius: 3px;
            cursor: pointer;
            color: var(--accent-cyan);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .icon-btn:hover {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        .variable-list {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .variable-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            background: rgba(0, 212, 170, 0.05);
            border-radius: 3px;
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .variable-name {
            flex: 1;
            color: var(--text-primary);
        }
        
        .variable-count {
            color: var(--text-secondary);
            font-size: 0.65rem;
        }
        
        .variable-load-btn {
            padding: 2px 6px;
            background: rgba(0, 212, 170, 0.2);
            border: 1px solid rgba(0, 212, 170, 0.3);
            border-radius: 2px;
            color: var(--accent-cyan);
            cursor: pointer;
            font-size: 0.65rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .variable-load-btn:hover {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        /* Media Groups */
        .media-groups {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .media-group {
            border: 1px solid rgba(0, 212, 170, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .group-header {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            background: rgba(0, 212, 170, 0.05);
            cursor: pointer;
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .group-header:hover {
            background: rgba(0, 212, 170, 0.1);
        }
        
        .group-title {
            flex: 1;
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .group-count {
            color: var(--text-secondary);
            font-size: 0.65rem;
        }
        
        .group-toggle {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.7rem;
            padding: 0;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .group-items {
            max-height: 200px;
            overflow-y: auto;
            display: block;
        }
        
        .media-group.collapsed .group-items {
            display: none;
        }
        
        .media-group.collapsed .group-toggle {
            transform: rotate(-90deg);
        }
        
        /* Media Navigation Compact */
        .media-navigation-compact {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin-top: 8px;
        }
        
        .nav-btn-compact {
            width: 24px;
            height: 24px;
            padding: 0;
            border: none;
            background: rgba(0, 212, 170, 0.1);
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            transition: all 0.2s ease;
            color: var(--text-primary);
        }
        
        .nav-btn-compact:hover {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        .media-position {
            padding: 0 8px;
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .media-position .separator {
            margin: 0 2px;
        }
        
        /* Quick Action Toolbar for Media */
        .quick-action-toolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(26, 26, 26, 0.95);
            border: 1px solid var(--accent-cyan);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
        }
        
        .quick-action-toolbar.visible {
            opacity: 1;
            pointer-events: all;
        }
        
        .quick-action-toolbar::before {
            content: attr(data-count) ' selected';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .quick-action-toolbar-btn {
            padding: 6px 12px;
            background: rgba(0, 212, 170, 0.1);
            border: 1px solid rgba(0, 212, 170, 0.3);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.2s ease;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .quick-action-toolbar-btn:hover {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        /* Batch Progress Indicator */
        .batch-progress {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            background: rgba(26, 26, 26, 0.95);
            border: 1px solid var(--accent-cyan);
            border-radius: 6px;
            color: var(--accent-cyan);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            z-index: 1001;
            display: none;
        }
        
        .item-icon {
            font-size: 12px;
        }
        
        .item-name {
            flex: 1;
            color: var(--text-primary);
        }
        
        .item-time {
            color: var(--text-secondary);
            font-size: 8px;
        }
        
        /* Library Tab - Editor Toolbar */
        .editor-toolbar {
            display: flex;
            gap: 3px;
            margin-bottom: 4px;
            padding: 4px;
            background: var(--bg-dark);
            border-radius: 2px;
        }
        
        .toolbar-group {
            display: flex;
            gap: 2px;
        }
        
        .toolbar-btn {
            padding: 3px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            font-weight: 600;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-secondary);
            cursor: pointer;
            pointer-events: auto !important;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .toolbar-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .toolbar-btn.active {
            background: var(--accent-cyan);
            color: #1a1a1a;
            border-color: var(--accent-cyan);
        }
        
        .toolbar-btn-small {
            padding: 3px 5px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        
        .toolbar-btn-small:hover {
            background: var(--bg-hover);
        }
        
        /* Library Tab - Waveform Compact */
        .waveform-compact {
            background: var(--bg-dark);
            border-radius: 2px;
            padding: 4px;
            margin-bottom: 4px;
        }
        
        .editor-info-bar {
            display: flex;
            gap: 12px;
            font-size: 9px;
            color: var(--text-secondary);
            padding: 2px 4px;
        }
        
        .editor-info-bar strong {
            color: var(--accent-cyan);
        }
        
        /* Library Tab - Piano Roll Compact */
        .piano-roll-compact {
            display: flex;
            background: var(--bg-dark);
            border-radius: 2px;
            padding: 4px;
            margin-bottom: 4px;
        }
        
        .piano-keys-mini {
            width: 30px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border-color);
        }
        
        /* Library Tab - Timeline Compact */
        .timeline-compact {
            background: var(--bg-dark);
            border-radius: 2px;
            padding: 4px;
        }
        
        .timeline-ruler-compact {
            height: 20px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 4px;
        }
        
        .timeline-tracks-compact {
            min-height: 200px;
        }
        
        /* Library Tab - Actions Panel */
        .actions-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .actions-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .action-label {
            font-size: 9px;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 3px;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .action-buttons {
            display: flex;
            gap: 3px;
        }
        
        .action-btn {
            flex: 1;
            padding: 4px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            font-weight: 600;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-primary);
            cursor: pointer;
        }
        
        .action-btn:hover {
            background: var(--bg-hover);
            border-color: var(--border-active);
        }
        
        .action-btn-small {
            flex: 1;
            padding: 3px 5px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        
        .action-btn-small:hover {
            background: var(--bg-hover);
        }
        
        /* Clip Controls */
        .clip-header {
            padding: 4px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 4px;
        }
        
        .clip-controls-row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .clip-control-label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 8px;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .clip-toggle {
            width: 12px;
            height: 12px;
        }
        
        .clip-control-select {
            padding: 2px 4px;
            font-size: 8px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .clip-gain-slider,
        .clip-transpose-slider {
            width: 60px;
            height: 4px;
        }
        
        .clip-color-picker {
            width: 20px;
            height: 16px;
            border: 1px solid var(--border-color);
            border-radius: 2px;
            cursor: pointer;
        }
        
        .clip-color-label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 8px;
            color: var(--text-secondary);
        }
        
        /* Loop Brace */
        .loop-brace {
            position: relative;
            height: 4px;
            background: var(--accent-orange);
            margin-top: 2px;
            border-radius: 2px;
        }
        
        .loop-start,
        .loop-end {
            position: absolute;
            top: -4px;
            width: 2px;
            height: 12px;
            background: var(--accent-orange);
        }
        
        .loop-start {
            left: 0;
        }
        
        .loop-end {
            right: 0;
        }
        
        /* Clip Properties */
        .clip-properties-panel {
            margin-top: 8px;
            padding: 6px;
            background: var(--bg-panel);
            border-radius: 2px;
            border: 1px solid var(--border-color);
        }
        
        .properties-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .property-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 8px;
        }
        
        .property-item label {
            min-width: 80px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
        }
        
        .property-item select {
            flex: 1;
            padding: 2px 4px;
            font-size: 8px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-primary);
        }
        
        /* Piano Roll Enhancements */
        .piano-roll-header {
            padding: 4px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 4px;
        }
        
        .piano-controls-row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .piano-control-label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 8px;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .piano-toggle {
            width: 12px;
            height: 12px;
        }
        
        .piano-control-select {
            padding: 2px 4px;
            font-size: 8px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .piano-roll-main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .velocity-lane,
        .cc-lanes {
            border-top: 1px solid var(--border-color);
            padding: 2px;
            background: var(--bg-dark);
        }
        
        .lane-label {
            font-size: 7px;
            color: var(--text-secondary);
            padding: 2px 4px;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .cc-lane {
            border-top: 1px solid var(--border-color);
        }
        
        /* Timeline Enhancements */
        .timeline-track {
            border-bottom: 1px solid var(--border-color);
        }
        
        .track-header-compact {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 4px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
        }
        
        .track-name-compact {
            flex: 1;
            font-size: 8px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
        }
        
        .track-controls-compact {
            display: flex;
            gap: 2px;
        }
        
        .track-btn-compact {
            width: 16px;
            height: 16px;
            padding: 0;
            font-size: 7px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        
        .track-btn-compact:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .track-btn-compact.active {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        .track-fader-compact {
            width: 20px;
            height: 60px;
        }
        
        .track-lane-compact {
            min-height: 60px;
            position: relative;
            background: var(--bg-dark);
        }
        
        .clip-region-compact {
            position: absolute;
            height: 40px;
            border-radius: 2px;
            padding: 2px 4px;
            cursor: pointer;
            border: 1px solid rgba(0,0,0,0.3);
        }
        
        .clip-label-compact {
            font-size: 7px;
            color: #1a1a1a;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
        }
        
        .automation-lane-compact {
            border-top: 1px solid var(--border-color);
            padding: 2px;
            background: var(--bg-panel);
        }
        
        .lane-label-compact {
            font-size: 7px;
            color: var(--text-secondary);
            padding: 2px 4px;
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Preview Controls */
        .preview-controls-panel {
            margin-top: 12px;
            padding: 6px;
            background: var(--bg-panel);
            border-radius: 2px;
            border: 1px solid var(--border-color);
        }
        
        .preview-controls {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }
        
        .preview-btn {
            flex: 1;
            padding: 4px;
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 10px;
        }
        
        .preview-btn:hover {
            background: var(--bg-hover);
            border-color: var(--border-active);
        }
        
        .preview-btn.active {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        .clip-info-display {
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 8px;
            color: var(--text-secondary);
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .info-item strong {
            color: var(--accent-cyan);
        }
        
        /* Panel Header */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .panel-actions {
            display: flex;
            gap: 5px;
        }
        
        /* Selector Groups */
        .selector-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        /* Device/Clip Items Enhanced */
        .device-item, .clip-item {
            padding: 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        
        .device-item:hover, .clip-item:hover {
            background: rgba(0,0,0,0.3);
            border-color: var(--border-color);
        }
        
        .device-item.selected, .clip-item.selected {
            border-color: var(--accent-cyan);
            background: rgba(0, 212, 170, 0.1);
        }
        
        .device-item-header, .clip-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .device-icon, .clip-icon {
            font-size: 1rem;
        }
        
        .device-name, .clip-name {
            flex: 1;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .device-status, .clip-status {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
        }
        
        .device-status.active {
            background: var(--accent-cyan);
            color: #1a1a1a;
        }
        
        .device-status {
            background: #4a4a4a;
            color: var(--text-secondary);
        }
        
        .clip-status.playing {
            color: var(--accent-cyan);
            animation: pulse 1s infinite;
        }
        
        .device-item-meta, .clip-item-meta {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        /* Spectrum Analyzer */
        .spectrum-analyzer {
            height: 100px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            margin-bottom: 10px;
            position: relative;
        }
        
        #spectrum-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Clip Library */
        .clip-library {
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* History List */
        .history-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .history-item {
            padding: 6px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            font-size: 0.7rem;
            color: var(--text-secondary);
        }
        
        /* Info Popup System */
        .info-popup {
            position: absolute;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 6px 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: var(--text-primary);
            max-width: 250px;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-4px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .info-popup.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .info-popup-title {
            font-weight: 600;
            color: var(--accent-cyan);
            margin-bottom: 3px;
            font-size: 10px;
        }
        
        .info-popup-desc {
            color: var(--text-secondary);
            margin-bottom: 4px;
            line-height: 1.3;
        }
        
        .info-popup-shortcut {
            color: var(--text-tertiary);
            font-size: 8px;
            margin-top: 3px;
            padding-top: 3px;
            border-top: 1px solid var(--border-color);
        }
        
        .info-popup-shortcut kbd {
            background: var(--bg-dark);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 2px 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            color: var(--accent-cyan);
            margin-left: 3px;
        }
        
        .info-popup-arrow {
            position: absolute;
            top: -6px;
            left: 12px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid var(--bg-panel);
        }
        
        .info-popup-arrow::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -6px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid var(--border-color);
        }
        
        .info-popup.above .info-popup-arrow {
            top: auto;
            bottom: -6px;
            border-bottom: none;
            border-top: 6px solid var(--bg-panel);
        }
        
        .info-popup.above .info-popup-arrow::before {
            top: auto;
            bottom: -1px;
            border-bottom: none;
            border-top: 6px solid var(--border-color);
        }
        
        /* Context Menu System */
        .context-menu {
            position: absolute;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: var(--text-primary);
            min-width: 180px;
            z-index: 10001;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: none;
            pointer-events: auto;
        }
        
        .context-menu.visible {
            display: block;
        }
        
        .context-menu-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            cursor: pointer;
            border-radius: 2px;
            transition: background 0.15s ease;
            position: relative;
        }
        
        .context-menu-item:hover:not(.disabled) {
            background: var(--bg-hover);
        }
        
        .context-menu-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .context-menu-item.disabled:hover {
            background: transparent;
        }
        
        .context-menu-separator {
            height: 1px;
            background: var(--border-color);
            margin: 3px 0;
        }
        
        .menu-icon {
            width: 12px;
            text-align: center;
            font-size: 10px;
            color: var(--text-secondary);
        }
        
        .menu-label {
            flex: 1;
            color: var(--text-primary);
        }
        
        .menu-shortcut {
            color: var(--text-tertiary);
            font-size: 8px;
            margin-left: auto;
        }
        
        .menu-arrow {
            color: var(--text-tertiary);
            font-size: 8px;
            margin-left: 4px;
        }
        
        .context-menu-item.has-submenu:hover .context-submenu,
        .context-menu-item.has-submenu.focused .context-submenu {
            display: block;
        }
        
        .context-submenu {
            position: absolute;
            left: 100%;
            top: 0;
            margin-left: 3px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            padding: 3px;
            min-width: 140px;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .context-menu-item.focused {
            background: var(--bg-hover);
        }
        
        .context-menu-item.focused .menu-label {
            color: var(--accent-cyan);
        }
        
        /* Cursor States */
        .editor-content {
            cursor: default;
        }
        
        .editor-content.select-mode {
            cursor: crosshair;
        }
        
        .editor-content.pan-mode {
            cursor: grab;
        }
        
        .editor-content.pan-mode:active {
            cursor: grabbing;
        }
        
        .editor-content.resize-mode {
            cursor: ew-resize;
        }
        
        .editor-content.edit-mode {
            cursor: text;
        }
        
        .editor-content.pointer-mode {
            cursor: pointer;
        }
        
        /* Hotkey and Gesture Feedback */
        .hotkey-feedback,
        .gesture-feedback {
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>SERGIK AI Controller</h1>
            <p>Full Ableton Live Integration | Audio Analysis | DNA Matching | Natural Language Control</p>
        </div>
        
        <!-- Device Preview -->
        <div class="device-wrapper">
            <div class="device">
                <div class="device-header">
                    <div class="device-title">
                        <span class="logo">&#127899;</span>
                        <h2>SERGIK AI CONTROLLER</h2>
                    </div>
                    <div class="device-status">
                        <div class="status-led"></div>
                        <span class="status-text">CONNECTED</span>
                    </div>
                </div>
                
                <!-- Main Tab Navigation -->
                <!-- 
                    NOTE: Mix, Arrange, and Automate tabs have been REMOVED.
                    Only 4 tabs remain: Create, Analyze, Library, and AI.
                    If you see Mix/Arrange/Automate tabs, clear browser cache and reload.
                -->
                <div class="main-tabs">
                    <button class="main-tab-btn active" data-main-tab="create">
                        <span class="icon">&#127929;</span>
                        <span>Create</span>
                    </button>
                    <button class="main-tab-btn" data-main-tab="analyze">
                        <span class="icon">&#129516;</span>
                        <span>Analyze</span>
                    </button>
                    <button class="main-tab-btn" data-main-tab="library">
                        <span class="icon">&#128218;</span>
                        <span>Library</span>
                        <span class="badge" id="library-badge" style="display: none;">0</span>
                    </button>
                    <button class="main-tab-btn" data-main-tab="ai">
                        <span class="icon">&#129302;</span>
                        <span>AI</span>
                    </button>
                    <!-- Mix, Arrange, and Automate tabs removed - do not add them back -->
                </div>
                
                <!-- Create Tab Section -->
                <div class="tab-section active" id="tab-section-create">
                <div class="device-grid">
                    <!-- Left Panel - Generation -->
                    <div class="panel">
                        <div class="panel-title">&#127929; Generate</div>
                        
                        <!-- Audio/MIDI Toggles -->
                        <div class="toggle-row">
                                <label class="toggle-switch" data-info-title="Audio Toggle" data-info-desc="Enable/disable audio generation" data-info-shortcut="">
                                <input type="checkbox" id="toggle-audio" checked>
                                <span class="toggle-slider"></span>
                                <span class="toggle-label">AUDIO</span>
                            </label>
                                <label class="toggle-switch" data-info-title="MIDI Toggle" data-info-desc="Enable/disable MIDI generation" data-info-shortcut="">
                                <input type="checkbox" id="toggle-midi" checked>
                                <span class="toggle-slider"></span>
                                <span class="toggle-label">MIDI</span>
                            </label>
                        </div>
                        
                        <div class="button-grid">
                                <button class="btn btn-generate btn-kicks" data-type="kicks" data-info-title="Generate Kicks" data-info-desc="Generate kick drum samples using AI" data-info-shortcut="">KICKS</button>
                                <button class="btn btn-generate btn-claps" data-type="claps" data-info-title="Generate Claps & Snares" data-info-desc="Generate clap and snare drum samples" data-info-shortcut="">CLAPS N SNARE</button>
                                <button class="btn btn-generate btn-hats" data-type="hats" data-info-title="Generate Hats & Shakers" data-info-desc="Generate hi-hat and shaker samples" data-info-shortcut="">HATS N SHAKER</button>
                                <button class="btn btn-generate btn-perc" data-type="percussion" data-info-title="Generate Percussion" data-info-desc="Generate various percussion samples" data-info-shortcut="">PERCUSSION</button>
                                <button class="btn btn-generate btn-bass" data-type="bass" data-info-title="Generate Bass" data-info-desc="Generate bass sounds and patterns" data-info-shortcut="">BASS</button>
                                <button class="btn btn-generate btn-synths" data-type="synths" data-info-title="Generate Synths & Sounds" data-info-desc="Generate synthesizer sounds and textures" data-info-shortcut="">SYNTHS N SOUN</button>
                                <button class="btn btn-generate btn-vocals" data-type="vocals" data-info-title="Generate Vocals" data-info-desc="Generate vocal samples and phrases" data-info-shortcut="">VOCALS</button>
                                <button class="btn btn-generate btn-fx" data-type="fx" data-info-title="Generate FX" data-info-desc="Generate sound effects and transitions" data-info-shortcut="">FX</button>
                        </div>
                        
                        <div class="panel-title" style="margin-top: 15px;">&#127898; Track Control</div>
                        <div class="button-grid">
                                <button class="btn btn-cyan" data-info-title="Create Track" data-info-desc="Create a new track" data-info-shortcut="">Create</button>
                                <button class="btn btn-gray" data-info-title="Delete Track" data-info-desc="Delete selected track" data-info-shortcut="">Delete</button>
                                <button class="btn btn-yellow" data-info-title="Arm Track" data-info-desc="Arm track for recording" data-info-shortcut="">Arm</button>
                                <button class="btn btn-orange" data-info-title="Mute Track" data-info-desc="Mute/unmute track" data-info-shortcut="">Mute</button>
                                <button class="btn btn-purple" data-info-title="Solo Track" data-info-desc="Solo/unsolo track" data-info-shortcut="">Solo</button>
                                <button class="btn btn-gray" data-info-title="Rename Track" data-info-desc="Rename selected track" data-info-shortcut="">Rename</button>
                        </div>
                    </div>
                    
                    <!-- Center Panel - Display, Dropdowns & Tabbed Input -->
                    <div class="center-panel">
                        <!-- Display with Dropdown Controls -->
                        <div class="display-screen">
                            <div class="display-line" data-info-title="Status Indicator" data-info-desc="Visual status indicator showing device connection and operation state" data-info-shortcut="">
                                <span class="label">Status:</span>
                                <div class="status-indicator" data-info-title="Status Indicator" data-info-desc="LED and text display showing current system status" data-info-shortcut="">
                                    <span class="status-led" id="status-led" data-info-title="Status LED" data-info-desc="Color-coded LED indicator: Green (Ready), Yellow (Processing), Red (Error)" data-info-shortcut=""></span>
                                    <span class="status-text" id="status-text-display" data-info-title="Status Text" data-info-desc="Text description of current status" data-info-shortcut="">Ready</span>
                                </div>
                            </div>
                            <div class="display-line" data-info-title="Idea Input Line" data-info-desc="Musical idea input field with auto-suggestion" data-info-shortcut="">
                                <span class="label" data-info-title="Idea Label" data-info-desc="Label for musical idea input" data-info-shortcut="">Idea:</span>
                                <input type="text" class="idea-input" id="idea-input" 
                                       placeholder="Enter your musical idea or concept..." 
                                       aria-label="Musical idea input"
                                       autocomplete="off"
                                       data-info-title="Musical Idea Input" data-info-desc="Describe your musical concept or idea" data-info-shortcut="">
                            </div>
                            <div class="display-line" data-info-title="Genre Selector Line" data-info-desc="Genre selection dropdown with sub-genre support" data-info-shortcut="">
                                <span class="label" data-info-title="Genre Label" data-info-desc="Label for genre selector" data-info-shortcut="">Genre:</span>
                                <select class="dropdown-select" id="genre-select" 
                                        aria-label="Select music genre" 
                                        aria-describedby="genre-description"
                                        role="combobox"
                                        aria-expanded="false"
                                        aria-controls="subgenre-select"
                                        data-info-title="Genre Selector" data-info-desc="Select the musical genre for generation" data-info-shortcut="">
                                    <optgroup label="Electronic">
                                        <option value="house" selected>House</option>
                                        <option value="tech_house">Tech House</option>
                                        <option value="deep_house">Deep House</option>
                                        <option value="techno">Techno</option>
                                        <option value="disco">Disco</option>
                                        <option value="progressive_house">Progressive House</option>
                                        <option value="minimal">Minimal</option>
                                        <option value="trance">Trance</option>
                                        <option value="hard_techno">Hard Techno</option>
                                        <option value="acid_house">Acid House</option>
                                        <option value="experimental">Experimental</option>
                                        <option value="bass">Bass</option>
                                    </optgroup>
                                    <optgroup label="Hip-Hop & Urban">
                                        <option value="hiphop">Hip-Hop</option>
                                        <option value="boom_bap">Boom Bap</option>
                                        <option value="trap">Trap</option>
                                        <option value="lo_fi">Lo-Fi</option>
                                        <option value="lofi">Lo-Fi (Alt)</option>
                                        <option value="drill">Drill</option>
                                        <option value="afrobeat">Afrobeat</option>
                                    </optgroup>
                                    <optgroup label="Breakbeat & DnB">
                                        <option value="dnb">Drum & Bass</option>
                                        <option value="jungle">Jungle</option>
                                        <option value="breakbeat">Breakbeat</option>
                                        <option value="garage">UK Garage</option>
                                        <option value="2step">2-Step</option>
                                    </optgroup>
                                    <optgroup label="Latin & World">
                                        <option value="reggaeton">Reggaeton</option>
                                        <option value="dembow">Dembow</option>
                                        <option value="reggae">Reggae</option>
                                        <option value="salsa">Salsa</option>
                                        <option value="bossa_nova">Bossa Nova</option>
                                        <option value="samba">Samba</option>
                                    </optgroup>
                                    <optgroup label="Ambient & Downtempo">
                                        <option value="ambient">Ambient</option>
                                        <option value="downtempo">Downtempo</option>
                                        <option value="chillout">Chillout</option>
                                        <option value="trip_hop">Trip-Hop</option>
                                    </optgroup>
                                    <optgroup label="Funk & Soul">
                                        <option value="funk">Funk</option>
                                        <option value="soul">Soul</option>
                                        <option value="r_and_b">R&B</option>
                                        <option value="neo_soul">Neo-Soul</option>
                                    </optgroup>
                                    <optgroup label="Rock & Alternative">
                                        <option value="indie_rock">Indie Rock</option>
                                        <option value="alternative">Alternative</option>
                                        <option value="post_rock">Post-Rock</option>
                                        <option value="psychedelic">Psychedelic</option>
                                    </optgroup>
                                    <optgroup label="Jazz & Fusion">
                                        <option value="jazz">Jazz</option>
                                        <option value="jazz_fusion">Jazz Fusion</option>
                                        <option value="nu_jazz">Nu-Jazz</option>
                                    </optgroup>
                                    <optgroup label="SERGIK DNA">
                                        <option value="sergik_dna">SERGIK DNA</option>
                                        <option value="sergik_dna_hiphop">SERGIK DNA - Hip-Hop</option>
                                        <option value="sergik_dna_funk">SERGIK DNA - Funk</option>
                                        <option value="sergik_dna_house">SERGIK DNA - House</option>
                                        <option value="sergik_dna_soul">SERGIK DNA - Soul</option>
                                        <option value="sergik_dna_reggae">SERGIK DNA - Reggae</option>
                                        <option value="sergik_dna_techno">SERGIK DNA - Techno</option>
                                        <option value="sergik_dna_disco">SERGIK DNA - Disco</option>
                                        <option value="sergik_dna_ambient">SERGIK DNA - Ambient</option>
                                        <option value="sergik_dna_jazz">SERGIK DNA - Jazz</option>
                                        <option value="sergik_dna_dnb">SERGIK DNA - Drum & Bass</option>
                                    </optgroup>
                                </select>
                            </div>
                            <div class="display-line" id="subgenre-line" style="display: none;">
                                <span class="label">Sub-Genre:</span>
                                <select class="dropdown-select" id="subgenre-select"
                                        aria-label="Select sub-genre" 
                                        aria-describedby="subgenre-description"
                                        role="combobox"
                                        aria-expanded="false"
                                        aria-controls="subgenre-select"
                                        data-info-title="Sub-Genre Selector" data-info-desc="Select a sub-genre to further refine your genre selection. Options update based on main genre." data-info-shortcut="">
                                    <option value="">None</option>
                                </select>
                            </div>
                            <div id="genre-description" class="sr-only">Select a music genre to filter available sub-genres</div>
                            <div id="subgenre-description" class="sr-only">Select a sub-genre to further refine your selection</div>
                            <div class="display-line" data-info-title="Tempo Selector Line" data-info-desc="Tempo/BPM selection with follow Live toggle" data-info-shortcut="">
                                <span class="label" data-info-title="Tempo Label" data-info-desc="Label for tempo selector" data-info-shortcut="">Tempo:</span>
                                <select class="dropdown-select orange" id="tempo-select" 
                                        aria-label="Select tempo/BPM for generation"
                                        title="Select tempo/BPM for generation"
                                        data-info-title="Tempo Selector" data-info-desc="Set the BPM (beats per minute) for generation" data-info-shortcut="">
                                    <option value="80">80 BPM (Hip-Hop)</option>
                                    <option value="85">85 BPM (Boom Bap)</option>
                                    <option value="90">90 BPM (Lo-Fi)</option>
                                    <option value="95">95 BPM (Funk)</option>
                                    <option value="100">100 BPM (Disco)</option>
                                    <option value="110">110 BPM (Soul)</option>
                                    <option value="120">120 BPM (House)</option>
                                    <option value="124" selected>124 BPM (House)</option>
                                    <option value="126">126 BPM (Tech House)</option>
                                    <option value="128">128 BPM (EDM)</option>
                                    <option value="130">130 BPM (Techno)</option>
                                    <option value="140">140 BPM (Trap)</option>
                                    <option value="150">150 BPM (DnB)</option>
                                    <option value="170">170 BPM (Jungle)</option>
                                </select>
                                <label class="toggle-switch" style="margin-left: 8px;" title="Follow Live: Sync with Ableton project tempo | Auto Update: Use genre-based tempo" data-info-title="Tempo Mode Toggle" data-info-desc="Toggle between 'Follow Live' (sync with Ableton tempo) and 'Auto Update' (use genre-based tempo suggestions)" data-info-shortcut="">
                                    <input type="checkbox" id="tempo-follow-toggle" data-info-title="Tempo Follow" data-info-desc="When enabled, syncs tempo with Ableton Live project tempo" data-info-shortcut="">
                                    <span class="toggle-slider"></span>
                                    <span class="toggle-label" id="tempo-toggle-label">Auto Update</span>
                                </label>
                            </div>
                            <div class="display-line" data-info-title="Energy Selector Line" data-info-desc="Energy level selector (1-10 scale)" data-info-shortcut="">
                                <span class="label" data-info-title="Energy Label" data-info-desc="Label for energy selector" data-info-shortcut="">Energy:</span>
                                <select class="dropdown-select yellow" id="energy-select" 
                                        aria-label="Select energy level from 1 (Ambient) to 10 (Festival)"
                                        title="Select energy level from 1 (Ambient) to 10 (Festival)"
                                        data-info-title="Energy Level" data-info-desc="Set the energy level from 1 (Ambient) to 10 (Festival)" data-info-shortcut="">
                                    <option value="1">1 - Ambient</option>
                                    <option value="2">2 - Chill</option>
                                    <option value="3">3 - Lo-Fi</option>
                                    <option value="4">4 - Downtempo</option>
                                    <option value="5">5 - Mid-Groove</option>
                                    <option value="6" selected>6 - Groove</option>
                                    <option value="7">7 - Upbeat</option>
                                    <option value="8">8 - High Energy</option>
                                    <option value="9">9 - Peak Time</option>
                                    <option value="10">10 - Festival</option>
                                </select>
                            </div>
                            <div class="display-line" data-info-title="Intelligence Selector Line" data-info-desc="Intelligence category selector with sub-categories" data-info-shortcut="">
                                <span class="label" data-info-title="Intelligence Label" data-info-desc="Label for intelligence selector" data-info-shortcut="">Intelligence:</span>
                                <select class="dropdown-select" id="intelligence-select" 
                                        aria-label="Select intelligence category"
                                        aria-describedby="intelligence-description"
                                        role="combobox"
                                        aria-expanded="false"
                                        aria-controls="intelligence-sub-select"
                                        data-info-title="Intelligence Category" data-info-desc="Select context-aware category (Groovy, Chill, Intense, etc.)" data-info-shortcut="">
                                    <option value="">Select Intelligence Category</option>
                                    <option value="groovy">Groovy</option>
                                    <option value="chill">Chill</option>
                                    <option value="intense">Intense</option>
                                    <option value="calm">Calm</option>
                                    <option value="social">Social</option>
                                    <option value="productivity">Productivity</option>
                                    <option value="creative">Creative</option>
                                    <option value="dance_floor">Dance Floor</option>
                                    <option value="background">Background</option>
                                    <option value="workout">Workout</option>
                                </select>
                            </div>
                            <div class="display-line" id="intelligence-sub-line" style="display: none;">
                                <span class="label">Intelligence Sub:</span>
                                <select class="dropdown-select" id="intelligence-sub-select"
                                        aria-label="Select intelligence sub-category"
                                        aria-describedby="intelligence-sub-description"
                                        title="Select intelligence sub-category"
                                        role="combobox"
                                        aria-expanded="false"
                                        aria-controls="intelligence-sub-select"
                                        data-info-title="Intelligence Sub-Category" data-info-desc="Select a sub-category to further refine your intelligence selection. Options update based on main category." data-info-shortcut="">
                                    <option value="">None</option>
                                </select>
                            </div>
                            <div id="intelligence-description" class="sr-only">Select an intelligence category to refine your selection</div>
                            <div id="intelligence-sub-description" class="sr-only">Select a sub-category to further refine your intelligence selection</div>
                            <div class="display-line" data-info-title="Key Selector Line" data-info-desc="Musical key selector (Camelot wheel notation)" data-info-shortcut="">
                                <span class="label" data-info-title="Key Label" data-info-desc="Label for key selector" data-info-shortcut="">Key:</span>
                                <select class="dropdown-select purple" id="key-select" 
                                        aria-label="Select musical key using Camelot wheel notation"
                                        title="Select musical key using Camelot wheel notation"
                                        data-info-title="Musical Key" data-info-desc="Select the musical key (e.g., D minor, D major)" data-info-shortcut="">
                                    <option value="7A">7A (D minor)</option>
                                    <option value="8A">8A (A minor)</option>
                                    <option value="9A">9A (E minor)</option>
                                    <option value="10A">10A (B minor)</option>
                                    <option value="11A">11A (F# minor)</option>
                                    <option value="12A">12A (Db minor)</option>
                                    <option value="1A">1A (Ab minor)</option>
                                    <option value="2A">2A (Eb minor)</option>
                                    <option value="3A">3A (Bb minor)</option>
                                    <option value="4A">4A (F minor)</option>
                                    <option value="5A">5A (C minor)</option>
                                    <option value="6A">6A (G minor)</option>
                                    <option value="7B">7B (F major)</option>
                                    <option value="8B">8B (C major)</option>
                                    <option value="9B">9B (G major)</option>
                                    <option value="10B" selected>10B (D major)</option>
                                    <option value="11B">11B (A major)</option>
                                    <option value="12B">12B (E major)</option>
                                    <option value="1B">1B (B major)</option>
                                    <option value="2B">2B (F# major)</option>
                                    <option value="3B">3B (Db major)</option>
                                    <option value="4B">4B (Ab major)</option>
                                    <option value="5B">5B (Eb major)</option>
                                    <option value="6B">6B (Bb major)</option>
                                </select>
                            </div>
                            <div class="display-line" data-info-title="Scale Selector Line" data-info-desc="Musical scale/mode selector" data-info-shortcut="">
                                <span class="label" data-info-title="Scale Label" data-info-desc="Label for scale selector" data-info-shortcut="">Scale:</span>
                                <select class="dropdown-select" id="scale-select" 
                                        aria-label="Select musical scale mode (Major, Minor, Dorian, etc.)"
                                        title="Select musical scale mode (Major, Minor, Dorian, etc.)"
                                        data-info-title="Musical Scale" data-info-desc="Select the scale mode (Major, Minor, Dorian, etc.)" data-info-shortcut="">
                                    <option value="major" selected>Major (Ionian)</option>
                                    <option value="minor">Natural Minor (Aeolian)</option>
                                    <option value="dorian">Dorian</option>
                                    <option value="phrygian">Phrygian</option>
                                    <option value="lydian">Lydian</option>
                                    <option value="mixolydian">Mixolydian</option>
                                    <option value="locrian">Locrian</option>
                                    <option value="harmonic_minor">Harmonic Minor</option>
                                    <option value="melodic_minor">Melodic Minor</option>
                                    <option value="pent_major">Pentatonic Major</option>
                                    <option value="pent_minor">Pentatonic Minor</option>
                                    <option value="blues">Blues</option>
                                </select>
                            </div>
                            <div class="display-line" data-info-title="Target Track Line" data-info-desc="Target track selector for generated content" data-info-shortcut="">
                                <span class="label" data-info-title="Target Label" data-info-desc="Label for target track selector" data-info-shortcut="">Target:</span>
                                <select class="dropdown-select" id="track-select" 
                                        aria-label="Select target track for generated content"
                                        title="Select target track for generated content"
                                        data-info-title="Target Track" data-info-desc="Select which track to send generated content to" data-info-shortcut="">
                                    <option value="new">New Track (Auto)</option>
                                    <option value="0">Track 1 - Drums</option>
                                    <option value="1">Track 2 - Bass</option>
                                    <option value="2">Track 3 - Chords</option>
                                    <option value="3">Track 4 - Lead</option>
                                    <option value="4">Track 5 - Vocals</option>
                                    <option value="5">Track 6 - FX</option>
                                    <option value="master">Master</option>
                                </select>
                            </div>
                            <div class="display-line" data-info-title="Slot Selector Line" data-info-desc="Clip slot selector for placing generated content" data-info-shortcut="">
                                <span class="label" data-info-title="Slot Label" data-info-desc="Label for slot selector" data-info-shortcut="">Slot:</span>
                                <select class="dropdown-select required" id="slot-select" title="Clip Slot" aria-label="Select the clip slot to place generated content" data-info-title="Clip Slot" data-info-desc="Select the clip slot to place generated content" data-info-shortcut="">
                                    <option value="" disabled selected>Select slot...</option>
                                    <option value="mouse">Mouse Highlight Selection</option>
                                    <option value="0">Slot 1 (Scene 1)</option>
                                    <option value="1">Slot 2 (Scene 2)</option>
                                    <option value="2">Slot 3 (Scene 3)</option>
                                    <option value="3">Slot 4 (Scene 4)</option>
                                    <option value="4">Slot 5 (Scene 5)</option>
                                    <option value="5">Slot 6 (Scene 6)</option>
                                    <option value="6">Slot 7 (Scene 7)</option>
                                    <option value="7">Slot 8 (Scene 8)</option>
                                    <option value="next">Next Empty Slot</option>
                                    <option value="append">Append to Arrangement</option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- Tabbed Input Interface -->
                        <div class="input-tabs">
                            <button class="tab-btn active" data-tab="file" data-info-title="File Input" data-info-desc="Upload audio file from your computer" data-info-shortcut="">
                                <span class="icon">&#128193;</span>
                                <span>File</span>
                            </button>
                            <button class="tab-btn" data-tab="url" data-info-title="URL Input" data-info-desc="Analyze audio from URL (YouTube, SoundCloud, etc.)" data-info-shortcut="">
                                <span class="icon">&#128279;</span>
                                <span>URL</span>
                            </button>
                            <button class="tab-btn" data-tab="mic" data-info-title="Microphone Input" data-info-desc="Record audio from microphone" data-info-shortcut="">
                                <span class="icon">&#127908;</span>
                                <span>Mic</span>
                            </button>
                            <button class="tab-btn" data-tab="command" data-info-title="Command Input" data-info-desc="Enter text commands for AI generation" data-info-shortcut="">
                                <span class="icon">&#9000;</span>
                                <span>Command</span>
                            </button>
                            <button class="tab-btn" data-tab="clipboard" data-info-title="Clipboard Input" data-info-desc="Paste audio from clipboard" data-info-shortcut="">
                                <span class="icon">&#128203;</span>
                                <span>Clipboard</span>
                            </button>
                        </div>
                        
                        <!-- Tab Contents -->
                        <div class="tab-content active" id="tab-file">
                            <div class="drop-zone" id="drop-zone" data-info-title="File Drop Zone" data-info-desc="Drag and drop audio files here or click to browse" data-info-shortcut="">
                                <span class="icon">&#128194;</span>
                                <p>Drag & drop audio file here</p>
                                <p style="color: var(--accent-cyan);">WAV, MP3, FLAC, AIF</p>
                                <input type="file" id="file-input" accept=".wav,.mp3,.flac,.aif,.aiff,.m4a" data-info-title="File Input" data-info-desc="Browse and select audio files from your computer. Supports WAV, MP3, FLAC, AIF, AIFF, M4A formats" data-info-shortcut="">
                            </div>
                        </div>
                        
                        <div class="tab-content" id="tab-url">
                            <div class="url-input-wrapper">
                                <input type="text" class="url-input" placeholder="Paste YouTube, SoundCloud, or audio URL..." data-info-title="URL Input" data-info-desc="Paste a URL to analyze audio" data-info-shortcut="">
                                <button class="btn btn-cyan" data-info-title="Analyze URL" data-info-desc="Analyze audio from the URL" data-info-shortcut="">Analyze</button>
                            </div>
                            <p style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 8px;">Supports YouTube, SoundCloud, direct audio URLs</p>
                        </div>
                        
                        <div class="tab-content" id="tab-mic">
                            <div class="mic-container">
                                <button class="mic-btn" id="mic-btn" data-info-title="Microphone" data-info-desc="Click to start/stop recording from microphone" data-info-shortcut="">&#127908;</button>
                                <span class="mic-status">Push to talk</span>
                            </div>
                        </div>
                        
                        <div class="tab-content" id="tab-command">
                            <div class="status-display-inline" data-info-title="Status Display" data-info-desc="Shows current system status and operation state" data-info-shortcut="">
                                <span class="status-label">Status:</span>
                                <span class="status-value" id="status-value" data-info-title="Status Value" data-info-desc="Current operation status (Ready, Processing, Error, etc.)" data-info-shortcut="">Ready</span>
                            </div>
                            <textarea class="prompt-input" id="command-input" placeholder='Type command: "Create a tech house chord progression in D minor"' data-info-title="Command Input" data-info-desc="Type natural language commands for AI generation" data-info-shortcut=""></textarea>
                        </div>
                        
                        <div class="tab-content" id="tab-clipboard">
                            <div class="clipboard-container">
                                <button class="paste-btn" id="paste-btn" data-info-title="Paste from Clipboard" data-info-desc="Paste audio URL or file path from clipboard" data-info-shortcut="Ctrl+V">
                                    <span>&#128203;</span>
                                    <span>Paste from Clipboard</span>
                                </button>
                                <span class="mic-status">Paste audio URL or file path</span>
                            </div>
                        </div>
                        
                        <!-- Transport Controls -->
                        <div class="transport">
                            <button class="transport-btn" data-info-title="Rewind" data-info-desc="Rewind playback" data-info-shortcut="">&#9198;</button>
                            <button class="transport-btn" data-info-title="Stop" data-info-desc="Stop playback" data-info-shortcut="Space">&#9209;</button>
                            <button class="transport-btn" data-info-title="Play" data-info-desc="Start playback" data-info-shortcut="Space">&#9654;</button>
                            <button class="transport-btn record" data-info-title="Record" data-info-desc="Start/stop recording" data-info-shortcut="">&#9210;</button>
                            <button class="transport-btn" data-info-title="Forward" data-info-desc="Fast forward playback" data-info-shortcut="">&#9197;</button>
                        </div>
                    </div>
                    
                        <!-- Right Panel - Quick Status -->
                        <div class="panel">
                            <div class="panel-title">&#128203; Status</div>
                            <div class="action-list" style="max-height: 200px; overflow-y: auto;">
                                <div class="action-item success">+ Ready</div>
                            </div>
                            
                            <div class="panel-title" style="margin-top: 15px;">&#128268; Quick</div>
                            <div class="button-grid">
                                <button class="btn btn-cyan" data-info-title="Analyze" data-info-desc="Analyze selected audio" data-info-shortcut="">Analyze</button>
                                <button class="btn btn-orange" data-info-title="Preview" data-info-desc="Preview generated content" data-info-shortcut="">Preview</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Analyze Tab Section -->
                <div class="tab-section" id="tab-section-analyze">
                    <div class="device-grid">
                        <!-- Analysis Results Panel (full width) -->
                    <div class="results-panel">
                        <!-- View Toggle -->
                        <div class="view-toggle">
                            <button class="toggle-btn active" data-view="dna" data-info-title="SERGIK DNA View" data-info-desc="View SERGIK DNA analysis and genre influence" data-info-shortcut="">SERGIK DNA</button>
                            <button class="toggle-btn" data-view="musicbrainz" data-info-title="MusicBrainz View" data-info-desc="View MusicBrainz metadata and tags" data-info-shortcut="">MusicBrainz</button>
                            <button class="toggle-btn" data-view="features" data-info-title="Features View" data-info-desc="View audio features (BPM, key, energy, etc.)" data-info-shortcut="">Features</button>
                        </div>
                        
                        <!-- SERGIK DNA View -->
                        <div class="view-content active" id="view-dna">
                            <!-- DNA Gauge -->
                            <div class="dna-gauge">
                                <div class="gauge-header">
                                    <span class="gauge-label">DNA Score</span>
                                    <span class="gauge-value" id="dna-score">78%</span>
                                </div>
                                <div class="gauge-bar">
                                    <div class="gauge-fill" style="width: 78%;"></div>
                                </div>
                            </div>
                            
                            <!-- Genre Influence Bars (Top 10) -->
                            <div class="genre-bars">
                                <div class="panel-title">Genre Influence (Top 10)</div>
                                <!-- Genre bars will be dynamically populated by updateDNAView() -->
                                <div class="genre-bar">
                                    <div class="genre-bar-header">
                                        <span class="genre-bar-name">Hip-Hop</span>
                                        <span class="genre-bar-value">42%</span>
                                    </div>
                                    <div class="genre-bar-track">
                                        <div class="genre-bar-fill hiphop" style="width: 42%;"></div>
                                    </div>
                                </div>
                                
                                <div class="genre-bar">
                                    <div class="genre-bar-header">
                                        <span class="genre-bar-name">House</span>
                                        <span class="genre-bar-value">28%</span>
                                    </div>
                                    <div class="genre-bar-track">
                                        <div class="genre-bar-fill house" style="width: 28%;"></div>
                                    </div>
                                </div>
                                
                                <div class="genre-bar">
                                    <div class="genre-bar-header">
                                        <span class="genre-bar-name">Funk</span>
                                        <span class="genre-bar-value">17%</span>
                                    </div>
                                    <div class="genre-bar-track">
                                        <div class="genre-bar-fill funk" style="width: 17%;"></div>
                                    </div>
                                </div>
                                
                                <div class="genre-bar">
                                    <div class="genre-bar-header">
                                        <span class="genre-bar-name">Soul</span>
                                        <span class="genre-bar-value">13%</span>
                                    </div>
                                    <div class="genre-bar-track">
                                        <div class="genre-bar-fill soul" style="width: 13%;"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Suggestions -->
                            <div class="suggestions">
                                <div class="panel-title">Suggestions</div>
                                <div class="suggestion-item">Great match! Keep the groove at 5-7 energy.</div>
                                <div class="suggestion-item">Try compatible key 11B for transition.</div>
                            </div>
                        </div>
                        
                        <!-- MusicBrainz View -->
                        <div class="view-content" id="view-musicbrainz">
                            <!-- Track Info -->
                            <div class="mb-track-info">
                                <div class="track-title" id="mb-title">Track Title</div>
                                <div class="track-artist" id="mb-artist">Artist Name</div>
                                <div class="track-album" id="mb-album">Album Name (2024)</div>
                            </div>
                            
                            <!-- Genre Influence Bars (Top 10) -->
                            <div class="genre-bars">
                                <div class="panel-title">Genre Analysis (Top 10)</div>
                                
                                <div class="genre-bar">
                                    <div class="genre-bar-header">
                                        <span class="genre-bar-name">Electronic</span>
                                        <span class="genre-bar-value">65%</span>
                                    </div>
                                    <div class="genre-bar-track">
                                        <div class="genre-bar-fill house" style="width: 65%;"></div>
                                    </div>
                                </div>
                                
                                <div class="genre-bar">
                                    <div class="genre-bar-header">
                                        <span class="genre-bar-name">Dance</span>
                                        <span class="genre-bar-value">45%</span>
                                    </div>
                                    <div class="genre-bar-track">
                                        <div class="genre-bar-fill funk" style="width: 45%;"></div>
                                    </div>
                                </div>
                                
                                <div class="genre-bar">
                                    <div class="genre-bar-header">
                                        <span class="genre-bar-name">R&B</span>
                                        <span class="genre-bar-value">30%</span>
                                    </div>
                                    <div class="genre-bar-track">
                                        <div class="genre-bar-fill soul" style="width: 30%;"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Suggestions -->
                            <div class="suggestions">
                                <div class="panel-title">Production Tips</div>
                                <div class="suggestion-item">Add sidechain compression for punch.</div>
                                <div class="suggestion-item">Layer with analog warmth.</div>
                            </div>
                            
                            <!-- Tags -->
                            <div class="panel-title" style="margin-top: 10px;">Tags</div>
                            <div class="mb-tags">
                                <span class="mb-tag">electronic</span>
                                <span class="mb-tag">dance</span>
                                <span class="mb-tag">groovy</span>
                                <span class="mb-tag">upbeat</span>
                                <span class="mb-tag">synth</span>
                            </div>
                        </div>
                        
                        <!-- Features View -->
                        <div class="view-content" id="view-features">
                            <div class="features-grid">
                                <div class="feature-card">
                                    <div class="feature-label">BPM</div>
                                    <div class="feature-value" id="feature-bpm">124</div>
                                </div>
                                <div class="feature-card">
                                    <div class="feature-label">Key</div>
                                    <div class="feature-value" id="feature-key">10B</div>
                                </div>
                                <div class="feature-card">
                                    <div class="feature-label">Energy</div>
                                    <div class="feature-value" id="feature-energy">6</div>
                                </div>
                                <div class="feature-card">
                                    <div class="feature-label">LUFS</div>
                                    <div class="feature-value" id="feature-lufs">-14.2</div>
                                </div>
                                <div class="feature-card">
                                    <div class="feature-label">Spectral Centroid</div>
                                    <div class="feature-value" id="feature-centroid">3200 Hz</div>
                                </div>
                                <div class="feature-card">
                                    <div class="feature-label">Stereo Width</div>
                                    <div class="feature-value" id="feature-width">0.85</div>
                                </div>
                            </div>
                            </div>
                        </div>
                        
                        <!-- Commit Section -->
                        <div class="commit-section">
                            <div class="commit-header">
                                <div class="panel-title" style="margin: 0;">Clip Placement</div>
                                <span class="placement-indicator waiting" id="placement-indicator">Select slot...</span>
                            </div>
                            <button class="commit-btn" id="commit-btn" disabled>
                                <span class="icon">&#127916;</span>
                                <span>Commit to Track</span>
                            </button>
                        </div>
                        
                        <!-- Sidebar - Analysis Controls -->
                        <div class="panel">
                            <div class="panel-title">&#129516; Analysis</div>
                            <div class="button-grid">
                                <button class="btn btn-cyan" data-info-title="Analyze File" data-info-desc="Analyze audio file" data-info-shortcut="">Analyze File</button>
                                <button class="btn btn-orange" data-info-title="Analyze URL" data-info-desc="Analyze audio from URL" data-info-shortcut="">Analyze URL</button>
                                <button class="btn btn-purple" data-info-title="DNA Match" data-info-desc="Match audio to SERGIK DNA" data-info-shortcut="">DNA Match</button>
                                <button class="btn btn-yellow" data-info-title="Export" data-info-desc="Export analysis results" data-info-shortcut="">Export</button>
                    </div>
                    
                            <div class="panel-title" style="margin-top: 15px;">&#128203; Recent</div>
                            <div class="action-list" style="max-height: 200px; overflow-y: auto;">
                                <div class="action-item success">+ Analyzed audio</div>
                                <div class="action-item success">+ DNA: 78%</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Library Tab Section -->
                <div class="tab-section" id="tab-section-library">
                    <div class="device-grid">
                        <!-- Left: Browser -->
                        <div class="panel browser-panel">
                            <div class="browser-header">
                                <div class="search-container">
                                    <input type="text" class="browser-search" id="media-search" placeholder="Search... (BPM:120, key:C, name:kick)" autocomplete="off" data-info-title="Media Search" data-info-desc="Search media library. Use BPM:120, key:C, name:kick syntax. Press Enter to load first result." data-info-shortcut="Enter">
                                    <button class="search-clear-btn" id="search-clear" style="display: none;" data-info-title="Clear Search" data-info-desc="Clear search query" data-info-shortcut="Esc"></button>
                                </div>
                                <div class="filter-bar">
                                    <button class="filter-chip active" data-filter="all" data-info-title="All Media" data-info-desc="Show all media" data-info-shortcut="">All</button>
                                    <button class="filter-chip" data-filter="audio" data-info-title="Audio Only" data-info-desc="Show audio files only" data-info-shortcut="">Audio</button>
                                    <button class="filter-chip" data-filter="midi" data-info-title="MIDI Only" data-info-desc="Show MIDI files only" data-info-shortcut="">MIDI</button>
                                    <button class="filter-chip" data-filter="variables" data-info-title="Variables" data-info-desc="Show variables" data-info-shortcut="">Variables</button>
                                    <button class="filter-chip" data-filter="recent" data-info-title="Recent" data-info-desc="Show recently used media" data-info-shortcut="">Recent</button>
                                </div>
                                <div class="search-suggestions" id="search-suggestions"></div>
                            </div>
                            <div class="media-groups" id="media-groups">
                                <!-- Recent Group -->
                                <div class="media-group" data-group="recent">
                                    <div class="group-header">
                                        <span class="group-title">Recent</span>
                                        <span class="group-count">(0)</span>
                                        <button class="group-toggle"></button>
                                    </div>
                                    <div class="group-items">
                                        <!-- Recent items will be rendered here -->
                                    </div>
                        </div>
                        
                                <!-- Variables Group -->
                                <div class="media-group" data-group="variables">
                                    <div class="group-header">
                                        <span class="group-title">Variables</span>
                                        <span class="group-count">(0)</span>
                                        <button class="group-toggle"></button>
                                </div>
                                    <div class="group-items">
                                        <!-- Variable items will be rendered here -->
                            </div>
                        </div>
                        
                                <!-- All Media Group -->
                                <div class="media-group active" data-group="all">
                                    <div class="group-header">
                                        <span class="group-title">All Media</span>
                                        <span class="group-count">(0)</span>
                                        <button class="group-toggle"></button>
                                    </div>
                                    <div class="group-items browser-list" id="media-list">
                                        <div class="browser-item" data-media-id="sample-1" data-media-type="audio" data-info-title="Media Item" data-info-desc="Click to select and preview, double-click to load" data-info-shortcut="Enter">
                                            <span class="item-icon"></span>
                                            <span class="item-name">Kick_01.wav</span>
                                            <span class="item-time">0:04</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                            <!-- Media Navigation -->
                            <div class="media-navigation-compact" id="media-navigation">
                                <button class="nav-btn-compact" id="prev-media" data-info-title="Previous Media" data-info-desc="Load previous media item" data-info-shortcut=""></button>
                                <div class="media-position">
                                    <span id="current-media-index">-</span>
                                    <span class="separator">/</span>
                                    <span id="total-media-count">0</span>
                                </div>
                                <button class="nav-btn-compact" id="next-media" data-info-title="Next Media" data-info-desc="Load next media item" data-info-shortcut=""></button>
                                <button class="nav-btn-compact" id="random-media" data-info-title="Random Media" data-info-desc="Load random media item" data-info-shortcut="R"></button>
                            </div>
                        </div>
                        
                        <!-- Center: Editor -->
                        <div class="panel editor-preview-panel">
                            <div class="editor-toolbar">
                                <div class="toolbar-group">
                                    <button class="toolbar-btn active" data-tool="select" data-info-title="Select Tool" data-info-desc="Select and move items" data-info-shortcut="">S</button>
                                    <button class="toolbar-btn" data-tool="cut" data-info-title="Cut Tool" data-info-desc="Cut audio/MIDI at cursor" data-info-shortcut="">C</button>
                                    <button class="toolbar-btn" data-tool="fade" data-info-title="Fade Tool" data-info-desc="Apply fade in/out" data-info-shortcut="">F</button>
                                </div>
                                <div class="toolbar-group">
                                    <button class="toolbar-btn" data-tool="waveform" data-info-title="Waveform Editor" data-info-desc="Edit audio waveform" data-info-shortcut="">W</button>
                                    <button class="toolbar-btn" data-tool="piano" data-info-title="Piano Roll Editor" data-info-desc="Edit MIDI notes" data-info-shortcut="">P</button>
                                    <button class="toolbar-btn" data-tool="timeline" data-info-title="Timeline Editor" data-info-desc="Edit arrangement timeline" data-info-shortcut="">T</button>
                                </div>
                                <div class="toolbar-group">
                                    <button class="toolbar-btn-small" id="zoom-in" data-info-title="Zoom In" data-info-desc="Zoom in on editor" data-info-shortcut="">+</button>
                                    <button class="toolbar-btn-small" id="zoom-out" data-info-title="Zoom Out" data-info-desc="Zoom out on editor" data-info-shortcut="">-</button>
                                </div>
                            </div>
                            
                            <div class="editor-content active" id="editor-waveform">
                                <div class="waveform-compact">
                                    <!-- Clip Header with Controls -->
                                    <div class="clip-header">
                                        <div class="clip-controls-row">
                                            <label class="clip-control-label" data-info-title="Warp Toggle" data-info-desc="Enable/disable warping for audio clip" data-info-shortcut="">
                                                <input type="checkbox" id="warp-toggle" class="clip-toggle">
                                                <span>Warp</span>
                                            </label>
                                            <select class="clip-control-select" id="warp-mode" data-info-title="Warp Mode" data-info-desc="Select warp algorithm: Beats, Tones, Texture, Repitch, Complex, Complex Pro" data-info-shortcut="">
                                                <option value="beats">Beats</option>
                                                <option value="tones">Tones</option>
                                                <option value="texture">Texture</option>
                                                <option value="repitch">Repitch</option>
                                                <option value="complex">Complex</option>
                                                <option value="complex-pro">Complex Pro</option>
                                            </select>
                                            <label class="clip-control-label" data-info-title="Clip Gain" data-info-desc="Adjust clip gain in dB (-12 to +12)" data-info-shortcut="">
                                                <span>Gain:</span>
                                                <input type="range" id="clip-gain" min="-12" max="12" value="0" step="0.1" class="clip-gain-slider">
                                                <span id="clip-gain-value">0.0 dB</span>
                                            </label>
                                            <label class="clip-control-label" data-info-title="Transpose" data-info-desc="Transpose clip in semitones (-48 to +48)" data-info-shortcut="">
                                                <span>Transpose:</span>
                                                <input type="range" id="clip-transpose" min="-48" max="48" value="0" step="1" class="clip-transpose-slider">
                                                <span id="clip-transpose-value">0 st</span>
                                            </label>
                                        </div>
                                    </div>
                                    <canvas id="waveform-canvas" style="height: 90px;"></canvas>
                                    <!-- Loop Brace Visualization -->
                                    <div class="loop-brace" id="loop-brace" style="display: none;">
                                        <div class="loop-start"></div>
                                        <div class="loop-end"></div>
                                    </div>
                                </div>
                                <div class="editor-info-bar" data-info-title="Waveform Info Bar" data-info-desc="Displays waveform length and selection time information" data-info-shortcut="">
                                    <span data-info-title="Length Display" data-info-desc="Total length of the audio waveform" data-info-shortcut="">Len: <strong id="waveform-length" data-info-title="Waveform Length" data-info-desc="Total duration of the audio file in minutes:seconds format" data-info-shortcut="">0:00</strong></span>
                                    <span data-info-title="Selection Display" data-info-desc="Duration of currently selected region" data-info-shortcut="">Sel: <strong id="waveform-selection-time" data-info-title="Selection Time" data-info-desc="Duration of selected audio region in minutes:seconds format" data-info-shortcut="">0:00</strong></span>
                                    <span data-info-title="BPM Display" data-info-desc="Beats per minute of the clip" data-info-shortcut="">BPM: <strong id="waveform-bpm" data-info-title="Waveform BPM" data-info-desc="BPM of the audio clip" data-info-shortcut="">120</strong></span>
                                    <span data-info-title="Sample Rate Display" data-info-desc="Sample rate of the audio file" data-info-shortcut="">SR: <strong id="waveform-sr" data-info-title="Waveform Sample Rate" data-info-desc="Sample rate in Hz" data-info-shortcut="">44100</strong> Hz</span>
                                    <label class="clip-color-label" data-info-title="Clip Color" data-info-desc="Set clip color for visual organization" data-info-shortcut="">
                                        <span>Color:</span>
                                        <input type="color" id="clip-color" value="#00d4aa" class="clip-color-picker">
                                    </label>
                                </div>
                                <!-- Clip Properties Panel -->
                                <div class="clip-properties-panel">
                                    <div class="properties-group">
                                        <div class="property-item">
                                            <label data-info-title="Launch Mode Label" data-info-desc="Label for launch mode selector" data-info-shortcut="">Launch Mode:</label>
                                            <select id="launch-mode" data-info-title="Launch Mode" data-info-desc="How clip launches: Trigger, Gate, Toggle, Repeat" data-info-shortcut="">
                                                <option value="trigger">Trigger</option>
                                                <option value="gate">Gate</option>
                                                <option value="toggle">Toggle</option>
                                                <option value="repeat">Repeat</option>
                                            </select>
                                        </div>
                                        <div class="property-item">
                                            <label data-info-title="Launch Quantization Label" data-info-desc="Label for launch quantization selector" data-info-shortcut="">Launch Quantization:</label>
                                            <select id="launch-quantization" data-info-title="Launch Quantization" data-info-desc="When clip launches relative to grid" data-info-shortcut="">
                                                <option value="none">None</option>
                                                <option value="8">8 bars</option>
                                                <option value="4">4 bars</option>
                                                <option value="2">2 bars</option>
                                                <option value="1">1 bar</option>
                                                <option value="1/2">1/2</option>
                                                <option value="1/4">1/4</option>
                                                <option value="1/8">1/8</option>
                                            </select>
                                        </div>
                                        <div class="property-item">
                                            <label data-info-title="Follow Action Label" data-info-desc="Label for follow action selector" data-info-shortcut="">Follow Action:</label>
                                            <select id="follow-action" data-info-title="Follow Action" data-info-desc="What happens after clip finishes" data-info-shortcut="">
                                                <option value="none">None</option>
                                                <option value="next">Next</option>
                                                <option value="previous">Previous</option>
                                                <option value="first">First</option>
                                                <option value="random">Random</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="editor-content" id="editor-piano-roll">
                                <div class="piano-roll-compact">
                                    <!-- Piano Roll Header -->
                                    <div class="piano-roll-header">
                                        <div class="piano-controls-row">
                                            <label class="piano-control-label" data-info-title="Grid Display Toggle" data-info-desc="Show/hide quantization grid" data-info-shortcut="">
                                                <input type="checkbox" id="grid-display" checked class="piano-toggle">
                                                <span>Grid</span>
                                            </label>
                                            <label class="piano-control-label" data-info-title="Note Names Toggle" data-info-desc="Show note names (C, C#, D, etc.)" data-info-shortcut="">
                                                <input type="checkbox" id="note-names" class="piano-toggle">
                                                <span>Names</span>
                                            </label>
                                            <label class="piano-control-label" data-info-title="Scale Highlight Toggle" data-info-desc="Highlight notes in selected scale" data-info-shortcut="">
                                                <input type="checkbox" id="scale-highlight" class="piano-toggle">
                                                <span>Scale</span>
                                            </label>
                                            <select class="piano-control-select" id="scale-selector" data-info-title="Scale Selector" data-info-desc="Select scale to highlight" data-info-shortcut="">
                                                <option value="major">Major</option>
                                                <option value="minor">Minor</option>
                                                <option value="dorian">Dorian</option>
                                                <option value="mixolydian">Mixolydian</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="piano-roll-main">
                                        <div class="piano-keys-mini" id="piano-keys"></div>
                                        <canvas id="piano-roll-canvas" style="height: 160px;"></canvas>
                                        <!-- Velocity Lane -->
                                        <div class="velocity-lane" id="velocity-lane">
                                            <div class="lane-label" data-info-title="Velocity Lane Label" data-info-desc="Label for velocity lane" data-info-shortcut="">Velocity</div>
                                            <canvas id="velocity-canvas" style="height: 40px;"></canvas>
                                        </div>
                                        <!-- CC Lanes -->
                                        <div class="cc-lanes" id="cc-lanes">
                                            <div class="cc-lane" data-cc="1" data-info-title="Modulation CC Lane" data-info-desc="MIDI CC1 (Modulation) lane" data-info-shortcut="">
                                                <div class="lane-label" data-info-title="CC Lane Label" data-info-desc="Label for CC lane" data-info-shortcut="">Modulation (CC1)</div>
                                                <canvas class="cc-canvas" style="height: 30px;"></canvas>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="editor-info-bar" data-info-title="Piano Roll Info Bar" data-info-desc="Displays MIDI note velocity and quantization settings" data-info-shortcut="">
                                    <label data-info-title="Velocity Control" data-info-desc="Adjust velocity for selected MIDI notes or new notes" data-info-shortcut="">Vel: <input type="range" id="velocity-slider" min="1" max="127" value="100" style="width: 60px;" data-info-title="Velocity Slider" data-info-desc="Adjust MIDI note velocity from 1 (softest) to 127 (loudest). Affects selected notes or new notes being added." data-info-shortcut="Shift+V"> <span id="velocity-value" data-info-title="Velocity Value" data-info-desc="Current velocity value (1-127)" data-info-shortcut="">100</span></label>
                                    <label data-info-title="Quantize Control" data-info-desc="Set quantization grid for MIDI notes" data-info-shortcut="">Qtz: <select id="quantize-value" style="width: 45px;" data-info-title="Quantize Grid" data-info-desc="Set quantization grid: 1/32 (32nd notes), 1/16 (16th notes), 1/8 (8th notes), 1/4 (quarter notes), etc. Notes snap to this grid when quantized." data-info-shortcut="Q"><option value="1/16" selected>1/16</option></select></label>
                                    <label data-info-title="Fold Octaves Toggle" data-info-desc="Show only used octaves" data-info-shortcut="">Fold: <input type="checkbox" id="fold-octaves" data-info-title="Fold Octaves" data-info-desc="Fold unused octaves to show only active range" data-info-shortcut=""></label>
                                </div>
                            </div>
                            
                            <div class="editor-content" id="editor-timeline">
                                <div class="timeline-compact">
                                    <div class="timeline-ruler-compact" id="timeline-ruler"></div>
                                    <div class="timeline-tracks-compact" id="timeline-tracks">
                                        <!-- Track Structure Example -->
                                        <div class="timeline-track" data-track="0" data-info-title="Timeline Track" data-info-desc="Track in timeline with controls and clips" data-info-shortcut="">
                                            <div class="track-header-compact" data-info-title="Track Header" data-info-desc="Track name and control buttons" data-info-shortcut="">
                                                <div class="track-name-compact" data-info-title="Track Name" data-info-desc="Name of the track" data-info-shortcut="">Track 1</div>
                                                <div class="track-controls-compact">
                                                    <button class="track-btn-compact" data-action="mute" data-info-title="Track Mute" data-info-desc="Mute/unmute this track" data-info-shortcut="M">M</button>
                                                    <button class="track-btn-compact" data-action="solo" data-info-title="Track Solo" data-info-desc="Solo/unsolo this track" data-info-shortcut="S">S</button>
                                                    <button class="track-btn-compact" data-action="arm" data-info-title="Track Arm" data-info-desc="Arm track for recording" data-info-shortcut="R">R</button>
                                                </div>
                                                <div class="track-fader-compact" data-info-title="Track Volume Fader" data-info-desc="Vertical volume fader for track" data-info-shortcut="">
                                                    <input type="range" class="track-volume" id="track-volume-0" min="0" max="100" value="75" style="writing-mode: vertical-lr; direction: rtl;" data-info-title="Track Volume" data-info-desc="Track volume fader (0-100)" data-info-shortcut="">
                                                </div>
                                            </div>
                                            <div class="track-lane-compact" data-info-title="Track Lane" data-info-desc="Timeline lane where clips are placed" data-info-shortcut="">
                                                <!-- Clips will be rendered here -->
                                            </div>
                                            <!-- Automation Lane -->
                                            <div class="automation-lane-compact" data-param="volume" data-info-title="Automation Lane" data-info-desc="Automation lane for track parameters" data-info-shortcut="">
                                                <div class="lane-label-compact" data-info-title="Automation Lane Label" data-info-desc="Label for automation lane" data-info-shortcut="">Volume</div>
                                                <canvas class="automation-canvas-compact" style="height: 30px;"></canvas>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="editor-info-bar" data-info-title="Timeline Info Bar" data-info-desc="Displays timeline track and clip information" data-info-shortcut="">
                                    <span data-info-title="Track Count Display" data-info-desc="Number of tracks in timeline" data-info-shortcut="">Tracks: <strong id="timeline-track-count" data-info-title="Timeline Track Count" data-info-desc="Total number of tracks" data-info-shortcut="">1</strong></span>
                                    <span data-info-title="Clip Count Display" data-info-desc="Number of clips in timeline" data-info-shortcut="">Clips: <strong id="timeline-clip-count" data-info-title="Timeline Clip Count" data-info-desc="Total number of clips" data-info-shortcut="">0</strong></span>
                                    <label data-info-title="Track Height Control" data-info-desc="Adjust track height" data-info-shortcut="">Track Height: <input type="range" id="track-height" min="30" max="200" value="80" data-info-title="Track Height Slider" data-info-desc="Adjust track height (30-200px)" data-info-shortcut=""></label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Right: Actions -->
                        <div class="panel actions-panel">
                            <div class="actions-group">
                                <div class="action-label">Actions</div>
                                <div class="action-buttons">
                                    <button class="action-btn" id="action-insert" data-info-title="Insert" data-info-desc="Insert selected media into arrangement" data-info-shortcut="">Insert</button>
                                    <button class="action-btn" id="action-replace" data-info-title="Replace" data-info-desc="Replace current clip with selected media" data-info-shortcut="">Replace</button>
                                </div>
                                <div class="action-buttons">
                                    <button class="action-btn" id="action-commit" data-info-title="Commit" data-info-desc="Commit changes to project" data-info-shortcut="">Commit</button>
                                    <button class="action-btn" id="action-duplicate" data-info-title="Duplicate" data-info-desc="Duplicate selected item" data-info-shortcut="">Dup</button>
                                </div>
                            </div>
                            <div class="actions-group">
                                <div class="action-label">Edit</div>
                                <div class="action-buttons">
                                    <button class="action-btn-small" id="tool-copy" data-info-title="Copy" data-info-desc="Copy selection to clipboard" data-info-shortcut="Ctrl+C">Copy</button>
                                    <button class="action-btn-small" id="tool-paste" data-info-title="Paste" data-info-desc="Paste from clipboard" data-info-shortcut="Ctrl+V">Paste</button>
                                </div>
                            </div>
                            <!-- Preview Controls Panel -->
                            <div class="preview-controls-panel">
                                <div class="panel-title" data-info-title="Preview Panel Title" data-info-desc="Section header for preview controls" data-info-shortcut="">Preview</div>
                                <div class="preview-controls">
                                    <button class="preview-btn" id="preview-play" data-info-title="Preview Play" data-info-desc="Play selected clip/media" data-info-shortcut="Space"></button>
                                    <button class="preview-btn" id="preview-stop" data-info-title="Preview Stop" data-info-desc="Stop preview" data-info-shortcut="Space"></button>
                                    <button class="preview-btn" id="preview-loop" data-info-title="Preview Loop" data-info-desc="Toggle loop preview" data-info-shortcut="L"></button>
                                </div>
                                <div class="clip-info-display" data-info-title="Clip Info Display" data-info-desc="Information about current clip" data-info-shortcut="">
                                    <div class="info-item" data-info-title="BPM Info Item" data-info-desc="BPM information" data-info-shortcut=""><span>BPM:</span> <strong id="clip-info-bpm" data-info-title="Clip BPM" data-info-desc="BPM of the clip" data-info-shortcut="">120</strong></div>
                                    <div class="info-item" data-info-title="Key Info Item" data-info-desc="Key information" data-info-shortcut=""><span>Key:</span> <strong id="clip-info-key" data-info-title="Clip Key" data-info-desc="Musical key of the clip" data-info-shortcut="">C</strong></div>
                                    <div class="info-item" data-info-title="Length Info Item" data-info-desc="Length information" data-info-shortcut=""><span>Length:</span> <strong id="clip-info-length" data-info-title="Clip Length" data-info-desc="Length in bars" data-info-shortcut="">4 bars</strong></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Edit Tab Section - REMOVED (merged into Library) -->
                
                <!-- 
                    Mix, Arrange, and Automate Tab Sections - REMOVED
                    These tabs have been completely removed from the interface.
                    Only Create, Analyze, Library, and AI tabs remain active.
                    If you see these tabs in the UI, clear browser cache and reload.
                -->
                
                <!-- AI Tab Section -->
                <div class="tab-section" id="tab-section-ai">
                    <div class="device-grid">
                        <!-- AI Assistant Panel -->
                        <div class="panel">
                            <div class="panel-header">
                                <div class="panel-title">&#129302; AI Assistant</div>
                                <div class="panel-actions">
                                    <button class="btn-icon" id="ai-clear" data-info-title="Clear Chat" data-info-desc="Clear all chat messages and start a new conversation with AI assistant" data-info-shortcut="">Clear</button>
                                </div>
                            </div>
                            
                            <!-- Chat Interface -->
                            <div class="ai-chat" id="ai-chat">
                                <div class="chat-messages" id="chat-messages">
                                    <div class="chat-message ai" data-info-title="AI Message" data-info-desc="Message from AI assistant. AI can help with music creation, analysis, and workflow suggestions." data-info-shortcut="">
                                        <div class="message-avatar" data-info-title="AI Avatar" data-info-desc="Avatar icon for AI assistant" data-info-shortcut="">&#129302;</div>
                                        <div class="message-content" data-info-title="Message Content" data-info-desc="AI message text and timestamp" data-info-shortcut="">
                                            <div class="message-text" data-info-title="Message Text" data-info-desc="Text content of the AI message" data-info-shortcut="">Hello! I'm your AI assistant. How can I help you create music today?</div>
                                            <div class="message-time" data-info-title="Message Time" data-info-desc="Timestamp when message was sent" data-info-shortcut="">Just now</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="chat-input-area">
                                    <input type="text" class="chat-input" id="chat-input" placeholder="Ask me anything..." data-info-title="AI Chat Input" data-info-desc="Type your question or command for AI assistant" data-info-shortcut="">
                                    <button class="chat-send" id="chat-send" data-info-title="Send Message" data-info-desc="Send message to AI assistant" data-info-shortcut="Enter">Send</button>
                                </div>
                            </div>
                            
                            <!-- Quick Actions -->
                            <div class="ai-quick-actions" style="margin-top: 15px;">
                                <div class="panel-title">Quick Actions</div>
                                <div class="quick-action-grid">
                                    <button class="quick-action-card" data-action="suggest-genre" data-info-title="Suggest Genre" data-info-desc="Get AI genre suggestions" data-info-shortcut="">
                                        <span class="action-icon">&#127929;</span>
                                        <span class="action-text">Suggest Genre</span>
                                    </button>
                                    <button class="quick-action-card" data-action="match-dna" data-info-title="DNA Match" data-info-desc="Match audio to SERGIK DNA" data-info-shortcut="">
                                        <span class="action-icon">&#129516;</span>
                                        <span class="action-text">DNA Match</span>
                                    </button>
                                    <button class="quick-action-card" data-action="find-similar" data-info-title="Find Similar" data-info-desc="Find similar tracks in library" data-info-shortcut="">
                                        <span class="action-icon">&#128218;</span>
                                        <span class="action-text">Find Similar</span>
                                    </button>
                                    <button class="quick-action-card" data-action="optimize-mix" data-info-title="Optimize Mix" data-info-desc="Get AI mix optimization suggestions" data-info-shortcut="">
                                        <span class="action-icon">&#128268;</span>
                                        <span class="action-text">Optimize Mix</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Smart Features Panel -->
                        <div class="panel">
                            <div class="panel-title">&#128161; Smart Features</div>
                            
                            <!-- AI Suggestions -->
                            <div class="ai-suggestions-panel">
                                <div class="suggestion-card">
                                    <div class="suggestion-header">
                                        <span class="suggestion-type">Smart Match</span>
                                        <span class="suggestion-score">92%</span>
                                    </div>
                                    <div class="suggestion-content">
                                        This bass works perfectly with Track 2 at 124 BPM
                                    </div>
                                    <button class="btn btn-cyan btn-small">Use</button>
                                </div>
                            </div>
                            
                            <!-- Workflow Automation -->
                            <div class="workflow-panel" style="margin-top: 15px;">
                                <div class="panel-title">&#128736; Workflows</div>
                                <div class="workflow-list">
                                    <div class="workflow-item" data-info-title="Auto-Organize Workflow" data-info-desc="Automatically organize media library by genre, BPM, and key" data-info-shortcut="">
                                        <span class="workflow-name" data-info-title="Workflow Name" data-info-desc="Name of the workflow" data-info-shortcut="">Auto-Organize</span>
                                        <button class="btn-icon-small" title="Run" data-info-title="Run Workflow" data-info-desc="Execute this workflow. Runs automated task to organize your library." data-info-shortcut=""></button>
                                    </div>
                                    <div class="workflow-item" data-info-title="Batch Export Workflow" data-info-desc="Export multiple clips or tracks as separate audio files" data-info-shortcut="">
                                        <span class="workflow-name" data-info-title="Workflow Name" data-info-desc="Name of the workflow" data-info-shortcut="">Batch Export</span>
                                        <button class="btn-icon-small" title="Run" data-info-title="Run Workflow" data-info-desc="Execute batch export workflow" data-info-shortcut=""></button>
                                    </div>
                                    <div class="workflow-item" data-info-title="DNA Analysis Workflow" data-info-desc="Analyze all tracks in library and generate SERGIK DNA profiles" data-info-shortcut="">
                                        <span class="workflow-name" data-info-title="Workflow Name" data-info-desc="Name of the workflow" data-info-shortcut="">DNA Analysis</span>
                                        <button class="btn-icon-small" title="Run" data-info-title="Run Workflow" data-info-desc="Execute DNA analysis workflow" data-info-shortcut=""></button>
                                    </div>
                                </div>
                                <button class="btn btn-purple" id="create-workflow" data-info-title="Create Workflow" data-info-desc="Create a new custom workflow. Define automated tasks and sequences for music production." data-info-shortcut="">Create Workflow</button>
                            </div>
                            
                            <!-- Performance Analytics -->
                            <div class="analytics-panel" style="margin-top: 15px;">
                                <div class="panel-title">Performance</div>
                                <div class="analytics-grid">
                                    <div class="analytics-item" data-info-title="CPU Usage" data-info-desc="Real-time CPU usage monitoring. Shows processor load from plugins and effects." data-info-shortcut="">
                                        <div class="analytics-label" data-info-title="CPU Label" data-info-desc="Label for CPU usage" data-info-shortcut="">CPU</div>
                                        <div class="analytics-value" id="cpu-usage" data-info-title="CPU Value" data-info-desc="Current CPU usage percentage. High values may cause audio dropouts." data-info-shortcut="">45%</div>
                                        <div class="analytics-bar" data-info-title="CPU Bar" data-info-desc="Visual bar showing CPU usage level" data-info-shortcut="">
                                            <div class="analytics-fill" style="width: 45%" data-info-title="CPU Fill" data-info-desc="CPU usage indicator fill" data-info-shortcut=""></div>
                                        </div>
                                    </div>
                                    <div class="analytics-item" data-info-title="RAM Usage" data-info-desc="Real-time RAM (memory) usage monitoring. Shows memory consumption by samples and plugins." data-info-shortcut="">
                                        <div class="analytics-label" data-info-title="RAM Label" data-info-desc="Label for RAM usage" data-info-shortcut="">RAM</div>
                                        <div class="analytics-value" id="ram-usage" data-info-title="RAM Value" data-info-desc="Current RAM usage in gigabytes. High usage may slow down system." data-info-shortcut="">2.1 GB</div>
                                        <div class="analytics-bar" data-info-title="RAM Bar" data-info-desc="Visual bar showing RAM usage level" data-info-shortcut="">
                                            <div class="analytics-fill" style="width: 60%" data-info-title="RAM Fill" data-info-desc="RAM usage indicator fill" data-info-shortcut=""></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Features -->
        <div class="features">
            <div class="feature-card">
                <h3><span class="icon">&#127929;</span> Track Management</h3>
                <ul>
                    <li>Create MIDI/Audio/Return tracks</li>
                    <li>Mute, Solo, Arm controls</li>
                    <li>Set volume, pan, sends</li>
                    <li>Rename and color tracks</li>
                    <li>Delete and duplicate</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3><span class="icon">&#128268;</span> Device Control</h3>
                <ul>
                    <li>Load Ableton instruments & effects</li>
                    <li>Load VST/AU plugins</li>
                    <li>Control all parameters</li>
                    <li>Load presets</li>
                    <li>Toggle device on/off</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3><span class="icon">&#127916;</span> Clip Management</h3>
                <ul>
                    <li>Create empty clips</li>
                    <li>Fire and stop clips</li>
                    <li>Set MIDI notes programmatically</li>
                    <li>Get clip information</li>
                    <li>Duplicate to any slot</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3><span class="icon">&#129516;</span> Audio Analysis</h3>
                <ul>
                    <li>BPM/Key/Energy detection</li>
                    <li>AcoustID fingerprinting</li>
                    <li>MusicBrainz genre lookup</li>
                    <li>SERGIK DNA matching</li>
                    <li>Genre influence DNA</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3><span class="icon">&#127908;</span> Voice Control</h3>
                <ul>
                    <li>Push-to-talk recording</li>
                    <li>Speech-to-text transcription</li>
                    <li>Natural language commands</li>
                    <li>Text-to-speech responses</li>
                    <li>Hands-free production</li>
                </ul>
            </div>
            
            <div class="feature-card">
                <h3><span class="icon">&#128279;</span> URL Extraction</h3>
                <ul>
                    <li>YouTube audio extraction</li>
                    <li>SoundCloud support</li>
                    <li>Direct audio URLs</li>
                    <li>Automatic analysis</li>
                    <li>Reference track import</li>
                </ul>
            </div>
        </div>
        
        <!-- Command Examples -->
        <div class="commands">
            <h2>Natural Language Commands</h2>
            <div class="command-grid">
                <div class="command">Create a new MIDI track called "Lead Synth"</div>
                <div class="command">Add Wavetable to track 2</div>
                <div class="command">Generate tech house chords in D minor</div>
                <div class="command">Set tempo to 128 BPM</div>
                <div class="command">Analyze this track and show DNA match</div>
                <div class="command">Fire scene 4</div>
                <div class="command">Load Serum VST on the bass track</div>
                <div class="command">Create a walking bass line, 8 bars</div>
                <div class="command">Set filter cutoff to 50% on track 1</div>
                <div class="command">Generate trap drums at 140 BPM</div>
                <div class="command">Extract audio from this YouTube URL</div>
                <div class="command">Duplicate the clip in slot 3</div>
            </div>
        </div>
        
        <div class="footer">
            <p>SERGIK AI Controller v2.0 | Max for Live Device</p>
            <p>Requires <a href="#">SERGIK ML API</a> running on localhost:8000</p>
        </div>
    </div>
    
    <script type="module">
        // CRITICAL: Wrap all imports in try-catch to prevent script failure
        // If imports fail, we'll use fallbacks so the app still works
        let initializeGenreSystem, initializeIntelligenceSelector, initializeIdeaAnalyzer, initializeTempoModeManager, debounce;
        let SearchParser, MediaLoader, MediaItemInteraction, MediaKeyboardNavigation, BrowserList;
        let VisualFeedback, UIEnhancements, RequestManager, MediaCache, BrowserCache, ErrorHandler, StateManager, DebugTools;
        
        // Use async IIFE to handle dynamic imports
        (async () => {
            try {
                // Genre system - imported module
                const genreModule = await import('./js/genre-system.js');
                initializeGenreSystem = genreModule.initializeGenreSystem;
                
                const intelModule = await import('./js/intelligence-selector.js');
                initializeIntelligenceSelector = intelModule.initializeIntelligenceSelector;
                
                const ideaModule = await import('./js/idea-analyzer.js');
                initializeIdeaAnalyzer = ideaModule.initializeIdeaAnalyzer;
                
                const tempoModule = await import('./js/tempo-mode-manager.js');
                initializeTempoModeManager = tempoModule.initializeTempoModeManager;
                
                const debounceModule = await import('./js/utils/debounce.ts');
                debounce = debounceModule.debounce;
                
                // Library Tab optimization modules
                const searchParserModule = await import('./js/search-parser.js');
                SearchParser = searchParserModule.SearchParser;
                
                const mediaLoaderModule = await import('./js/media-loader.js');
                MediaLoader = mediaLoaderModule.MediaLoader;
                
                const mediaInteractionModule = await import('./js/media-item-interaction.js');
                MediaItemInteraction = mediaInteractionModule.MediaItemInteraction;
                
                const mediaKeyboardModule = await import('./js/media-keyboard-navigation.js');
                MediaKeyboardNavigation = mediaKeyboardModule.MediaKeyboardNavigation;
                
                const browserListModule = await import('./js/browser-list.js');
                BrowserList = browserListModule.BrowserList;
                
                const visualFeedbackModule = await import('./js/visual-feedback.js');
                VisualFeedback = visualFeedbackModule.VisualFeedback;
                
                const uiEnhancementsModule = await import('./js/ui-enhancements.js');
                UIEnhancements = uiEnhancementsModule.UIEnhancements;
                
                const requestManagerModule = await import('./js/request-manager.js');
                RequestManager = requestManagerModule.RequestManager;
                
                const mediaCacheModule = await import('./js/media-cache.js');
                MediaCache = mediaCacheModule.MediaCache;
                
                const browserCacheModule = await import('./js/browser-cache.js');
                BrowserCache = browserCacheModule.BrowserCache;
                
                const errorHandlerModule = await import('./js/error-handler.js');
                ErrorHandler = errorHandlerModule.ErrorHandler;
                
                const stateManagerModule = await import('./js/state-manager.js');
                StateManager = stateManagerModule.StateManager;
                
                const debugToolsModule = await import('./js/debug-tools.js');
                DebugTools = debugToolsModule.DebugTools;
                
                console.log('[App] All modules loaded successfully');
            } catch (err) {
                console.error('[App] Module import failed, using fallbacks:', err);
                // Create fallback functions/classes
                initializeGenreSystem = () => ({});
                initializeIntelligenceSelector = () => ({});
                initializeIdeaAnalyzer = () => ({ analyze: () => ({}) });
                initializeTempoModeManager = () => ({});
                debounce = (fn, delay) => {
                    let timeout;
                    return (...args) => {
                        clearTimeout(timeout);
                        timeout = setTimeout(() => fn(...args), delay);
                    };
                };
                SearchParser = class { parse() { return {}; } };
                MediaLoader = class { loadMediaIntoEditor() { return Promise.resolve(); } };
                MediaItemInteraction = class { setupInteractions() {} };
                MediaKeyboardNavigation = class {};
                BrowserList = class { setItems() {}; clearItems() {}; items = []; };
                VisualFeedback = class { showLoading() {}; hideLoading() {}; showError() {} };
                UIEnhancements = class {};
                RequestManager = class { debounce() {} };
                MediaCache = class { get() { return null; }; set() {}; clear() {} };
                BrowserCache = class { getSearchResults() { return null; }; setSearchResults() {} };
                ErrorHandler = class { handle() { console.error(...arguments); } };
                StateManager = class { get() { return null; }; set() {} };
                DebugTools = class { setEnabled() {}; inspectState() {}; getLogs() { return []; } };
            }
        
        // Export classes to window for global access (fixes module scope issues)
        // This ensures classes are available even if module scope has issues
        window.SearchParser = SearchParser;
        window.MediaLoader = MediaLoader;
        window.MediaItemInteraction = MediaItemInteraction;
        window.MediaKeyboardNavigation = MediaKeyboardNavigation;
        window.BrowserList = BrowserList;
        window.VisualFeedback = VisualFeedback;
        window.UIEnhancements = UIEnhancements;
        window.RequestManager = RequestManager;
        window.MediaCache = MediaCache;
        window.BrowserCache = BrowserCache;
        window.ErrorHandler = ErrorHandler;
        window.StateManager = StateManager;
        window.DebugTools = DebugTools;
        
                // Initialize genre system (if loaded)
                if (initializeGenreSystem) {
                    const genreSystem = initializeGenreSystem();
                }
                
                // Initialize intelligence selector (if loaded)
                if (initializeIntelligenceSelector) {
                    const intelligenceSelector = initializeIntelligenceSelector();
                }
                
                // Initialize idea analyzer (if loaded)
                if (initializeIdeaAnalyzer) {
                    const ideaAnalyzer = initializeIdeaAnalyzer();
                }
                
                // Initialize tempo mode manager (if loaded)
                if (initializeTempoModeManager) {
                    const tempoModeManager = initializeTempoModeManager();
                }
            })(); // Close async IIFE
        
        // External code (MaxForLive device) can update tempo by:
        // 1. Setting window.currentLiveTempo = 126.5;
        // 2. Or calling window.tempoModeManager.updateTempo(126.5);
        
        // Wire up idea input with analyzer and auto-fill (only if modules loaded)
        if (debounce && initializeIdeaAnalyzer) {
            const ideaInput = document.getElementById('idea-input');
            const genreSelect = document.getElementById('genre-select');
            const tempoSelect = document.getElementById('tempo-select');
            const energySelect = document.getElementById('energy-select');
            const keySelect = document.getElementById('key-select');
            const scaleSelect = document.getElementById('scale-select');
            const intelligenceSelect = document.getElementById('intelligence-select');
            
            if (ideaInput) {
                const ideaAnalyzer = initializeIdeaAnalyzer();
                const analyzeIdea = debounce((ideaText) => {
                    if (!ideaText || ideaText.trim() === '') return;
                    
                    const suggestions = ideaAnalyzer.analyze(ideaText);
                
                // Auto-fill genre if detected
                if (suggestions.genre && genreSelect) {
                    const option = genreSelect.querySelector(`option[value="${suggestions.genre}"]`);
                    if (option) {
                        genreSelect.value = suggestions.genre;
                        // Trigger change event to update all dependent fields
                        genreSelect.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }
                
                // Auto-fill tempo if detected (only if Follow Live is disabled)
                if (suggestions.tempo && tempoSelect) {
                    const followToggle = document.getElementById('tempo-follow-toggle');
                    if (!followToggle || !followToggle.checked) {
                        const closestOption = Array.from(tempoSelect.options)
                            .reduce((closest, opt) => {
                                const optValue = parseInt(opt.value, 10);
                                if (isNaN(optValue)) return closest;
                                const currentDiff = Math.abs(parseInt(closest.value, 10) - suggestions.tempo);
                                const optDiff = Math.abs(optValue - suggestions.tempo);
                                return optDiff < currentDiff ? opt : closest;
                            });
                        if (closestOption) {
                            tempoSelect.value = closestOption.value;
                        }
                    }
                }
                
                // Auto-fill energy if detected
                if (suggestions.energy && energySelect) {
                    const option = energySelect.querySelector(`option[value="${suggestions.energy}"]`);
                    if (option) {
                        energySelect.value = suggestions.energy.toString();
                    }
                }
                
                // Auto-fill key if detected
                if (suggestions.key && keySelect) {
                    const option = keySelect.querySelector(`option[value="${suggestions.key}"]`);
                    if (option) {
                        keySelect.value = suggestions.key;
                    }
                }
                
                // Auto-fill scale if detected
                if (suggestions.scale && scaleSelect) {
                    const option = scaleSelect.querySelector(`option[value="${suggestions.scale}"]`);
                    if (option) {
                        scaleSelect.value = suggestions.scale;
                    }
                }
                
                // Auto-fill intelligence if detected
                if (suggestions.intelligence && intelligenceSelect) {
                    const option = intelligenceSelect.querySelector(`option[value="${suggestions.intelligence}"]`);
                    if (option) {
                        intelligenceSelect.value = suggestions.intelligence;
                        intelligenceSelect.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }
            }, 500);
            
            ideaInput.addEventListener('input', (e) => {
                analyzeIdea(e.target.value);
            });
        }
        
        // Tab switching functionality (input tabs)
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                const tabId = this.dataset.tab;
                
                // Remove active class from all tabs and contents
                tabBtns.forEach(b => b.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                this.classList.add('active');
                document.getElementById('tab-' + tabId).classList.add('active');
            });
        });
        
        // Main tab switching functionality
        const mainTabBtns = document.querySelectorAll('.main-tab-btn');
        const tabSections = document.querySelectorAll('.tab-section');
        
        mainTabBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                const tabId = this.dataset.mainTab;
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:5917',message:'Main tab clicked',data:{tabId:tabId},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                // #endregion
                
                // Remove active class from all tabs and sections
                mainTabBtns.forEach(b => b.classList.remove('active'));
                tabSections.forEach(s => s.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding section
                this.classList.add('active');
                const targetSection = document.getElementById('tab-section-' + tabId);
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:5926',message:'Target section lookup',data:{tabId:tabId,targetSectionExists:!!targetSection,sectionId:'tab-section-' + tabId},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                // #endregion
                if (targetSection) {
                    targetSection.classList.add('active');
                }
                
                // Update status
                if (typeof updateStatus === 'function') {
                    updateStatus('ready', `Switched to ${tabId.charAt(0).toUpperCase() + tabId.slice(1)} view`);
                }
                
                // Update library badge if switching to library tab
                if (tabId === 'library') {
                    updateLibraryBadge();
                }
                
                // Tab-specific initialization
                initializeTab(tabId);
            });
        });
        
        // Initialize active tab on page load
        function initializeActiveTab() {
            const activeTabBtn = document.querySelector('.main-tab-btn.active');
            if (activeTabBtn) {
                const activeTabId = activeTabBtn.dataset.mainTab;
                console.log('[DEBUG] Initializing active tab on load:', activeTabId);
                initializeTab(activeTabId);
            }
        }
        
        // Call on DOM ready or immediately if already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                // Wait a bit for all scripts to load
                setTimeout(initializeActiveTab, 100);
            });
        } else {
            // DOM already loaded, but wait for other scripts
            setTimeout(initializeActiveTab, 100);
        }
        
        // Library Tab Optimization - Initialization Functions
        // ============================================================================
        
        // API base URL for SERGIK ML API
        const API_BASE_URL = 'http://127.0.0.1:7242';
        
        /**
         * Initialize Library Tab with all optimization classes
         * Now with comprehensive error handling and fallbacks
         */
        function initializeLibraryTab() {
            console.log('[Library Tab] Starting initialization with error handling...');
            
            try {
                // Initialize core classes with error handling
                try {
                    window.searchParser = new SearchParser();
                    console.log('[Library Tab] SearchParser initialized');
                } catch (err) {
                    console.warn('[Library Tab] SearchParser initialization failed, using fallback:', err);
                    window.searchParser = { parse: (q) => ({ query: q }) };
                }
                
                try {
                    window.mediaCache = new MediaCache(100, 10 * 1024 * 1024);
                    console.log('[Library Tab] MediaCache initialized');
                } catch (err) {
                    console.warn('[Library Tab] MediaCache initialization failed, using fallback:', err);
                    window.mediaCache = { get: () => null, set: () => {}, clear: () => {} };
                }
                
                try {
                    window.browserCache = new BrowserCache();
                    console.log('[Library Tab] BrowserCache initialized');
                } catch (err) {
                    console.warn('[Library Tab] BrowserCache initialization failed, using fallback:', err);
                    window.browserCache = { getSearchResults: () => null, setSearchResults: () => {} };
                }
                
                try {
                    window.requestManager = new RequestManager();
                    console.log('[Library Tab] RequestManager initialized');
                } catch (err) {
                    console.warn('[Library Tab] RequestManager initialization failed, using fallback:', err);
                    window.requestManager = { debounce: (id, fn, delay) => setTimeout(fn, delay) };
                }
                
                try {
                    window.errorHandler = new ErrorHandler();
                    console.log('[Library Tab] ErrorHandler initialized');
                } catch (err) {
                    console.warn('[Library Tab] ErrorHandler initialization failed, using fallback:', err);
                    window.errorHandler = { handle: (err) => console.error('[Error]', err) };
                }
                
                try {
                    window.stateManager = new StateManager();
                    console.log('[Library Tab] StateManager initialized');
                } catch (err) {
                    console.warn('[Library Tab] StateManager initialization failed, using fallback:', err);
                    window.stateManager = { get: () => null, set: () => {} };
                }
                
                try {
                    window.visualFeedback = new VisualFeedback();
                    console.log('[Library Tab] VisualFeedback initialized');
                } catch (err) {
                    console.warn('[Library Tab] VisualFeedback initialization failed, using fallback:', err);
                    window.visualFeedback = { showLoading: () => {}, hideLoading: () => {}, showError: () => {} };
                }
                
                try {
                    window.debugTools = new DebugTools();
                    console.log('[Library Tab] DebugTools initialized');
                } catch (err) {
                    console.warn('[Library Tab] DebugTools initialization failed, using fallback:', err);
                    window.debugTools = { setEnabled: () => {}, inspectState: () => {}, getLogs: () => [] };
                }
                
                // Initialize MediaLoader with cache
                try {
                    window.mediaLoader = new MediaLoader();
                    window.mediaLoader.mediaCache = window.mediaCache;
                    console.log('[Library Tab] MediaLoader initialized');
                } catch (err) {
                    console.warn('[Library Tab] MediaLoader initialization failed, using fallback:', err);
                    window.mediaLoader = { 
                        loadMediaIntoEditor: () => Promise.resolve(),
                        currentMedia: null
                    };
                }
                
                // Initialize UI components
                try {
                    window.uiEnhancements = new UIEnhancements();
                    console.log('[Library Tab] UIEnhancements initialized');
                } catch (err) {
                    console.warn('[Library Tab] UIEnhancements initialization failed, using fallback:', err);
                    window.uiEnhancements = {};
                }
                
                // Initialize virtual scrolling for media list FIRST
                // This must happen before MediaItemInteraction because BrowserList
                // replaces the container content with its wrapper
                const mediaListContainer = document.getElementById('media-list');
                if (mediaListContainer) {
                    try {
                        window.browserList = new BrowserList(mediaListContainer, {
                            itemHeight: 60,
                            bufferSize: 50
                        });
                        console.log('[Library Tab] BrowserList initialized');
                    } catch (err) {
                        console.warn('[Library Tab] BrowserList initialization failed, using fallback:', err);
                        window.browserList = { 
                            setItems: () => {}, 
                            clearItems: () => {},
                            items: []
                        };
                    }
                }
                
                // Initialize interaction handlers AFTER BrowserList
                // This ensures the browser-list-wrapper exists for event delegation
                // Use setTimeout to ensure BrowserList wrapper is fully created
                setTimeout(() => {
                    try {
                        window.mediaItemInteraction = new MediaItemInteraction();
                        console.log('[Library Tab] MediaItemInteraction initialized');
                    } catch (err) {
                        console.warn('[Library Tab] MediaItemInteraction initialization failed, using fallback:', err);
                        window.mediaItemInteraction = { loadMedia: () => {} };
                    }
                }, 50);
                
                try {
                    window.mediaKeyboardNavigation = new MediaKeyboardNavigation();
                    console.log('[Library Tab] MediaKeyboardNavigation initialized');
                } catch (err) {
                    console.warn('[Library Tab] MediaKeyboardNavigation initialization failed, using fallback:', err);
                    window.mediaKeyboardNavigation = {};
                }
            } catch (err) {
                console.error('[Library Tab] Critical error during class initialization:', err);
                // Continue with fallbacks
            }
            
            // Wire search input to SearchParser and RequestManager
            try {
                const searchInput = document.getElementById('media-search');
                if (searchInput) {
                    let searchDebounce;
                    searchInput.addEventListener('input', (e) => {
                        const query = e.target.value;
                        clearTimeout(searchDebounce);
                        
                        searchDebounce = setTimeout(() => {
                            performLibrarySearch(query);
                        }, 300);
                    });
                    
                    // Handle Enter key to load first result
                    searchInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            const query = e.target.value;
                            if (query.trim()) {
                                performLibrarySearch(query).then(() => {
                                    // Load first result if available
                                    if (window.browserList && window.browserList.items.length > 0) {
                                        const firstItem = window.browserList.items[0];
                                        if (window.mediaItemInteraction && firstItem.id) {
                                            window.mediaItemInteraction.loadMedia(firstItem.id);
                                        }
                                    }
                                });
                            }
                        }
                    });
                }
            } catch (err) {
                console.error('[Library Tab] Error wiring search input:', err);
            }
            
            // Connect to Max device (if available)
            try {
                if (typeof maxComms !== 'undefined') {
                    setupMaxDeviceIntegration();
                }
            } catch (err) {
                console.error('[Library Tab] Error setting up Max device integration:', err);
            }
            
            // Enable debug mode if URL parameter is present
            try {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('debug') === 'true') {
                    if (window.debugTools && window.debugTools.setEnabled) {
                        window.debugTools.setEnabled(true);
                        console.log('[Debug] Debug mode enabled');
                        
                        // Expose debug tools to console
                        window.inspectState = () => window.debugTools.inspectState();
                        window.getLogs = (level) => window.debugTools.getLogs(level);
                    }
                }
            } catch (err) {
                console.error('[Library Tab] Error enabling debug mode:', err);
            }
            
            // CRITICAL: Wire all Library tab buttons - MUST always execute
            // This is moved outside try-catch to ensure it always runs
            console.log('[Library Tab] Wiring button handlers...');
            wireLibraryTabButtons();
            
            console.log('[Library Tab] Initialization complete');
        }
        
        /**
         * Wire all Library tab button handlers end-to-end
         * This function MUST always execute, even if initialization fails
         */
        function wireLibraryTabButtons() {
            console.log('[Library Tab] Wiring all button handlers...');
            
            try {
                // Ensure editor states are initialized
                if (!window.editorStates) {
                    console.warn('[Library Tab] editorStates not initialized yet, initializing...');
                    // Initialize editor states if they don't exist
                    window.editorStates = {
                        waveform: { editorType: 'waveform', data: {}, selection: {}, hasSelection: () => false },
                        'piano-roll': { editorType: 'piano-roll', data: {}, selection: {}, hasSelection: () => false },
                        timeline: { editorType: 'timeline', data: {}, selection: {}, hasSelection: () => false }
                    };
                }
                
                // Ensure getCurrentEditorState is available globally
                if (typeof window.getCurrentEditorState !== 'function') {
                    console.warn('[Library Tab] getCurrentEditorState not available, creating fallback...');
                    window.getCurrentEditorState = function() {
                        const activeEditor = document.querySelector('.editor-content.active');
                        if (!activeEditor || !window.editorStates) return null;
                        
                        if (activeEditor.id === 'editor-waveform') {
                            return window.editorStates.waveform;
                        } else if (activeEditor.id === 'editor-piano-roll') {
                            return window.editorStates['piano-roll'];
                        } else if (activeEditor.id === 'editor-timeline') {
                            return window.editorStates.timeline;
                        }
                        return null;
                    };
                }
            } catch (err) {
                console.error('[Library Tab] Error initializing editor states:', err);
                // Continue anyway - wire buttons even if states fail
            }
            
            // 1. Filter Chip Buttons - with error handling and visual feedback
            try {
                const filterChips = document.querySelectorAll('.filter-chip[data-filter]');
                console.log('[Library Tab] Found', filterChips.length, 'filter chips');
                
                filterChips.forEach(chip => {
                    try {
                        // Remove any existing handlers to avoid duplicates
                        const newChip = chip.cloneNode(true);
                        chip.parentNode.replaceChild(newChip, chip);
                        
                        newChip.addEventListener('click', function() {
                            try {
                                const filterType = this.dataset.filter;
                                console.log('[Library Tab] Filter chip clicked:', filterType);
                                
                                // Visual feedback: Remove active from all chips
                                document.querySelectorAll('.filter-chip').forEach(c => {
                                    c.classList.remove('active');
                                    c.style.opacity = '0.7';
                                });
                                
                                // Visual feedback: Add active to clicked chip
                                this.classList.add('active');
                                this.style.opacity = '1';
                                this.style.background = 'var(--accent-cyan)';
                                
                                // Filter media items
                                filterMediaItems(filterType);
                                
                                // Update status
                                if (typeof updateStatus === 'function') {
                                    updateStatus('ready', `Filtered: ${filterType}`);
                                }
                                
                                console.log('[Library Tab] Filter applied:', filterType);
                            } catch (err) {
                                console.error('[Library Tab] Error handling filter chip click:', err);
                            }
                        });
                    } catch (err) {
                        console.error('[Library Tab] Error wiring filter chip:', err);
                    }
                });
            } catch (err) {
                console.error('[Library Tab] Error wiring filter chips:', err);
            }
            
            // 2. Search Clear Button
            const searchClear = document.getElementById('search-clear');
            const searchInput = document.getElementById('media-search');
            if (searchClear && searchInput) {
                // Show/hide clear button based on input
                searchInput.addEventListener('input', function() {
                    searchClear.style.display = this.value.trim() ? 'block' : 'none';
                });
                
                searchClear.addEventListener('click', function() {
                    searchInput.value = '';
                    searchInput.focus();
                    this.style.display = 'none';
                    
                    // Clear search results
                    if (window.browserList) {
                        window.browserList.clearItems();
                    }
                    
                    // Reset filter to "all"
                    const allFilter = document.querySelector('.filter-chip[data-filter="all"]');
                    if (allFilter) {
                        document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'));
                        allFilter.classList.add('active');
                        filterMediaItems('all');
                    }
                    
                    if (typeof updateStatus === 'function') {
                        updateStatus('ready', 'Search cleared');
                    }
                });
            }
            
            // 3. Group Toggle Buttons
            const groupToggles = document.querySelectorAll('.group-toggle');
            groupToggles.forEach(toggle => {
                toggle.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const group = this.closest('.media-group');
                    if (group) {
                        group.classList.toggle('collapsed');
                        const isCollapsed = group.classList.contains('collapsed');
                        this.textContent = isCollapsed ? '' : '';
                    }
                });
            });
            
            // 4. Action Buttons (Insert, Replace, Commit, Duplicate) - with visual feedback
            try {
                const actionInsert = document.getElementById('action-insert');
                if (actionInsert) {
                    actionInsert.addEventListener('click', function() {
                        try {
                            console.log('[Library Tab] Action Insert clicked');
                            const selectedItem = document.querySelector('.browser-item.selected');
                            if (!selectedItem) {
                                if (typeof updateStatus === 'function') {
                                    updateStatus('error', 'No item selected');
                                }
                                // Visual feedback
                                this.style.background = 'var(--error-red)';
                                setTimeout(() => { this.style.background = ''; }, 1000);
                                return;
                            }
                            
                            // Visual feedback: show loading state
                            const originalBg = this.style.background;
                            this.style.background = 'var(--accent-cyan)';
                            this.style.opacity = '0.8';
                            
                            const mediaId = selectedItem.dataset.mediaId;
                            if (mediaId && window.mediaLoader) {
                                window.mediaLoader.loadMediaIntoEditor(mediaId, 'auto').then(() => {
                                    // Insert into arrangement at current playhead
                                    sendToMax('insert_media', mediaId);
                                    if (typeof updateStatus === 'function') {
                                        updateStatus('success', 'Media inserted');
                                    }
                                    // Visual feedback: success
                                    this.style.background = 'var(--success-green)';
                                    setTimeout(() => {
                                        this.style.background = originalBg;
                                        this.style.opacity = '1';
                                    }, 1000);
                                }).catch(err => {
                                    console.error('[Library Tab] Insert failed:', err);
                                    if (typeof updateStatus === 'function') {
                                        updateStatus('error', 'Insert failed');
                                    }
                                    // Visual feedback: error
                                    this.style.background = 'var(--error-red)';
                                    setTimeout(() => {
                                        this.style.background = originalBg;
                                        this.style.opacity = '1';
                                    }, 1000);
                                });
                            }
                        } catch (err) {
                            console.error('[Library Tab] Error in Insert handler:', err);
                        }
                    });
                }
            } catch (err) {
                console.error('[Library Tab] Error wiring Insert button:', err);
            }
            
            try {
                const actionReplace = document.getElementById('action-replace');
                if (actionReplace) {
                    actionReplace.addEventListener('click', function() {
                        try {
                            console.log('[Library Tab] Action Replace clicked');
                            const selectedItem = document.querySelector('.browser-item.selected');
                            if (!selectedItem) {
                                if (typeof updateStatus === 'function') {
                                    updateStatus('error', 'No item selected');
                                }
                                // Visual feedback
                                this.style.background = 'var(--error-red)';
                                setTimeout(() => { this.style.background = ''; }, 1000);
                                return;
                            }
                            
                            // Visual feedback: show loading state
                            const originalBg = this.style.background;
                            this.style.background = 'var(--accent-cyan)';
                            this.style.opacity = '0.8';
                            
                            const mediaId = selectedItem.dataset.mediaId;
                            if (mediaId && window.mediaLoader) {
                                window.mediaLoader.loadMediaIntoEditor(mediaId, 'auto').then(() => {
                                    // Replace current clip
                                    sendToMax('replace_media', mediaId);
                                    if (typeof updateStatus === 'function') {
                                        updateStatus('success', 'Media replaced');
                                    }
                                    // Visual feedback: success
                                    this.style.background = 'var(--success-green)';
                                    setTimeout(() => {
                                        this.style.background = originalBg;
                                        this.style.opacity = '1';
                                    }, 1000);
                                }).catch(err => {
                                    console.error('[Library Tab] Replace failed:', err);
                                    if (typeof updateStatus === 'function') {
                                        updateStatus('error', 'Replace failed');
                                    }
                                    // Visual feedback: error
                                    this.style.background = 'var(--error-red)';
                                    setTimeout(() => {
                                        this.style.background = originalBg;
                                        this.style.opacity = '1';
                                    }, 1000);
                                });
                            }
                        } catch (err) {
                            console.error('[Library Tab] Error in Replace handler:', err);
                        }
                    });
                }
            } catch (err) {
                console.error('[Library Tab] Error wiring Replace button:', err);
            }
            
            try {
                const actionCommit = document.getElementById('action-commit');
                if (actionCommit) {
                    actionCommit.addEventListener('click', function() {
                        try {
                            console.log('[Library Tab] Action Commit clicked');
                            const currentMedia = window.mediaLoader?.currentMedia;
                            if (!currentMedia) {
                                if (typeof updateStatus === 'function') {
                                    updateStatus('error', 'No media loaded');
                                }
                                // Visual feedback
                                this.style.background = 'var(--error-red)';
                                setTimeout(() => { this.style.background = ''; }, 1000);
                                return;
                            }
                            
                            // Commit changes to project
                            sendToMax('commit_changes', currentMedia);
                            if (typeof updateStatus === 'function') {
                                updateStatus('success', 'Changes committed');
                            }
                            
                            // Visual feedback: success
                            const originalBg = this.style.background;
                            this.style.background = 'var(--success-green)';
                            setTimeout(() => {
                                this.style.background = originalBg;
                            }, 1000);
                        } catch (err) {
                            console.error('[Library Tab] Error in Commit handler:', err);
                        }
                    });
                }
            } catch (err) {
                console.error('[Library Tab] Error wiring Commit button:', err);
            }
            
            try {
                const actionDuplicate = document.getElementById('action-duplicate');
                if (actionDuplicate) {
                    actionDuplicate.addEventListener('click', function() {
                        try {
                            console.log('[Library Tab] Action Duplicate clicked');
                            const selectedItem = document.querySelector('.browser-item.selected');
                            if (!selectedItem) {
                                if (typeof updateStatus === 'function') {
                                    updateStatus('error', 'No item selected');
                                }
                                // Visual feedback
                                this.style.background = 'var(--error-red)';
                                setTimeout(() => { this.style.background = ''; }, 1000);
                                return;
                            }
                            
                            // Visual feedback
                            const originalBg = this.style.background;
                            this.style.background = 'var(--accent-cyan)';
                            
                            const mediaId = selectedItem.dataset.mediaId;
                            if (mediaId) {
                                // Duplicate the item
                                duplicateMediaItem(mediaId);
                                if (typeof updateStatus === 'function') {
                                    updateStatus('success', 'Item duplicated');
                                }
                                // Visual feedback: success
                                setTimeout(() => {
                                    this.style.background = originalBg;
                                }, 1000);
                            }
                        } catch (err) {
                            console.error('[Library Tab] Error in Duplicate handler:', err);
                        }
                    });
                }
            } catch (err) {
                console.error('[Library Tab] Error wiring Duplicate button:', err);
            }
            
            // 5. Preview Controls (Play, Stop, Loop) - with visual feedback
            try {
                const previewPlay = document.getElementById('preview-play');
                const previewStop = document.getElementById('preview-stop');
                const previewLoop = document.getElementById('preview-loop');
                
                if (previewPlay) {
                    previewPlay.addEventListener('click', function() {
                        try {
                            console.log('[Library Tab] Preview Play clicked');
                            const selectedItem = document.querySelector('.browser-item.selected');
                            if (!selectedItem) {
                                if (typeof updateStatus === 'function') {
                                    updateStatus('error', 'No item selected for preview');
                                }
                                // Visual feedback
                                this.style.background = 'var(--error-red)';
                                setTimeout(() => { this.style.background = ''; }, 1000);
                                return;
                            }
                            
                            const mediaId = selectedItem.dataset.mediaId;
                            if (mediaId) {
                                // Start preview
                                sendToMax('preview_play', mediaId);
                                
                                // Visual feedback: activate play button
                                this.classList.add('active');
                                this.style.background = 'var(--accent-cyan)';
                                previewStop?.classList.remove('active');
                                if (previewStop) previewStop.style.background = '';
                                
                                // Update item state
                                if (window.mediaLoader) {
                                    window.mediaLoader.updateMediaItemState(mediaId, 'playing');
                                }
                                
                                if (typeof updateStatus === 'function') {
                                    updateStatus('ready', 'Preview playing');
                                }
                            }
                        } catch (err) {
                            console.error('[Library Tab] Error in Preview Play handler:', err);
                        }
                    });
                }
                
                if (previewStop) {
                    previewStop.addEventListener('click', function() {
                        try {
                            console.log('[Library Tab] Preview Stop clicked');
                            // Stop preview
                            sendToMax('preview_stop');
                            
                            // Visual feedback: activate stop button
                            this.classList.add('active');
                            this.style.background = 'var(--error-red)';
                            previewPlay?.classList.remove('active');
                            if (previewPlay) previewPlay.style.background = '';
                            
                            // Update all items to remove playing state
                            document.querySelectorAll('.browser-item.playing').forEach(item => {
                                item.classList.remove('playing');
                            });
                            
                            if (typeof updateStatus === 'function') {
                                updateStatus('ready', 'Preview stopped');
                            }
                        } catch (err) {
                            console.error('[Library Tab] Error in Preview Stop handler:', err);
                        }
                    });
                }
                
                if (previewLoop) {
                    previewLoop.addEventListener('click', function() {
                        try {
                            console.log('[Library Tab] Preview Loop clicked');
                            const isLooping = this.classList.toggle('active');
                            
                            // Visual feedback
                            if (isLooping) {
                                this.style.background = 'var(--accent-cyan)';
                            } else {
                                this.style.background = '';
                            }
                            
                            sendToMax('preview_loop', isLooping);
                            if (typeof updateStatus === 'function') {
                                updateStatus('ready', `Loop: ${isLooping ? 'ON' : 'OFF'}`);
                            }
                        } catch (err) {
                            console.error('[Library Tab] Error in Preview Loop handler:', err);
                        }
                    });
                }
            } catch (err) {
                console.error('[Library Tab] Error wiring preview controls:', err);
            }
            
            // 6. Toolbar Buttons (already wired in wireToolbarButtons, but ensure they work)
            // These are handled by wireToolbarButtons() which is called in initializeTab
            
                // 7. Copy/Paste buttons
                try {
                    const toolCopy = document.getElementById('tool-copy');
                    const toolPaste = document.getElementById('tool-paste');
                    
                    if (toolCopy) {
                        toolCopy.addEventListener('click', function() {
                            const selectedItem = document.querySelector('.browser-item.selected');
                            if (selectedItem) {
                                const mediaId = selectedItem.dataset.mediaId;
                                if (mediaId) {
                                    // Copy to clipboard
                                    if (navigator.clipboard) {
                                        navigator.clipboard.writeText(mediaId).then(() => {
                                            if (typeof updateStatus === 'function') {
                                                updateStatus('success', 'Copied to clipboard');
                                            }
                                        });
                                    }
                                }
                            }
                        });
                    }
                    
                    if (toolPaste) {
                        toolPaste.addEventListener('click', function() {
                            // Paste from clipboard
                            if (navigator.clipboard) {
                                navigator.clipboard.readText().then(text => {
                                    // Try to find item with this ID
                                    const item = document.querySelector(`[data-media-id="${text}"]`);
                                    if (item && window.mediaLoader) {
                                        window.mediaLoader.loadMediaIntoEditor(text);
                                        if (typeof updateStatus === 'function') {
                                            updateStatus('success', 'Pasted from clipboard');
                                        }
                                    }
                                }).catch(() => {
                                    if (typeof updateStatus === 'function') {
                                        updateStatus('error', 'Nothing to paste');
                                    }
                                });
                            }
                        });
                    }
                } catch (err) {
                    console.error('[Library Tab] Error wiring Copy/Paste buttons:', err);
                }
                
                // 8. Media Navigation Buttons (Previous, Next, Random)
                try {
                    const prevMediaBtn = document.getElementById('prev-media');
                    const nextMediaBtn = document.getElementById('next-media');
                    const randomMediaBtn = document.getElementById('random-media');
                    
                    if (prevMediaBtn) {
                        prevMediaBtn.addEventListener('click', function() {
                            try {
                                console.log('[Library Tab] Previous media clicked');
                                if (window.mediaKeyboardNavigation && window.mediaKeyboardNavigation.loadPreviousMedia) {
                                    window.mediaKeyboardNavigation.loadPreviousMedia();
                                } else {
                                    // Fallback: find previous item
                                    const selectedItem = document.querySelector('.browser-item.selected');
                                    if (selectedItem) {
                                        const allItems = Array.from(document.querySelectorAll('.browser-item[data-media-id]'));
                                        const currentIndex = allItems.indexOf(selectedItem);
                                        if (currentIndex > 0) {
                                            const prevItem = allItems[currentIndex - 1];
                                            prevItem.click();
                                        }
                                    }
                                }
                            } catch (err) {
                                console.error('[Library Tab] Error in Previous media handler:', err);
                            }
                        });
                    }
                    
                    if (nextMediaBtn) {
                        nextMediaBtn.addEventListener('click', function() {
                            try {
                                console.log('[Library Tab] Next media clicked');
                                if (window.mediaKeyboardNavigation && window.mediaKeyboardNavigation.loadNextMedia) {
                                    window.mediaKeyboardNavigation.loadNextMedia();
                                } else {
                                    // Fallback: find next item
                                    const selectedItem = document.querySelector('.browser-item.selected');
                                    if (selectedItem) {
                                        const allItems = Array.from(document.querySelectorAll('.browser-item[data-media-id]'));
                                        const currentIndex = allItems.indexOf(selectedItem);
                                        if (currentIndex < allItems.length - 1) {
                                            const nextItem = allItems[currentIndex + 1];
                                            nextItem.click();
                                        }
                                    }
                                }
                            } catch (err) {
                                console.error('[Library Tab] Error in Next media handler:', err);
                            }
                        });
                    }
                    
                    if (randomMediaBtn) {
                        randomMediaBtn.addEventListener('click', function() {
                            try {
                                console.log('[Library Tab] Random media clicked');
                                if (window.mediaKeyboardNavigation && window.mediaKeyboardNavigation.loadRandomMedia) {
                                    window.mediaKeyboardNavigation.loadRandomMedia();
                                } else {
                                    // Fallback: select random item
                                    const allItems = Array.from(document.querySelectorAll('.browser-item[data-media-id]'));
                                    if (allItems.length > 0) {
                                        const randomIndex = Math.floor(Math.random() * allItems.length);
                                        allItems[randomIndex].click();
                                    }
                                }
                            } catch (err) {
                                console.error('[Library Tab] Error in Random media handler:', err);
                            }
                        });
                    }
                } catch (err) {
                    console.error('[Library Tab] Error wiring media navigation buttons:', err);
                }
                
                console.log('[Library Tab] All buttons wired successfully');
            } catch (err) {
                console.error('[Library Tab] Critical error in wireLibraryTabButtons:', err);
                // Function still completes - buttons may not all be wired but initialization continues
            }
            
            // Always log completion, even if errors occurred
            console.log('[Library Tab] wireLibraryTabButtons execution completed');
        }
        
        /**
         * Filter media items by type
         * Enhanced with error handling and visual feedback
         */
        function filterMediaItems(filterType) {
            try {
                console.log('[Library Tab] Filtering media items by:', filterType);
                
                const allItems = document.querySelectorAll('.browser-item[data-media-id]');
                const mediaList = document.getElementById('media-list');
                
                if (!mediaList) {
                    console.warn('[Library Tab] Media list container not found');
                    return;
                }
                
                let visibleCount = 0;
                
                allItems.forEach(item => {
                    try {
                        const itemType = item.dataset.mediaType || 'audio';
                        const isVariable = item.closest('.media-group[data-group="variables"]') !== null;
                        const isRecent = item.closest('.media-group[data-group="recent"]') !== null;
                        
                        let shouldShow = false;
                        
                        switch(filterType) {
                            case 'all':
                                shouldShow = true;
                                break;
                            case 'audio':
                                shouldShow = itemType === 'audio';
                                break;
                            case 'midi':
                                shouldShow = itemType === 'midi';
                                break;
                            case 'variables':
                                shouldShow = isVariable;
                                break;
                            case 'recent':
                                shouldShow = isRecent;
                                break;
                            default:
                                shouldShow = true;
                        }
                        
                        // Show/hide item
                        if (shouldShow) {
                            item.style.display = '';
                            visibleCount++;
                        } else {
                            item.style.display = 'none';
                        }
                    } catch (err) {
                        console.error('[Library Tab] Error processing media item:', err);
                        // Show item by default if error occurs
                        item.style.display = '';
                    }
                });
                
                // Update counts
                try {
                    if (typeof updateMediaCounts === 'function') {
                        updateMediaCounts();
                    }
                } catch (err) {
                    console.error('[Library Tab] Error updating media counts:', err);
                }
                
                console.log('[Library Tab] Filter complete:', visibleCount, 'items visible');
            } catch (err) {
                console.error('[Library Tab] Error in filterMediaItems:', err);
                // Show all items on error
                const allItems = document.querySelectorAll('.browser-item[data-media-id]');
                allItems.forEach(item => {
                    item.style.display = '';
                });
            }
        }
        
        /**
         * Duplicate a media item
         */
        function duplicateMediaItem(mediaId) {
            const originalItem = document.querySelector(`[data-media-id="${mediaId}"]`);
            if (!originalItem) return;
            
            // Clone the item
            const clonedItem = originalItem.cloneNode(true);
            const newId = `${mediaId}_copy_${Date.now()}`;
            clonedItem.dataset.mediaId = newId;
            clonedItem.classList.remove('selected', 'loaded', 'playing');
            
            // Update name
            const nameEl = clonedItem.querySelector('.item-name');
            if (nameEl) {
                nameEl.textContent = nameEl.textContent + ' (copy)';
            }
            
            // Insert after original
            originalItem.parentNode.insertBefore(clonedItem, originalItem.nextSibling);
            
            // Update counts
            updateMediaCounts();
        }
        
        /**
         * Update media counts in groups
         */
        function updateMediaCounts() {
            document.querySelectorAll('.media-group').forEach(group => {
                const itemsContainer = group.querySelector('.group-items');
                const countEl = group.querySelector('.group-count');
                if (itemsContainer && countEl) {
                    const visibleItems = Array.from(itemsContainer.querySelectorAll('.browser-item')).filter(
                        item => item.style.display !== 'none'
                    );
                    countEl.textContent = `(${visibleItems.length})`;
                }
            });
        }
        
        /**
         * Send command to Max (helper function)
         */
        function sendToMax(command, ...args) {
            if (window.maxComms || window.maxCommunication) {
                const maxComms = window.maxComms || window.maxCommunication;
                maxComms.sendCommand(command, args);
            } else {
                console.log('[Max Command]', command, args);
            }
        }
        
        /**
         * Perform library search with caching and debouncing
         * Enhanced with comprehensive error handling
         */
        async function performLibrarySearch(query) {
            try {
                console.log('[Library Tab] Performing search:', query);
                
                if (!query || query.trim().length === 0) {
                    // Show all items or clear results
                    try {
                        if (window.browserList && window.browserList.clearItems) {
                            window.browserList.clearItems();
                        }
                    } catch (err) {
                        console.error('[Library Tab] Error clearing search results:', err);
                    }
                    return;
                }
                
                // Show loading state
                try {
                    if (window.visualFeedback && window.visualFeedback.showLoading) {
                        window.visualFeedback.showLoading('Searching...', 'library-search');
                    }
                } catch (err) {
                    console.warn('[Library Tab] Error showing loading state:', err);
                }
                
                // Check cache first
                try {
                    if (window.browserCache && window.browserCache.getSearchResults) {
                        const cached = window.browserCache.getSearchResults(query);
                        if (cached) {
                            if (window.browserList && window.browserList.setItems) {
                                window.browserList.setItems(cached);
                            }
                            if (window.visualFeedback && window.visualFeedback.hideLoading) {
                                window.visualFeedback.hideLoading('library-search');
                            }
                            console.log('[Library Tab] Search results loaded from cache');
                            return;
                        }
                    }
                } catch (err) {
                    console.warn('[Library Tab] Error checking cache:', err);
                    // Continue with API search
                }
                
                // Parse query
                let parsed = {};
                try {
                    if (window.searchParser && window.searchParser.parse) {
                        parsed = window.searchParser.parse(query);
                    }
                } catch (err) {
                    console.warn('[Library Tab] Error parsing query:', err);
                    // Continue with raw query
                }
            
                // Make API request with debouncing
                try {
                    let response;
                    if (window.requestManager && window.requestManager.debounce) {
                        response = await window.requestManager.debounce(
                            `search-${query}`,
                            async () => {
                                const url = `${API_BASE_URL}/live/browser/search?query=${encodeURIComponent(query)}`;
                                const res = await fetch(url);
                                if (!res.ok) {
                                    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                                }
                                return res.json();
                            },
                            300
                        );
                    } else {
                        // Fallback: direct fetch
                        const url = `${API_BASE_URL}/live/browser/search?query=${encodeURIComponent(query)}`;
                        const res = await fetch(url);
                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                        }
                        response = await res.json();
                    }
                    
                    if (response && response.status === 'ok') {
                        // Convert to BrowserList format
                        const items = (response.items || []).map(item => ({
                            id: item.path || item.name,
                            name: item.name,
                            type: item.item_type || 'audio',
                            path: item.path,
                            icon: item.item_type === 'midi_clip' ? '' : '',
                            duration: item.duration || null,
                            bpm: item.bpm || null,
                            key: item.key || null,
                            ...item
                        }));
                        
                        // Cache results
                        try {
                            if (window.browserCache && window.browserCache.setSearchResults) {
                                window.browserCache.setSearchResults(query, items);
                            }
                        } catch (err) {
                            console.warn('[Library Tab] Error caching results:', err);
                        }
                        
                        // Update browser list
                        try {
                            if (window.browserList && window.browserList.setItems) {
                                window.browserList.setItems(items);
                            }
                        } catch (err) {
                            console.error('[Library Tab] Error updating browser list:', err);
                        }
                        
                        // Save to recent queries
                        try {
                            if (window.searchParser && window.searchParser.saveRecentQuery) {
                                window.searchParser.saveRecentQuery(query);
                            }
                        } catch (err) {
                            console.warn('[Library Tab] Error saving recent query:', err);
                        }
                        
                        // Visual feedback
                        try {
                            if (window.visualFeedback && window.visualFeedback.success) {
                                window.visualFeedback.success(`Found ${items.length} results`);
                            } else if (typeof updateStatus === 'function') {
                                updateStatus('success', `Found ${items.length} results`);
                            }
                        } catch (err) {
                            console.warn('[Library Tab] Error showing success feedback:', err);
                        }
                    } else {
                        // Handle error response
                        try {
                            if (window.visualFeedback && window.visualFeedback.error) {
                                window.visualFeedback.error(response?.error || 'Search failed');
                            } else if (typeof updateStatus === 'function') {
                                updateStatus('error', response?.error || 'Search failed');
                            }
                        } catch (err) {
                            console.warn('[Library Tab] Error showing error feedback:', err);
                        }
                    }
                } catch (error) {
                    console.error('[Library Tab] Error in API request:', error);
                    try {
                        if (window.errorHandler && window.errorHandler.showError) {
                            window.errorHandler.showError(error, 'Library search');
                        } else if (typeof updateStatus === 'function') {
                            updateStatus('error', 'Search failed: ' + error.message);
                        }
                    } catch (err) {
                        console.error('[Library Tab] Error handling search error:', err);
                    }
                } finally {
                    // Always hide loading state
                    try {
                        if (window.visualFeedback && window.visualFeedback.hideLoading) {
                            window.visualFeedback.hideLoading('library-search');
                        }
                    } catch (err) {
                        console.warn('[Library Tab] Error hiding loading state:', err);
                    }
                }
            } catch (err) {
                console.error('[Library Tab] Critical error in performLibrarySearch:', err);
                // Ensure loading state is hidden even on critical errors
                try {
                    if (window.visualFeedback && window.visualFeedback.hideLoading) {
                        window.visualFeedback.hideLoading('library-search');
                    }
                } catch (hideErr) {
                    // Ignore errors in cleanup
                }
            }
        }
        
        /**
         * Setup Max device integration for sending commands
         */
        function setupMaxDeviceIntegration() {
            // Listen for search results from Max device
            window.addEventListener('message', (event) => {
                if (event.data.type === 'browser_search_result') {
                    const { query, items } = event.data;
                    if (window.browserList) {
                        window.browserList.setItems(items);
                    }
                }
            });
            
            // Override MediaLoader sendToMax to use actual Max communication
            if (window.mediaLoader) {
                window.mediaLoader.sendToMax = (command, ...args) => {
                    if (typeof maxComms !== 'undefined' && maxComms.sendCommand) {
                        maxComms.sendCommand(command, ...args);
                    } else {
                        // Fallback: send via postMessage or HTTP
                        console.log(`[Max] ${command}`, ...args);
                    }
                };
            }
            
            // Connect MediaItemInteraction to Max device commands
            if (window.mediaItemInteraction && window.mediaLoader) {
                // Override loadMedia method
                const originalLoadMedia = window.mediaItemInteraction.loadMedia;
                window.mediaItemInteraction.loadMedia = async function(mediaId) {
                    const mediaLoader = window.mediaLoader;
                    if (!mediaLoader) return;
                    
                    const loadingId = window.visualFeedback ? window.visualFeedback.showLoading('Loading media...', 'load-media') : null;
                    
                    try {
                        // Get media data
                        const mediaData = await mediaLoader.fetchMediaData(mediaId);
                        
                        // Send to Max device
                        const trackIndex = window.stateManager ? (window.stateManager.get('selectedTrackIndex') || 0) : 0;
                        mediaLoader.sendToMax('load_sample', trackIndex, mediaData.path);
                        
                        // Update state
                        mediaLoader.updateMediaItemState(mediaId, 'loading');
                        
                        // Wait for confirmation (or timeout)
                        setTimeout(() => {
                            mediaLoader.updateMediaItemState(mediaId, 'loaded');
                            if (window.visualFeedback && loadingId) {
                                window.visualFeedback.hideLoading(loadingId);
                                window.visualFeedback.success('Media loaded');
                            }
                        }, 1000);
                        
                    } catch (error) {
                        if (window.errorHandler) {
                            window.errorHandler.showError(error, 'Load media');
                        }
                        mediaLoader.updateMediaItemState(mediaId, 'error');
                        if (window.visualFeedback && loadingId) {
                            window.visualFeedback.hideLoading(loadingId);
                        }
                    }
                };
            }
            
            console.log('[Max Device] Integration setup complete');
        }
        
        // Tab-specific initialization
        function initializeTab(tabId) {
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:6643',message:'initializeTab called',data:{tabId:tabId},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
            // #endregion
            switch(tabId) {
                case 'library':
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:6645',message:'Library tab initialization started',data:{timestamp:Date.now()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                    // #endregion
                    initializeEditors(); // Editors now in Library tab
                    // Also wire toolbar buttons directly when Library tab is activated
                    setTimeout(() => {
                        // #region agent log
                        fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:6648',message:'setTimeout callback executing',data:{timestamp:Date.now()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                        // #endregion
                        wireToolbarButtons();
                        // Initialize Library Tab optimization
                        initializeLibraryTab();
                    }, 100);
                    break;
                case 'ai':
                    initializeAI();
                    break;
            }
        }
        
            // Toolbar button handlers
        function wireToolbarButtons() {
            console.log('[DEBUG] wireToolbarButtons called');
            
            // Validate toolbar exists
            const toolbar = document.querySelector('.editor-toolbar');
            if (!toolbar) {
                console.error('[ERROR] .editor-toolbar not found! Cannot wire buttons.');
                return;
            }
            
            // Remove existing listeners to prevent duplicates
            const toolbarBtns = document.querySelectorAll('.toolbar-btn');
            
            console.log('[DEBUG] Found toolbar buttons:', toolbarBtns.length);
            
            // Validate buttons exist
            if (toolbarBtns.length === 0) {
                console.error('[ERROR] No toolbar buttons found!');
                return;
            }
            
            // Use event delegation on the toolbar container to handle clicks
            // Remove old listener if exists
            if (toolbar._toolbarClickHandler) {
                toolbar.removeEventListener('click', toolbar._toolbarClickHandler);
                console.log('[DEBUG] Removed old toolbar click handler');
            }
            
            if (toolbar) {
                
                // Create new handler with error handling
                toolbar._toolbarClickHandler = function(e) {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const btn = e.target.closest('.toolbar-btn');
                        if (!btn || typeof btn.getAttribute !== 'function') {
                            console.log('[DEBUG] Click not on toolbar button, target:', e.target);
                            return;
                        }
                        
                        const tool = btn.getAttribute('data-tool');
                        if (!tool) {
                            console.warn('[WARN] Button clicked but no data-tool attribute');
                            return;
                        }
                        
                        console.log('[DEBUG] Toolbar button clicked:', tool, 'Button element:', btn);
                        // #region agent log
                        fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:6715',message:'Toolbar button clicked',data:{tool:tool,getCurrentEditorStateExists:typeof window.getCurrentEditorState === 'function',getCurrentEditorStateExistsDirect:typeof getCurrentEditorState === 'function'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                        // #endregion
                        
                        const state = window.getCurrentEditorState ? window.getCurrentEditorState() : (typeof getCurrentEditorState === 'function' ? getCurrentEditorState() : null);
                        // #region agent log
                        fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:6718',message:'getCurrentEditorState called',data:{stateExists:!!state,stateType:state?.editorType},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                        // #endregion
                        
                        // For editor switching (waveform, piano, timeline), don't require state
                        if (!state && !['waveform', 'piano', 'timeline'].includes(tool)) {
                            console.log('[DEBUG] No state and tool is not editor switch, returning');
                            return;
                        }
                        
                        // Update active button
                        try {
                            toolbarBtns.forEach(b => b.classList.remove('active'));
                            btn.classList.add('active');
                        } catch (err) {
                            console.error('[ERROR] Error updating button active state:', err);
                        }
                        
                        // Handle tool-specific actions
                        switch(tool) {
                        case 'select':
                            // Enable selection mode
                            break;
                        case 'cut':
                            // Enable cut mode
                            if (state && state.hasSelection()) {
                                handleCut(state);
                            }
                            break;
                        case 'fade':
                            // Enable fade mode
                            break;
                        case 'waveform':
                        case 'piano':
                        case 'timeline':
                            // Switch editor - unified handler with comprehensive error handling
                            try {
                                console.log('[Library Tab] Switching to', tool, 'editor');
                                
                                // Ensure Library tab is active
                                const libraryTab = document.querySelector('#tab-section-library');
                                if (libraryTab && !libraryTab.classList.contains('active')) {
                                    libraryTab.classList.add('active');
                                    console.log('[Library Tab] Activated Library tab');
                                }
                                
                                // Hide all editors with multiple methods for reliability
                                const allEditors = document.querySelectorAll('.editor-content');
                                console.log('[Library Tab] Found', allEditors.length, 'editors to hide');
                                
                                allEditors.forEach(editor => {
                                    editor.classList.remove('active');
                                    editor.style.display = 'none';
                                    editor.style.visibility = 'hidden';
                                    editor.style.opacity = '0';
                                    editor.setAttribute('aria-hidden', 'true');
                                });
                                
                                // Show target editor
                                const editorId = tool === 'piano' ? 'editor-piano-roll' : `editor-${tool}`;
                                const targetEditor = document.getElementById(editorId);
                                
                                if (targetEditor) {
                                    // Show editor with multiple methods
                                    targetEditor.classList.add('active');
                                    targetEditor.style.display = 'block';
                                    targetEditor.style.visibility = 'visible';
                                    targetEditor.style.opacity = '1';
                                    targetEditor.setAttribute('aria-hidden', 'false');
                                    
                                    // Update toolbar button visual state
                                    const editorBtn = document.querySelector(`.toolbar-btn[data-tool="${tool}"]`);
                                    if (editorBtn) {
                                        // Remove active from all toolbar buttons
                                        document.querySelectorAll('.toolbar-btn').forEach(b => {
                                            b.classList.remove('active');
                                            b.style.opacity = '0.7';
                                        });
                                        // Activate clicked button
                                        editorBtn.classList.add('active');
                                        editorBtn.style.opacity = '1';
                                    }
                                    
                                    // Update editor state if available
                                    if (window.editorStates) {
                                        const stateKey = tool === 'piano' ? 'piano-roll' : tool;
                                        if (window.editorStates[stateKey]) {
                                            console.log('[Library Tab] Editor state available for', stateKey);
                                        }
                                    }
                                    
                                    console.log('[Library Tab] Successfully activated', tool, 'editor');
                                    
                                    // Visual feedback
                                    if (typeof updateStatus === 'function') {
                                        updateStatus('ready', `${tool.charAt(0).toUpperCase() + tool.slice(1)} editor active`);
                                    }
                                } else {
                                    console.error('[Library Tab] ERROR: Editor not found:', editorId);
                                    console.error('[Library Tab] Available editors:', Array.from(allEditors).map(e => e.id));
                                    
                                    if (typeof updateStatus === 'function') {
                                        updateStatus('error', `Editor ${editorId} not found`);
                                    }
                                }
                            } catch (err) {
                                console.error('[Library Tab] Error switching editor:', err);
                                if (typeof updateStatus === 'function') {
                                    updateStatus('error', 'Failed to switch editor');
                                }
                            }
                            break;
                        }
                    } catch (err) {
                        console.error('[ERROR] Error in toolbar click handler:', err);
                    }
                };
                
                // Attach event listener to toolbar container
                toolbar.addEventListener('click', toolbar._toolbarClickHandler, true); // Use capture phase
                console.log('[DEBUG] Event listener attached to toolbar container via delegation (capture phase)');
                
                // Also test direct button clicks
                toolbarBtns.forEach(btn => {
                    if (btn && typeof btn.getAttribute === 'function') {
                        btn.style.pointerEvents = 'auto';
                        btn.style.cursor = 'pointer';
                        console.log('[DEBUG] Button prepared:', btn.getAttribute('data-tool'), btn);
                    }
                });
                
                // Test: Try clicking programmatically to verify it works
                const testBtn = toolbar.querySelector('[data-tool="waveform"]');
                if (testBtn) {
                    console.log('[DEBUG] Found waveform button in toolbar:', testBtn);
                    console.log('[DEBUG] Button text:', testBtn.textContent);
                    console.log('[DEBUG] Button data-tool:', testBtn.getAttribute('data-tool'));
                } else {
                    console.error('[DEBUG] Waveform button NOT found in toolbar!');
                }
            } else {
                console.error('[DEBUG] .editor-toolbar not found!');
                console.error('[DEBUG] Library tab active?', document.querySelector('#tab-section-library')?.classList.contains('active'));
                console.error('[DEBUG] Editor preview panel exists?', !!document.querySelector('.editor-preview-panel'));
            }
            
            // Also wire individual buttons as fallback (with error handling)
            console.log('[DEBUG] Wiring individual buttons as fallback, count:', toolbarBtns.length);
            toolbarBtns.forEach((btn, index) => {
                try {
                    if (!btn || typeof btn.getAttribute !== 'function') {
                        console.warn(`[WARN] Button ${index} is not a valid element`);
                        return;
                    }
                    const tool = btn.getAttribute('data-tool');
                    if (!tool) {
                        console.warn(`[WARN] Button ${index} has no data-tool attribute`);
                        return;
                    }
                    
                    console.log(`[DEBUG] Button ${index}: tool="${tool}", text="${btn.textContent.trim()}"`);
                    
                    // Remove old listener
                    if (btn._toolbarClickHandler) {
                        btn.removeEventListener('click', btn._toolbarClickHandler);
                    }
                    
                    // Create new handler
                    btn._toolbarClickHandler = function(e) {
                        try {
                            if (e) e.stopPropagation(); // Prevent delegation handler from also firing
                            const tool = this.getAttribute('data-tool');
                    
                    // #region agent log
                    console.log('[DEBUG] Toolbar button clicked:', tool);
                    fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:6842',message:'Toolbar button clicked (fallback)',data:{tool:tool,getCurrentEditorStateExists:typeof window.getCurrentEditorState === 'function'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                    // #endregion
                    
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : (typeof getCurrentEditorState === 'function' ? getCurrentEditorState() : null);
                    
                    // #region agent log
                    console.log('[DEBUG] getCurrentEditorState returned:', !!state);
                    fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:6846',message:'getCurrentEditorState check (fallback)',data:{stateExists:!!state,stateType:state?.editorType,tool:tool},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                    // #endregion
                    
                    // For editor switching (waveform, piano, timeline), don't require state
                    if (!state && !['waveform', 'piano', 'timeline'].includes(tool)) {
                        console.log('[DEBUG] No state and tool is not editor switch, returning');
                        return;
                    }
                    
                    // Update active button
                    toolbarBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Handle tool-specific actions
                    switch(tool) {
                        case 'select':
                            // Enable selection mode
                            break;
                        case 'cut':
                            // Enable cut mode
                            if (state && state.hasSelection()) {
                                handleCut(state);
                            }
                            break;
                        case 'fade':
                            // Enable fade mode
                            break;
                        case 'waveform':
                        case 'piano':
                        case 'timeline':
                            // Switch editor - unified handler with comprehensive error handling
                            try {
                                console.log('[Library Tab] Switching to', tool, 'editor');
                                
                                // Ensure Library tab is active
                                const libraryTab = document.querySelector('#tab-section-library');
                                if (libraryTab && !libraryTab.classList.contains('active')) {
                                    libraryTab.classList.add('active');
                                    console.log('[Library Tab] Activated Library tab');
                                }
                                
                                // Hide all editors with multiple methods for reliability
                                const allEditors = document.querySelectorAll('.editor-content');
                                console.log('[Library Tab] Found', allEditors.length, 'editors to hide');
                                
                                allEditors.forEach(editor => {
                                    editor.classList.remove('active');
                                    editor.style.display = 'none';
                                    editor.style.visibility = 'hidden';
                                    editor.style.opacity = '0';
                                    editor.setAttribute('aria-hidden', 'true');
                                });
                                
                                // Show target editor
                                const editorId = tool === 'piano' ? 'editor-piano-roll' : `editor-${tool}`;
                                const targetEditor = document.getElementById(editorId);
                                
                                if (targetEditor) {
                                    // Show editor with multiple methods
                                    targetEditor.classList.add('active');
                                    targetEditor.style.display = 'block';
                                    targetEditor.style.visibility = 'visible';
                                    targetEditor.style.opacity = '1';
                                    targetEditor.setAttribute('aria-hidden', 'false');
                                    
                                    // Update toolbar button visual state
                                    const editorBtn = document.querySelector(`.toolbar-btn[data-tool="${tool}"]`);
                                    if (editorBtn) {
                                        // Remove active from all toolbar buttons
                                        document.querySelectorAll('.toolbar-btn').forEach(b => {
                                            b.classList.remove('active');
                                            b.style.opacity = '0.7';
                                        });
                                        // Activate clicked button
                                        editorBtn.classList.add('active');
                                        editorBtn.style.opacity = '1';
                                    }
                                    
                                    // Update editor state if available
                                    if (window.editorStates) {
                                        const stateKey = tool === 'piano' ? 'piano-roll' : tool;
                                        if (window.editorStates[stateKey]) {
                                            console.log('[Library Tab] Editor state available for', stateKey);
                                        }
                                    }
                                    
                                    console.log('[Library Tab] Successfully activated', tool, 'editor');
                                    
                                    // Visual feedback
                                    if (typeof updateStatus === 'function') {
                                        updateStatus('ready', `${tool.charAt(0).toUpperCase() + tool.slice(1)} editor active`);
                                    }
                                } else {
                                    console.error('[Library Tab] ERROR: Editor not found:', editorId);
                                    console.error('[Library Tab] Available editors:', Array.from(allEditors).map(e => e.id));
                                    
                                    if (typeof updateStatus === 'function') {
                                        updateStatus('error', `Editor ${editorId} not found`);
                                    }
                                }
                            } catch (err) {
                                console.error('[Library Tab] Error switching editor:', err);
                                if (typeof updateStatus === 'function') {
                                    updateStatus('error', 'Failed to switch editor');
                                }
                            }
                            break;
                        }
                        } catch (err) {
                            console.error('[ERROR] Error in toolbar button handler for ${tool}:', err);
                        }
                    };
                    
                    // Attach handler to button
                    btn.addEventListener('click', btn._toolbarClickHandler);
                    console.log(`[DEBUG] Attached click handler to button: ${tool}`);
                } catch (err) {
                    console.error(`[ERROR] Error wiring button ${index}:`, err);
                }
            });
            
            console.log('[DEBUG] wireToolbarButtons completed, total buttons wired:', toolbarBtns.length);
            
            // Zoom buttons
            const zoomIn = document.getElementById('zoom-in');
            const zoomOut = document.getElementById('zoom-out');
            if (zoomIn) {
                zoomIn.addEventListener('click', () => {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : (typeof getCurrentEditorState === 'function' ? getCurrentEditorState() : null);
                    if (state && typeof handleZoomIn === 'function') {
                        handleZoomIn(state);
                    }
                });
            }
            if (zoomOut) {
                zoomOut.addEventListener('click', () => {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : (typeof getCurrentEditorState === 'function' ? getCurrentEditorState() : null);
                    if (state && typeof handleZoomOut === 'function') {
                        handleZoomOut(state);
                    }
                });
            }
        }
        
        // Initialize Editors
        function initializeEditors() {
            console.log('[DEBUG] initializeEditors called');
            
            // Initialize editor states if not already initialized
            if (!window.editorStates) {
                console.log('[DEBUG] Initializing editor states...');
                window.editorStates = {
                    waveform: { 
                        editorType: 'waveform', 
                        data: {}, 
                        selection: {}, 
                        hasSelection: () => false,
                        clipProperties: { bpm: 120, key: 'C', sampleRate: 44100 }
                    },
                    'piano-roll': { 
                        editorType: 'piano-roll', 
                        data: {}, 
                        selection: {}, 
                        hasSelection: () => false 
                    },
                    timeline: { 
                        editorType: 'timeline', 
                        data: {}, 
                        selection: {}, 
                        hasSelection: () => false 
                    }
                };
            }
            
            // Ensure waveform editor is visible by default when Library tab loads
            const waveformEditor = document.getElementById('editor-waveform');
            const pianoRollEditor = document.getElementById('editor-piano-roll');
            const timelineEditor = document.getElementById('editor-timeline');
            
            if (waveformEditor) {
                // Hide all editors first
                [waveformEditor, pianoRollEditor, timelineEditor].forEach(editor => {
                    if (editor) {
                        editor.classList.remove('active');
                        editor.style.display = 'none';
                        editor.style.visibility = 'hidden';
                        editor.style.opacity = '0';
                    }
                });
                
                // Show waveform editor
                waveformEditor.classList.add('active');
                waveformEditor.style.display = 'block';
                waveformEditor.style.visibility = 'visible';
                waveformEditor.style.opacity = '1';
                
                // Activate waveform toolbar button
                const waveformBtn = document.querySelector('.toolbar-btn[data-tool="waveform"]');
                if (waveformBtn) {
                    document.querySelectorAll('.toolbar-btn').forEach(b => b.classList.remove('active'));
                    waveformBtn.classList.add('active');
                }
                
                console.log('[DEBUG] Waveform editor set as default');
            }
            
            // Editor tab switching
            const editorTabBtns = document.querySelectorAll('.editor-tab-btn');
            const editorContents = document.querySelectorAll('.editor-content');
            
            console.log('[DEBUG] Editor tab buttons found:', editorTabBtns.length);
            console.log('[DEBUG] Editor contents found:', editorContents.length);
            
            editorTabBtns.forEach(btn => {
                btn.addEventListener('click', function() {
                    const editorId = this.dataset.editor;
                    
                    editorTabBtns.forEach(b => b.classList.remove('active'));
                    editorContents.forEach(c => c.classList.remove('active'));
                    
                    this.classList.add('active');
                    const targetEditor = document.getElementById('editor-' + editorId);
                    if (targetEditor) {
                        targetEditor.classList.add('active');
                    }
                });
            });
            
            // Wire toolbar buttons - use requestAnimationFrame and retry mechanism
            function attemptWireToolbarButtons(retries = 3) {
                const toolbar = document.querySelector('.editor-toolbar');
                const toolbarBtns = document.querySelectorAll('.toolbar-btn');
                
                if (toolbar && toolbarBtns.length > 0) {
                    console.log('[DEBUG] Toolbar found, wiring buttons...');
                    wireToolbarButtons();
                } else if (retries > 0) {
                    console.log(`[DEBUG] Toolbar not ready, retrying... (${retries} attempts left)`);
                    setTimeout(() => attemptWireToolbarButtons(retries - 1), 200);
                } else {
                    console.error('[DEBUG] Failed to find toolbar after retries');
                }
            }
            
            // Use requestAnimationFrame to ensure DOM is fully rendered
            requestAnimationFrame(() => {
                setTimeout(() => attemptWireToolbarButtons(3), 50);
            });
            
            // #region agent log
            console.log('[DEBUG] initializeEditors completed, toolbar buttons wired');
            fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:5470',message:'initializeEditors completed',data:{timestamp:Date.now()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
            // #endregion
            
            // Initialize waveform canvas
            const waveformCanvas = document.getElementById('waveform-canvas');
            if (waveformCanvas) {
                const ctx = waveformCanvas.getContext('2d');
                waveformCanvas.width = waveformCanvas.offsetWidth;
                waveformCanvas.height = waveformCanvas.offsetHeight;
                // Draw placeholder waveform
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-cyan') || '#00d4aa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, waveformCanvas.height / 2);
                ctx.lineTo(waveformCanvas.width, waveformCanvas.height / 2);
                ctx.stroke();
            }
            
            // Initialize piano roll
            const pianoRollCanvas = document.getElementById('piano-roll-canvas');
            if (pianoRollCanvas) {
                const ctx = pianoRollCanvas.getContext('2d');
                pianoRollCanvas.width = pianoRollCanvas.offsetWidth;
                pianoRollCanvas.height = pianoRollCanvas.offsetHeight;
            }
        }
        
        // Initialize AI
        function initializeAI() {
            const chatInput = document.getElementById('chat-input');
            const chatSend = document.getElementById('chat-send');
            const chatMessages = document.getElementById('chat-messages');
            
            function sendMessage() {
                const message = chatInput.value.trim();
                if (!message) return;
                
                // Add user message
                const userMsg = document.createElement('div');
                userMsg.className = 'chat-message user';
                userMsg.innerHTML = `
                    <div class="message-avatar"></div>
                    <div class="message-content">
                        <div class="message-text">${message}</div>
                        <div class="message-time">Just now</div>
                    </div>
                `;
                chatMessages.appendChild(userMsg);
                chatInput.value = '';
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                // Simulate AI response
                setTimeout(() => {
                    const aiMsg = document.createElement('div');
                    aiMsg.className = 'chat-message ai';
                    aiMsg.innerHTML = `
                        <div class="message-avatar"></div>
                        <div class="message-content">
                            <div class="message-text">I understand you want to ${message.toLowerCase()}. Let me help you with that.</div>
                            <div class="message-time">Just now</div>
                        </div>
                    `;
                    chatMessages.appendChild(aiMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 500);
            }
            
            if (chatSend) {
                chatSend.addEventListener('click', sendMessage);
            }
            
            if (chatInput) {
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        sendMessage();
                    }
                });
            }
        }
        
        // View toggle handlers for Analyze and Library tabs
        document.querySelectorAll('.view-toggle .toggle-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const viewId = this.dataset.view;
                const toggleContainer = this.closest('.view-toggle');
                const contentContainer = toggleContainer.parentElement;
                
                // Remove active from all buttons and views in this container
                toggleContainer.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                contentContainer.querySelectorAll('.view-content').forEach(v => v.classList.remove('active'));
                
                // Add active to clicked button and corresponding view
                this.classList.add('active');
                
                // Try multiple ID patterns to find the view
                const targetView = contentContainer.querySelector('#view-' + viewId) || 
                                 contentContainer.querySelector('#view-library-' + viewId) ||
                                 contentContainer.querySelector('#view-media-' + viewId) ||
                                 document.getElementById('view-' + viewId) ||
                                 document.getElementById('view-library-' + viewId) ||
                                 document.getElementById('view-media-' + viewId);
                
                if (targetView) {
                    targetView.classList.add('active');
                } else {
                    // Fallback: find by class or data attribute
                    const views = contentContainer.querySelectorAll('.view-content');
                    const viewArray = Array.from(views);
                    const matchingView = viewArray.find(v => v.id && v.id.includes(viewId));
                    if (matchingView) {
                        matchingView.classList.add('active');
                    }
                }
            });
        });
        
        // Update library badge count
        function updateLibraryBadge() {
            const libraryBadge = document.getElementById('library-badge');
            const mediaItems = document.querySelectorAll('.media-item:not(.empty)');
            const count = mediaItems.length;
            
            if (libraryBadge) {
                const libraryTabBtn = document.querySelector('[data-main-tab="library"]');
                if (count > 0) {
                    libraryBadge.textContent = count;
                    libraryBadge.style.display = 'block';
                    if (libraryTabBtn) {
                        libraryTabBtn.classList.add('has-notification');
                    }
                } else {
                    libraryBadge.style.display = 'none';
                    if (libraryTabBtn) {
                        libraryTabBtn.classList.remove('has-notification');
                    }
                }
            }
        }
        
        // Update library badge when media is added (hook into existing function)
        const originalAddToMediaList = window.addToMediaList;
        if (typeof originalAddToMediaList === 'function') {
            window.addToMediaList = function(...args) {
                const result = originalAddToMediaList.apply(this, args);
                updateLibraryBadge();
                return result;
            };
        }
        
        // Keyboard shortcuts for tab switching (Ctrl/Cmd + 1-8)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                const keyMap = {
                    '1': 'create',
                    '2': 'analyze',
                    '3': 'library',
                    '4': 'ai'
                };
                
                if (keyMap[e.key]) {
                    e.preventDefault();
                    const tabBtn = document.querySelector(`[data-main-tab="${keyMap[e.key]}"]`);
                    if (tabBtn) {
                        tabBtn.click();
                    }
                }
            }
        });
        
        // Context-aware tab switching
        // Auto-switch to Analyze tab when file is analyzed
        const originalHandleFile = window.handleFile;
        if (typeof originalHandleFile === 'function') {
            window.handleFile = function(...args) {
                const result = originalHandleFile.apply(this, args);
                // Switch to analyze tab after analysis
                setTimeout(() => {
                    const analyzeTab = document.querySelector('[data-main-tab="analyze"]');
                    if (analyzeTab) {
                        analyzeTab.click();
                    }
                }, 2100); // After analysis completes
                return result;
            };
        }
        
        // Auto-switch to Library tab when generation completes
        document.querySelectorAll('.btn-generate').forEach(btn => {
            const originalClick = btn.onclick;
            btn.addEventListener('click', function() {
                if (originalClick) originalClick.call(this);
                // Switch to library tab after generation
                setTimeout(() => {
                    const libraryTab = document.querySelector('[data-main-tab="library"]');
                    if (libraryTab) {
                        libraryTab.click();
                    }
                }, 1600); // After generation completes
            });
        });
        
        // File drop zone functionality
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        function handleFile(file) {
            console.log('File selected:', file.name);
            // Update status
            updateStatus('analyzing', 'Analyzing...');
            
            // Simulate analysis (in real implementation, send to API)
            // Example: fetch('/analyze/upload', { method: 'POST', body: formData })
            setTimeout(() => {
                updateStatus('ready', 'Ready');
                
                // Simulate analysis response with top 10 genres
                const mockAnalysisData = {
                    sergik_dna: {
                        overall_match: Math.floor(Math.random() * 30) + 70
                    },
                    genre_influence: {
                        sergik_alignment: {
                            'hiphop': 42,
                            'house': 28,
                            'funk': 17,
                            'soul': 13,
                            'techno': 8,
                            'disco': 6,
                            'r&b': 5,
                            'jazz': 4,
                            'ambient': 3,
                            'reggae': 2,
                            'trap': 1.5,  // Will be filtered out (top 10 only)
                            'dubstep': 1.2,  // Will be filtered out (top 10 only)
                            'drum and bass': 1.0  // Will be filtered out (top 10 only)
                        }
                    },
                    musicbrainz: {
                        title: file.name.replace('.wav', '').replace('.mp3', ''),
                        artist: 'SERGIK',
                        releases: ['Demo Album (2024)'],
                        genres: ['house', 'tech house', 'electronic', 'dance', 'techno', 
                                'deep house', 'progressive house', 'bass house', 
                                'tropical house', 'garage house',
                                'minimal techno', 'acid house', 'future house']  // Last 3 will be filtered (top 10 only)
                    }
                };
                
                // Update views with top 10 data
                updateDNAView(mockAnalysisData);
                updateMusicBrainzView(mockAnalysisData);
            }, 2000);
        }
        
        // Mic button functionality
        const micBtn = document.getElementById('mic-btn');
        let isRecording = false;
        
        micBtn.addEventListener('mousedown', () => {
            isRecording = true;
            micBtn.classList.add('recording');
            document.querySelector('.mic-status').textContent = 'Recording...';
        });
        
        micBtn.addEventListener('mouseup', () => {
            isRecording = false;
            micBtn.classList.remove('recording');
            document.querySelector('.mic-status').textContent = 'Push to talk';
        });
        
        micBtn.addEventListener('mouseleave', () => {
            if (isRecording) {
                isRecording = false;
                micBtn.classList.remove('recording');
                document.querySelector('.mic-status').textContent = 'Push to talk';
            }
        });
        
        // Paste button functionality
        document.getElementById('paste-btn').addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                console.log('Pasted:', text);
                // Handle pasted URL or path
                updateStatus('processing', 'Processing...');
                setTimeout(() => {
                    updateStatus('ready', 'Ready');
                }, 1500);
            } catch (err) {
                console.error('Failed to read clipboard:', err);
            }
        });
        
        // Interactive preview - buttons flash on click
        document.querySelectorAll('.btn, .transport-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                this.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    this.style.transform = '';
                }, 100);
            });
        });
        
        // Prompt input demo
        const promptInput = document.querySelector('.prompt-input');
        const commands = [
            'Create a tech house chord progression in D minor',
            'Add Wavetable synth to track 3',
            'Generate 8 bars of minimal techno drums',
            'Set tempo to 126 BPM',
            'Analyze this track and match SERGIK DNA'
        ];
        
        let commandIndex = 0;
        if (promptInput) {
            promptInput.addEventListener('focus', function() {
                if (!this.value) {
                    this.placeholder = commands[commandIndex];
                    commandIndex = (commandIndex + 1) % commands.length;
                }
            });
        }
        
        // Genre system initialization - using modular approach
        // Import and initialize genre system
        import('./js/genre-system.js').then(module => {
            module.initializeGenreSystem();
        }).catch(error => {
            console.error('Failed to load genre system module:', error);
            // Fallback to inline implementation if module loading fails
            console.warn('Falling back to inline genre system');
        });
        
        // Other dropdown change handlers
        document.querySelectorAll('.dropdown-select').forEach(select => {
            if (select.id !== 'genre-select' && select.id !== 'subgenre-select') {
                select.addEventListener('change', function() {
                    console.log(`${this.id} changed to: ${this.value}`);
                });
            }
        });
        
        // Status update function
        function updateStatus(state, text) {
            const statusLed = document.getElementById('status-led');
            const statusText = document.getElementById('status-text-display');
            const statusValue = document.getElementById('status-value');
            
            if (statusLed) {
                statusLed.className = 'status-led ' + state;
            }
            if (statusText) {
                statusText.textContent = text;
            }
            if (statusValue) {
                statusValue.textContent = text;
            }
        }
        
        // Audio/MIDI Toggle Management
        const toggleAudio = document.getElementById('toggle-audio');
        const toggleMidi = document.getElementById('toggle-midi');
        const generateButtons = document.querySelectorAll('.btn-generate');
        
        function updateGenerateButtons() {
            const audioEnabled = toggleAudio.checked;
            const midiEnabled = toggleMidi.checked;
            const bothDisabled = !audioEnabled && !midiEnabled;
            
            generateButtons.forEach(btn => {
                btn.disabled = bothDisabled;
            });
        }
        
        if (toggleAudio && toggleMidi) {
            toggleAudio.addEventListener('change', updateGenerateButtons);
            toggleMidi.addEventListener('change', updateGenerateButtons);
            updateGenerateButtons(); // Initial state
        }
        
        // Generate Button Handlers
        if (generateButtons.length > 0) {
            generateButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    if (this.disabled) return;
                    
                    const type = this.dataset.type;
                    const audioEnabled = toggleAudio ? toggleAudio.checked : true;
                    const midiEnabled = toggleMidi ? toggleMidi.checked : true;
                    
                    // Visual feedback
                    this.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        this.style.transform = '';
                    }, 100);
                    
                    // Update status
                    updateStatus('processing', 'Generating ' + type + '...');
                    
                    // Generate media (in real implementation, call API)
                    setTimeout(() => {
                        const outputTypes = [];
                        if (audioEnabled) outputTypes.push('audio');
                        if (midiEnabled) outputTypes.push('midi');
                        
                        addToMediaList(type, outputTypes);
                        updateStatus('ready', 'Ready');
                    }, 1500);
                });
            });
        }
        
        // Media List Management
        const mediaList = document.getElementById('media-list');
        let mediaItems = [];
        
        function addToMediaList(type, outputTypes) {
            outputTypes.forEach(outputType => {
                const item = {
                    id: Date.now() + Math.random(),
                    name: type.charAt(0).toUpperCase() + type.slice(1) + ' ' + outputType.toUpperCase(),
                    type: outputType,
                    category: type,
                    timestamp: new Date()
                };
                mediaItems.push(item);
            });
            renderMediaList();
        }
        
        function renderMediaList() {
            if (!mediaList) return;
            if (mediaItems.length === 0) {
                mediaList.innerHTML = '<div class="media-item empty"><span>No generated media yet</span></div>';
                return;
            }
            
            mediaList.innerHTML = mediaItems.map(item => {
                const icon = item.type === 'audio' ? '&#127925;' : '&#127931;';
                return `
                    <div class="media-item" data-id="${item.id}">
                        <div class="media-item-header">
                            <span class="media-item-icon">${icon}</span>
                            <div>
                                <div class="media-item-name">${item.name}</div>
                                <div class="media-item-type">${item.category}  ${item.type.toUpperCase()}</div>
                            </div>
                        </div>
                        <div class="media-item-actions">
                            <button class="media-item-btn insert" onclick="insertMedia('${item.id}')">Insert</button>
                            <button class="media-item-btn replace" onclick="replaceMedia('${item.id}')">Replace</button>
                            <button class="media-item-btn commit" onclick="commitMedia('${item.id}')">Commit</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Media action functions
        window.insertMedia = function(id) {
            const item = mediaItems.find(m => m.id == id);
            if (item) {
                updateStatus('processing', 'Inserting ' + item.name + '...');
                setTimeout(() => updateStatus('ready', 'Ready'), 1000);
            }
        };
        
        window.replaceMedia = function(id) {
            const item = mediaItems.find(m => m.id == id);
            if (item) {
                updateStatus('processing', 'Replacing with ' + item.name + '...');
                setTimeout(() => updateStatus('ready', 'Ready'), 1000);
            }
        };
        
        window.commitMedia = function(id) {
            const item = mediaItems.find(m => m.id == id);
            if (item) {
                const slotSelect = document.getElementById('slot-select');
                const slotValue = slotSelect ? slotSelect.value : '';
                if (!slotValue || slotValue === 'mouse') {
                    updateStatus('error', 'Select a slot first');
                    return;
                }
                updateStatus('processing', 'Committing ' + item.name + '...');
                setTimeout(() => updateStatus('ready', 'Ready'), 1000);
            }
        };
        
        // Update DNA view with analysis results (limit to top 10)
        // Call this function when analysis completes: updateDNAView(analysisResponse)
        function updateDNAView(analysisData) {
            if (!analysisData || !analysisData.sergik_dna) return;
            
            const dnaData = analysisData.sergik_dna;
            const genreInfluence = analysisData.genre_influence || {};
            
            // Update DNA score
            const dnaScore = dnaData.overall_match || 0;
            document.getElementById('dna-score').textContent = dnaScore + '%';
            document.querySelector('.gauge-fill').style.width = dnaScore + '%';
            
            // Update genre bars (limit to top 10)
            const genreBarsContainer = document.querySelector('#view-dna .genre-bars');
            if (genreBarsContainer && genreInfluence.sergik_alignment) {
                const alignment = genreInfluence.sergik_alignment;
                
                // Sort by value and take top 10
                const allGenres = Object.entries(alignment).sort((a, b) => b[1] - a[1]);
                const sortedGenres = allGenres.slice(0, 10);
                const totalGenres = allGenres.length;
                
                // Clear existing bars (but keep the panel title)
                const panelTitle = genreBarsContainer.querySelector('.panel-title');
                const existingBars = genreBarsContainer.querySelectorAll('.genre-bar');
                existingBars.forEach(bar => bar.remove());
                
                // Update panel title to show count if more than 10
                if (panelTitle) {
                    if (totalGenres > 10) {
                        panelTitle.textContent = `Genre Influence (Top 10 of ${totalGenres})`;
                    } else {
                        panelTitle.textContent = `Genre Influence (Top ${sortedGenres.length})`;
                    }
                }
                
                // Add top 10 genre bars
                if (sortedGenres.length === 0) {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.style.cssText = 'padding: 20px; color: var(--text-secondary); text-align: center; font-size: 12px;';
                    emptyMsg.textContent = 'No genre data available';
                    genreBarsContainer.appendChild(emptyMsg);
                } else {
                    sortedGenres.forEach(([genre, percentage]) => {
                        const genreBar = document.createElement('div');
                        genreBar.className = 'genre-bar';
                        genreBar.innerHTML = `
                            <div class="genre-bar-header">
                                <span class="genre-bar-name">${genre.charAt(0).toUpperCase() + genre.slice(1)}</span>
                                <span class="genre-bar-value">${Math.round(percentage)}%</span>
                            </div>
                            <div class="genre-bar-track">
                                <div class="genre-bar-fill ${genre}" style="width: ${Math.min(100, percentage)}%;"></div>
                            </div>
                        `;
                        genreBarsContainer.appendChild(genreBar);
                    });
                }
            }
        }
        
        // Update MusicBrainz view with analysis results (limit to top 10)
        // Call this function when analysis completes: updateMusicBrainzView(analysisResponse)
        function updateMusicBrainzView(analysisData) {
            if (!analysisData || !analysisData.musicbrainz) return;
            
            const mbData = analysisData.musicbrainz;
            
            // Update track info
            if (mbData.title) document.getElementById('mb-title').textContent = mbData.title;
            if (mbData.artist) document.getElementById('mb-artist').textContent = mbData.artist;
            if (mbData.releases && mbData.releases.length > 0) {
                document.getElementById('mb-album').textContent = mbData.releases[0];
            }
            
            // Update genre bars (limit to top 10)
            const genreBarsContainer = document.querySelector('#view-musicbrainz .genre-bars');
            if (genreBarsContainer && mbData.genres) {
                const allGenres = Array.isArray(mbData.genres) ? mbData.genres : [];
                const genres = allGenres.slice(0, 10);
                const totalGenres = allGenres.length;
                
                // Clear existing bars (but keep the panel title)
                const panelTitle = genreBarsContainer.querySelector('.panel-title');
                const existingBars = genreBarsContainer.querySelectorAll('.genre-bar');
                existingBars.forEach(bar => bar.remove());
                
                // Update panel title to show count if more than 10
                if (panelTitle) {
                    if (totalGenres > 10) {
                        panelTitle.textContent = `Genre Analysis (Top 10 of ${totalGenres})`;
                    } else {
                        panelTitle.textContent = `Genre Analysis (Top ${genres.length})`;
                    }
                }
                
                // Add top 10 genre bars
                if (genres.length === 0) {
                    const emptyMsg = document.createElement('div');
                    emptyMsg.style.cssText = 'padding: 20px; color: var(--text-secondary); text-align: center; font-size: 12px;';
                    emptyMsg.textContent = 'No genres found';
                    genreBarsContainer.appendChild(emptyMsg);
                } else {
                    genres.forEach((genre, index) => {
                        // Calculate percentage (decreasing for visual effect, max 10 items)
                        const percentage = Math.max(20, 100 - (index * 8));
                        
                        // Map genre to DNA category for color coding
                        const genreLower = genre.toLowerCase();
                        let category = 'house';
                        if (genreLower.includes('hip') || genreLower.includes('rap') || genreLower.includes('trap')) category = 'hiphop';
                        else if (genreLower.includes('funk') || genreLower.includes('disco') || genreLower.includes('reggae')) category = 'funk';
                        else if (genreLower.includes('soul') || genreLower.includes('r&b') || genreLower.includes('jazz')) category = 'soul';
                        
                        const genreBar = document.createElement('div');
                        genreBar.className = 'genre-bar';
                        genreBar.innerHTML = `
                            <div class="genre-bar-header">
                                <span class="genre-bar-name">${genre.charAt(0).toUpperCase() + genre.slice(1)}</span>
                                <span class="genre-bar-value">${percentage}%</span>
                            </div>
                            <div class="genre-bar-track">
                                <div class="genre-bar-fill ${category}" style="width: ${percentage}%;"></div>
                            </div>
                        `;
                        genreBarsContainer.appendChild(genreBar);
                    });
                }
            }
        }
        
        // View toggle functionality (DNA / MusicBrainz / Media Browser)
        const viewToggleBtns = document.querySelectorAll('.view-toggle .toggle-btn');
        
        viewToggleBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                const viewId = this.dataset.view;
                const toggleContainer = this.closest('.view-toggle');
                
                // Find all views in the same container
                const parentPanel = toggleContainer.closest('.panel, .results-panel');
                const allViews = parentPanel ? parentPanel.querySelectorAll('.view-content') : [];
                const allToggleBtns = toggleContainer.querySelectorAll('.toggle-btn');
                
                // Remove active class from all toggle buttons and views in this container
                allToggleBtns.forEach(b => b.classList.remove('active'));
                allViews.forEach(v => v.classList.remove('active'));
                
                // Add active class to clicked button and corresponding view
                this.classList.add('active');
                
                // Try multiple ID patterns to find the view
                let targetView = parentPanel ? parentPanel.querySelector('#view-' + viewId) : document.getElementById('view-' + viewId);
                if (!targetView) {
                    // Try library-specific IDs
                    targetView = parentPanel ? parentPanel.querySelector('#view-library-' + viewId) : document.getElementById('view-library-' + viewId);
                }
                if (!targetView) {
                    // Try media-specific IDs
                    targetView = parentPanel ? parentPanel.querySelector('#view-media-' + viewId) : document.getElementById('view-media-' + viewId);
                }
                if (!targetView) {
                    // Fallback: find by class and data attribute
                    const allViews = parentPanel ? parentPanel.querySelectorAll('.view-content') : document.querySelectorAll('.view-content');
                    targetView = Array.from(allViews).find(v => v.id && v.id.includes(viewId));
                }
                
                if (targetView) {
                    targetView.classList.add('active');
                }
            });
        });
        
        // Commit button validation
        const trackSelect = document.getElementById('track-select');
        const slotSelect = document.getElementById('slot-select');
        const commitBtn = document.getElementById('commit-btn');
        const placementIndicator = document.getElementById('placement-indicator');
        
        function updateCommitState() {
            const trackValue = trackSelect.value;
            const slotValue = slotSelect.value;
            
            // Slot rules:
            // - "" => not selected
            // - "mouse" => waiting for user to click a slot in Ableton (cannot commit yet)
            // - anything else => selected
            const isMousePickMode = slotValue === 'mouse';
            const slotSelected = slotValue !== '' && !isMousePickMode;
            
            if (isMousePickMode) {
                commitBtn.disabled = true;
                slotSelect.classList.add('required');
                slotSelect.classList.remove('valid');
                placementIndicator.textContent = 'Click slot in Ableton...';
                placementIndicator.classList.add('waiting');
                placementIndicator.classList.remove('ready');
                return;
            }
            
            if (slotSelected) {
                // Enable commit button
                commitBtn.disabled = false;
                slotSelect.classList.remove('required');
                slotSelect.classList.add('valid');
                
                // Update placement indicator
                let trackName = trackSelect.options[trackSelect.selectedIndex].text;
                let slotName = slotSelect.options[slotSelect.selectedIndex].text;
                placementIndicator.textContent = `${trackName}  ${slotName}`;
                placementIndicator.classList.remove('waiting');
                placementIndicator.classList.add('ready');
            } else {
                // Disable commit button
                commitBtn.disabled = true;
                slotSelect.classList.add('required');
                slotSelect.classList.remove('valid');
                
                // Update placement indicator
                placementIndicator.textContent = 'Select slot...';
                placementIndicator.classList.add('waiting');
                placementIndicator.classList.remove('ready');
            }
        }
        
        trackSelect.addEventListener('change', updateCommitState);
        slotSelect.addEventListener('change', updateCommitState);
        
        // Commit button click handler
        commitBtn.addEventListener('click', function() {
            if (!this.disabled) {
                const trackValue = trackSelect.value;
                const slotValue = slotSelect.value;
                const trackName = trackSelect.options[trackSelect.selectedIndex].text;
                const slotName = slotSelect.options[slotSelect.selectedIndex].text;
                
                console.log(`Committing clip to: ${trackName}, ${slotName}`);
                
                // Visual feedback
                this.style.background = 'linear-gradient(180deg, #10b981 0%, #059669 100%)';
                this.innerHTML = '<span class="icon">&#10004;</span><span>Committed!</span>';
                
                // Reset after 2 seconds
                setTimeout(() => {
                    this.style.background = '';
                    this.innerHTML = '<span class="icon">&#127916;</span><span>Commit to Track</span>';
                }, 2000);
                
                // Add to action log
                const actionList = document.querySelector('.action-list');
                const newAction = document.createElement('div');
                newAction.className = 'action-item success';
                newAction.textContent = `+ Clip  ${trackName}, ${slotName}`;
                actionList.insertBefore(newAction, actionList.firstChild);
                
                // Remove oldest action if more than 5
                if (actionList.children.length > 5) {
                    actionList.removeChild(actionList.lastChild);
                }
            }
        });
        
        // Initialize commit state
        updateCommitState();
        
        // Quick actions bar functionality
        document.querySelectorAll('.quick-action-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const tabId = this.dataset.quickTab;
                const mainTabBtn = document.querySelector(`[data-main-tab="${tabId}"]`);
                if (mainTabBtn) {
                    mainTabBtn.click();
                }
            });
            
            // Update active state
            btn.addEventListener('click', function() {
                document.querySelectorAll('.quick-action-btn').forEach(b => {
                    b.style.opacity = '0.7';
                });
                this.style.opacity = '1';
            });
        });
        // Info Popup System
        (function() {
            let popupElement = null;
            let popupTimer = null;
            let currentElement = null;
            const HOVER_DELAY = 1000; // 1 second
            
            // Detect platform
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            
            // Create popup element
            function createInfoPopup() {
                if (popupElement) return popupElement;
                
                popupElement = document.createElement('div');
                popupElement.className = 'info-popup';
                popupElement.id = 'info-popup';
                popupElement.innerHTML = `
                    <div class="info-popup-arrow"></div>
                    <div class="info-popup-title"></div>
                    <div class="info-popup-desc"></div>
                    <div class="info-popup-shortcut"></div>
                `;
                document.body.appendChild(popupElement);
                return popupElement;
            }
            
            // Format shortcut for platform
            function formatShortcut(shortcut) {
                if (!shortcut) return null;
                if (isMac) {
                    return shortcut.replace(/Ctrl\+/g, 'Cmd+').replace(/Alt\+/g, 'Option+');
                }
                return shortcut;
            }
            
            // Get element info from data attributes
            function getElementInfo(element) {
                // Ensure element is a valid DOM element (not a text node, etc.)
                if (!element || typeof element.getAttribute !== 'function') {
                    // #region agent log
                    if (element && element.nodeType !== undefined) {
                        fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:7862',message:'getElementInfo invalid element',data:{nodeType:element.nodeType,hasGetAttribute:typeof element.getAttribute === 'function'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
                    }
                    // #endregion
                    return null;
                }
                
                const title = element.getAttribute('data-info-title');
                const desc = element.getAttribute('data-info-desc');
                const shortcut = element.getAttribute('data-info-shortcut');
                
                if (!title && !desc) return null;
                
                return {
                    title: title || '',
                    desc: desc || '',
                    shortcut: formatShortcut(shortcut)
                };
            }
            
            // Calculate popup position
            function calculatePopupPosition(element) {
                const rect = element.getBoundingClientRect();
                const popup = popupElement;
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const scrollX = window.scrollX || window.pageXOffset;
                const scrollY = window.scrollY || window.pageYOffset;
                
                // Default: below element
                let top = rect.bottom + scrollY + 6;
                let left = rect.left + scrollX + (rect.width / 2);
                let position = 'below';
                
                // Check if popup would overflow viewport
                const popupWidth = 250; // max-width
                const popupHeight = 100; // estimated
                
                // Check bottom overflow
                if (rect.bottom + popupHeight + 12 > viewportHeight) {
                    // Show above instead
                    top = rect.top + scrollY - popupHeight - 6;
                    position = 'above';
                }
                
                // Check right overflow
                if (left + popupWidth / 2 > viewportWidth) {
                    left = viewportWidth - popupWidth / 2 - 10;
                }
                
                // Check left overflow
                if (left - popupWidth / 2 < 0) {
                    left = popupWidth / 2 + 10;
                }
                
                return { top, left, position };
            }
            
            // Show popup
            function showInfoPopup(element, info) {
                if (!info) return;
                
                const popup = createInfoPopup();
                const pos = calculatePopupPosition(element);
                
                // Update content
                popup.querySelector('.info-popup-title').textContent = info.title;
                popup.querySelector('.info-popup-desc').textContent = info.desc;
                
                const shortcutEl = popup.querySelector('.info-popup-shortcut');
                if (info.shortcut) {
                    shortcutEl.innerHTML = `Shortcut: <kbd>${info.shortcut}</kbd>`;
                    shortcutEl.style.display = 'block';
                } else {
                    shortcutEl.style.display = 'none';
                }
                
                // Position popup
                popup.style.top = pos.top + 'px';
                popup.style.left = pos.left + 'px';
                popup.style.transform = 'translateX(-50%)';
                
                // Update arrow position
                if (pos.position === 'above') {
                    popup.classList.add('above');
                } else {
                    popup.classList.remove('above');
                }
                
                // Show with animation
                setTimeout(() => {
                    popup.classList.add('visible');
                }, 10);
                
                currentElement = element;
            }
            
            // Hide popup
            function hideInfoPopup() {
                if (popupElement) {
                    popupElement.classList.remove('visible');
                }
                if (popupTimer) {
                    clearTimeout(popupTimer);
                    popupTimer = null;
                }
                currentElement = null;
            }
            
            // Handle mouse enter
            function handleMouseEnter(e) {
                const element = e.target;
                const info = getElementInfo(element);
                
                if (!info) return;
                
                // Clear any existing timer
                if (popupTimer) {
                    clearTimeout(popupTimer);
                }
                
                // Hide current popup if different element
                if (currentElement && currentElement !== element) {
                    hideInfoPopup();
                }
                
                // Set timer to show popup after delay
                popupTimer = setTimeout(() => {
                    showInfoPopup(element, info);
                }, HOVER_DELAY);
            }
            
            // Handle mouse leave
            function handleMouseLeave(e) {
                if (popupTimer) {
                    clearTimeout(popupTimer);
                    popupTimer = null;
                }
                hideInfoPopup();
            }
            
            // Initialize popup system
            function initInfoPopupSystem() {
                // Use event delegation on document
                document.addEventListener('mouseenter', function(e) {
                    // Check if element or parent has data attributes
                    let element = e.target;
                    let info = null;
                    
                    // Check element and parents up to 3 levels
                    for (let i = 0; i < 3 && element && element !== document.body; i++) {
                        // Skip text nodes and other non-elements
                        if (element.nodeType === Node.ELEMENT_NODE) {
                            info = getElementInfo(element);
                            if (info) break;
                        }
                        element = element.parentElement;
                    }
                    
                    if (info && element && element.nodeType === Node.ELEMENT_NODE && typeof element.getAttribute === 'function') {
                        handleMouseEnter({ target: element });
                    }
                }, true);
                
                document.addEventListener('mouseleave', function(e) {
                    let element = e.target;
                    let hasInfo = false;
                    
                    // Check if leaving an element with info
                    for (let i = 0; i < 3 && element && element !== document.body; i++) {
                        // Skip text nodes and other non-elements
                        if (element.nodeType === Node.ELEMENT_NODE && getElementInfo(element)) {
                            hasInfo = true;
                            break;
                        }
                        element = element.parentElement;
                    }
                    
                    if (hasInfo) {
                        handleMouseLeave(e);
                    }
                }, true);
            }
            
            // Initialize on DOM ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initInfoPopupSystem);
            } else {
                initInfoPopupSystem();
            }
        })();
        
        // Editor State Management System
        (function() {
            class EditorState {
                constructor(editorType) {
                    this.editorType = editorType; // 'waveform', 'piano-roll', 'timeline'
                    this.selection = {
                        start: 0,
                        end: 0,
                        items: [] // Selected notes, clips, or regions
                    };
                    this.clipboard = null;
                    this.data = {
                        waveform: null, // Audio samples
                        notes: [], // MIDI notes: {pitch, start, duration, velocity}
                        clips: [] // Timeline clips: {track, start, end, loop}
                    };
                    this.zoom = {
                        horizontal: 1.0,
                        vertical: 1.0
                    };
                    this.viewport = {
                        x: 0,
                        y: 0
                    };
                    this.snap = {
                        enabled: true,
                        mode: 'grid', // 'grid', 'zero-crossing', 'off'
                        gridSize: 1/16
                    };
                    this.undoStack = [];
                    this.redoStack = [];
                    this.maxHistorySize = 50;
                    
                    // Media reference (added for media management integration)
                    this.currentMedia = {
                        id: null,
                        name: null,
                        path: null,
                        type: null,
                        metadata: {}
                    };
                    
                    // Variable reference
                    this.currentVariable = null;
                    
                    // Clip properties (Ableton-native)
                    this.clipProperties = {
                        warp: {
                            enabled: false,
                            mode: 'beats', // beats, tones, texture, repitch, complex, complex-pro
                            markers: [] // Warp markers: [{time, beatTime}]
                        },
                        gain: 0.0, // dB (-12 to +12)
                        transpose: 0, // semitones (-48 to +48)
                        loop: {
                            enabled: false,
                            start: 0,
                            end: 0
                        },
                        launch: {
                            mode: 'trigger', // trigger, gate, toggle, repeat
                            quantization: 'none', // none, 8, 4, 2, 1, 1/2, 1/4, 1/8
                            followAction: 'none' // none, next, previous, first, random
                        },
                        color: '#00d4aa',
                        bpm: 120,
                        key: 'C',
                        sampleRate: 44100
                    };
                    
                    // Piano roll enhancements
                    this.pianoRollSettings = {
                        showGrid: true,
                        showNoteNames: false,
                        scaleHighlight: false,
                        scale: 'major',
                        foldOctaves: false,
                        showVelocityLane: true,
                        showCCLanes: [1] // CC lanes to show
                    };
                    
                    // Timeline enhancements
                    this.timelineSettings = {
                        trackHeight: 80,
                        showAutomation: true,
                        trackFolding: {}
                    };
                }
                
                saveState() {
                    const state = {
                        selection: JSON.parse(JSON.stringify(this.selection)),
                        data: JSON.parse(JSON.stringify(this.data)),
                        zoom: JSON.parse(JSON.stringify(this.zoom)),
                        viewport: JSON.parse(JSON.stringify(this.viewport)),
                        snap: JSON.parse(JSON.stringify(this.snap)),
                        clipProperties: JSON.parse(JSON.stringify(this.clipProperties)),
                        pianoRollSettings: JSON.parse(JSON.stringify(this.pianoRollSettings)),
                        timelineSettings: JSON.parse(JSON.stringify(this.timelineSettings)),
                        currentMedia: JSON.parse(JSON.stringify(this.currentMedia)),
                        currentVariable: this.currentVariable
                    };
                    this.undoStack.push(state);
                    if (this.undoStack.length > this.maxHistorySize) {
                        this.undoStack.shift();
                    }
                    this.redoStack = []; // Clear redo on new action
                }
                
                undo() {
                    if (this.undoStack.length === 0) return false;
                    const currentState = {
                        selection: JSON.parse(JSON.stringify(this.selection)),
                        data: JSON.parse(JSON.stringify(this.data)),
                        zoom: JSON.parse(JSON.stringify(this.zoom)),
                        viewport: JSON.parse(JSON.stringify(this.viewport)),
                        snap: JSON.parse(JSON.stringify(this.snap)),
                        clipProperties: JSON.parse(JSON.stringify(this.clipProperties)),
                        pianoRollSettings: JSON.parse(JSON.stringify(this.pianoRollSettings)),
                        timelineSettings: JSON.parse(JSON.stringify(this.timelineSettings)),
                        currentMedia: JSON.parse(JSON.stringify(this.currentMedia)),
                        currentVariable: this.currentVariable
                    };
                    this.redoStack.push(currentState);
                    const previousState = this.undoStack.pop();
                    this.restoreState(previousState);
                    return true;
                }
                
                redo() {
                    if (this.redoStack.length === 0) return false;
                    const currentState = {
                        selection: JSON.parse(JSON.stringify(this.selection)),
                        data: JSON.parse(JSON.stringify(this.data)),
                        zoom: JSON.parse(JSON.stringify(this.zoom)),
                        viewport: JSON.parse(JSON.stringify(this.viewport)),
                        snap: JSON.parse(JSON.stringify(this.snap)),
                        clipProperties: JSON.parse(JSON.stringify(this.clipProperties)),
                        pianoRollSettings: JSON.parse(JSON.stringify(this.pianoRollSettings)),
                        timelineSettings: JSON.parse(JSON.stringify(this.timelineSettings)),
                        currentMedia: JSON.parse(JSON.stringify(this.currentMedia)),
                        currentVariable: this.currentVariable
                    };
                    this.undoStack.push(currentState);
                    const previousState = this.redoStack.pop();
                    this.restoreState(previousState);
                    return true;
                }
                
                restoreState(state) {
                    this.selection = state.selection;
                    this.data = state.data;
                    this.zoom = state.zoom;
                    this.viewport = state.viewport;
                    this.snap = state.snap;
                    if (state.clipProperties) this.clipProperties = state.clipProperties;
                    if (state.pianoRollSettings) this.pianoRollSettings = state.pianoRollSettings;
                    if (state.timelineSettings) this.timelineSettings = state.timelineSettings;
                    if (state.currentMedia) this.currentMedia = state.currentMedia;
                    if (state.currentVariable !== undefined) this.currentVariable = state.currentVariable;
                }
                
                hasSelection() {
                    return this.selection.items.length > 0 || 
                           (this.selection.start !== this.selection.end);
                }
                
                clearSelection() {
                    this.selection = { start: 0, end: 0, items: [] };
                }
                
                selectAll() {
                    if (this.editorType === 'waveform') {
                        this.selection.start = 0;
                        this.selection.end = this.data.waveform ? this.data.waveform.length : 0;
                    } else if (this.editorType === 'piano-roll') {
                        this.selection.items = [...this.data.notes];
                    } else if (this.editorType === 'timeline') {
                        this.selection.items = [...this.data.clips];
                    }
                }
                
                invertSelection() {
                    if (this.editorType === 'piano-roll') {
                        const selected = new Set(this.selection.items);
                        this.selection.items = this.data.notes.filter(note => !selected.has(note));
                    } else if (this.editorType === 'timeline') {
                        const selected = new Set(this.selection.items);
                        this.selection.items = this.data.clips.filter(clip => !selected.has(clip));
                    }
                }
            }
            
            // Global editor state instances
            window.editorStates = {
                waveform: new EditorState('waveform'),
                'piano-roll': new EditorState('piano-roll'),
                timeline: new EditorState('timeline')
            };
            
            // Global clipboard
            window.editorClipboard = {
                type: null, // 'waveform', 'notes', 'clips'
                data: null
            };
        })();
        
        // Max for Live Communication Layer
        (function() {
            class MaxCommunication {
                constructor() {
                    this.connected = false;
                    this.commandQueue = [];
                    this.responseHandlers = new Map();
                    this.messageId = 0;
                    this.init();
                }
                
                init() {
                    // Check if we're in Max for Live environment
                    if (typeof this.max !== 'undefined' || typeof window.max !== 'undefined') {
                        this.connected = true;
                        this.setupListeners();
                    } else {
                        // Simulate connection for preview/testing
                        this.connected = true;
                        console.log('Max for Live: Simulated connection (preview mode)');
                    }
                }
                
                setupListeners() {
                    // Listen for messages from Max
                    if (typeof this.max !== 'undefined') {
                        this.max.addHandler('fromMax', 'max', (msg) => {
                            this.handleResponse(msg);
                        });
                    }
                }
                
                isConnected() {
                    return this.connected;
                }
                
                sendCommand(command, args = [], callback = null) {
                    const messageId = this.messageId++;
                    const message = {
                        id: messageId,
                        command: command,
                        args: args
                    };
                    
                    if (callback) {
                        this.responseHandlers.set(messageId, callback);
                    }
                    
                    if (this.connected) {
                        if (typeof this.max !== 'undefined') {
                            // Real Max environment
                            this.max.outlet(0, command, ...args);
                        } else {
                            // Simulated - execute locally
                            setTimeout(() => {
                                this.handleSimulatedResponse(messageId, command, args);
                            }, 10);
                        }
                    } else {
                        this.commandQueue.push(message);
                    }
                    
                    return messageId;
                }
                
                handleSimulatedResponse(messageId, command, args) {
                    // Simulate responses for preview mode
                    let response = { status: 'ok', command: command };
                    
                    try {
                        switch(command) {
                            case 'get_clip_notes':
                                if (window.editorStates && window.editorStates['piano-roll']) {
                                    response.notes = window.editorStates['piano-roll'].data.notes || [];
                                } else {
                                    response.notes = [];
                                }
                                break;
                            case 'set_quantization':
                                response.quantization = args && args[0] ? args[0] : '1/16';
                                break;
                            case 'mute_track':
                            case 'solo_track':
                            case 'arm_track':
                                response.track = args && args[0] !== undefined ? args[0] : 0;
                                response.state = args && args[1] !== undefined ? args[1] : true;
                                break;
                            case 'duplicate_clip':
                                response.clip = { 
                                    track: args && args[0] !== undefined ? args[0] : 0, 
                                    slot: args && args[1] !== undefined ? args[1] : 0 
                                };
                                break;
                            default:
                                response.status = 'ok';
                        }
                        
                        const handler = this.responseHandlers && this.responseHandlers.get ? this.responseHandlers.get(messageId) : null;
                        if (handler && typeof handler === 'function') {
                            handler(response);
                            if (this.responseHandlers && this.responseHandlers.delete) {
                                this.responseHandlers.delete(messageId);
                            }
                        } else {
                            console.log('[MaxCommunication] No handler for message:', messageId, 'command:', command);
                        }
                    } catch (error) {
                        console.error('[MaxCommunication] Error in handleSimulatedResponse:', error);
                    }
                }
                
                handleResponse(msg) {
                    if (msg && msg.id !== undefined) {
                        const handler = this.responseHandlers.get(msg.id);
                        if (handler) {
                            handler(msg);
                            this.responseHandlers.delete(msg.id);
                        }
                    }
                }
            }
            
            window.maxCommunication = new MaxCommunication();
            window.maxComms = window.maxCommunication; // Alias for compatibility
        })();
        
        // Enhanced Library Tab - Ableton Native Workflow Integration
        (function() {
            'use strict';
            
            // Initialize Ableton-native controls
            function initAbletonWorkflowControls() {
                try {
                    console.log('[DEBUG] initAbletonWorkflowControls called');
                    
                    // Verify key elements exist
                    const warpToggle = document.getElementById('warp-toggle');
                    const previewPlay = document.getElementById('preview-play');
                    const clipHeader = document.querySelector('.clip-header');
                    const previewPanel = document.querySelector('.preview-controls-panel');
                    
                    console.log('[DEBUG] Element existence check:', {
                        warpToggle: !!warpToggle,
                        previewPlay: !!previewPlay,
                        clipHeader: !!clipHeader,
                        previewPanel: !!previewPanel
                    });
                    
                    // Initialize all control groups with error handling
                    try {
                        initWaveformControls();
                    } catch (err) {
                        console.error('[ERROR] Error initializing waveform controls:', err);
                    }
                    
                    try {
                        initPianoRollControls();
                    } catch (err) {
                        console.error('[ERROR] Error initializing piano roll controls:', err);
                    }
                    
                    try {
                        initTimelineControls();
                    } catch (err) {
                        console.error('[ERROR] Error initializing timeline controls:', err);
                    }
                    
                    try {
                        initPreviewControls();
                    } catch (err) {
                        console.error('[ERROR] Error initializing preview controls:', err);
                    }
                    
                    try {
                        initClipProperties();
                    } catch (err) {
                        console.error('[ERROR] Error initializing clip properties:', err);
                    }
                    
                    console.log('[DEBUG] initAbletonWorkflowControls completed');
                } catch (err) {
                    console.error('[ERROR] Error in initAbletonWorkflowControls:', err);
                }
            }
            
            // Waveform Editor Controls
            function initWaveformControls() {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:6510',message:'initWaveformControls entry',data:{timestamp:Date.now()},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
                // #endregion
                
                const warpToggle = document.getElementById('warp-toggle');
                const warpMode = document.getElementById('warp-mode');
                const clipGain = document.getElementById('clip-gain');
                const clipGainValue = document.getElementById('clip-gain-value');
                const clipTranspose = document.getElementById('clip-transpose');
                const clipTransposeValue = document.getElementById('clip-transpose-value');
                const clipColor = document.getElementById('clip-color');
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:6522',message:'Waveform elements found',data:{warpToggle:!!warpToggle,warpMode:!!warpMode,clipGain:!!clipGain,clipColor:!!clipColor},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                // #endregion
                
                if (warpToggle) {
                    warpToggle.addEventListener('change', function() {
                        const state = window.editorStates?.waveform;
                        if (state) {
                            state.clipProperties.warp.enabled = this.checked;
                            state.saveState();
                            if (window.updateWaveformCanvas) window.updateWaveformCanvas();
                            sendToMax('set_warp', state.clipProperties.warp.enabled);
                            showNotification(`Warp ${state.clipProperties.warp.enabled ? 'ON' : 'OFF'}`);
                        }
                    });
                }
                
                if (warpMode) {
                    warpMode.addEventListener('change', function() {
                        const state = window.editorStates?.waveform;
                        if (state) {
                            state.clipProperties.warp.mode = this.value;
                            state.saveState();
                            if (window.updateWaveformCanvas) window.updateWaveformCanvas();
                            sendToMax('set_warp_mode', this.value);
                            showNotification(`Warp Mode: ${this.value}`);
                        }
                    });
                }
                
                if (clipGain && clipGainValue) {
                    clipGain.addEventListener('input', function() {
                        const value = parseFloat(this.value);
                        clipGainValue.textContent = value.toFixed(1) + ' dB';
                        const state = window.editorStates?.waveform;
                        if (state) {
                            state.clipProperties.gain = value;
                            state.saveState();
                            sendToMax('set_clip_gain', value);
                        }
                    });
                }
                
                if (clipTranspose && clipTransposeValue) {
                    clipTranspose.addEventListener('input', function() {
                        const value = parseInt(this.value);
                        clipTransposeValue.textContent = value + ' st';
                        const state = window.editorStates?.waveform;
                        if (state) {
                            state.clipProperties.transpose = value;
                            state.saveState();
                            if (window.updateWaveformCanvas) window.updateWaveformCanvas();
                            sendToMax('set_clip_transpose', value);
                        }
                    });
                }
                
                if (clipColor) {
                    clipColor.addEventListener('change', function() {
                        const state = window.editorStates?.waveform;
                        if (state) {
                            state.clipProperties.color = this.value;
                            state.saveState();
                            if (window.updateWaveformCanvas) window.updateWaveformCanvas();
                            sendToMax('set_clip_color', this.value);
                        }
                    });
                }
            }
            
            // Piano Roll Controls
            function initPianoRollControls() {
                const gridDisplay = document.getElementById('grid-display');
                const noteNames = document.getElementById('note-names');
                const scaleHighlight = document.getElementById('scale-highlight');
                const scaleSelector = document.getElementById('scale-selector');
                const foldOctaves = document.getElementById('fold-octaves');
                
                if (gridDisplay) {
                    gridDisplay.addEventListener('change', function() {
                        const state = window.editorStates?.['piano-roll'];
                        if (state) {
                            state.pianoRollSettings.showGrid = this.checked;
                            state.saveState();
                            if (window.updatePianoRollCanvas) window.updatePianoRollCanvas();
                        }
                    });
                }
                
                if (noteNames) {
                    noteNames.addEventListener('change', function() {
                        const state = window.editorStates?.['piano-roll'];
                        if (state) {
                            state.pianoRollSettings.showNoteNames = this.checked;
                            state.saveState();
                            if (window.updatePianoRollCanvas) window.updatePianoRollCanvas();
                        }
                    });
                }
                
                if (scaleHighlight) {
                    scaleHighlight.addEventListener('change', function() {
                        const state = window.editorStates?.['piano-roll'];
                        if (state) {
                            state.pianoRollSettings.scaleHighlight = this.checked;
                            state.saveState();
                            if (window.updatePianoRollCanvas) window.updatePianoRollCanvas();
                        }
                    });
                }
                
                if (scaleSelector) {
                    scaleSelector.addEventListener('change', function() {
                        const state = window.editorStates?.['piano-roll'];
                        if (state) {
                            state.pianoRollSettings.scale = this.value;
                            state.saveState();
                            if (window.updatePianoRollCanvas) window.updatePianoRollCanvas();
                        }
                    });
                }
                
                if (foldOctaves) {
                    foldOctaves.addEventListener('change', function() {
                        const state = window.editorStates?.['piano-roll'];
                        if (state) {
                            state.pianoRollSettings.foldOctaves = this.checked;
                            state.saveState();
                            if (window.updatePianoRollCanvas) window.updatePianoRollCanvas();
                        }
                    });
                }
                
                initVelocityLane();
                initCCLanes();
            }
            
            function initVelocityLane() {
                const velocityCanvas = document.getElementById('velocity-canvas');
                if (!velocityCanvas) return;
                
                const ctx = velocityCanvas.getContext('2d');
                velocityCanvas.width = velocityCanvas.offsetWidth;
                velocityCanvas.height = velocityCanvas.offsetHeight;
                
                function drawVelocityLane() {
                    ctx.clearRect(0, 0, velocityCanvas.width, velocityCanvas.height);
                    const state = window.editorStates?.['piano-roll'];
                    if (!state || !state.data.notes) return;
                    
                    ctx.fillStyle = 'rgba(0, 212, 170, 0.6)';
                    state.data.notes.forEach(note => {
                        if (state.selection.items.includes(note)) {
                            const x = (note.start / (state.data.length || 1)) * velocityCanvas.width;
                            const width = (note.duration / (state.data.length || 1)) * velocityCanvas.width;
                            const height = (note.velocity / 127) * velocityCanvas.height;
                            ctx.fillRect(x, velocityCanvas.height - height, width, height);
                        }
                    });
                }
                
                const observer = new MutationObserver(drawVelocityLane);
                observer.observe(document.getElementById('piano-roll-canvas'), { attributes: true });
                drawVelocityLane();
            }
            
            function initCCLanes() {
                const ccLanes = document.getElementById('cc-lanes');
                if (!ccLanes) return;
                
                const ccLaneElements = ccLanes.querySelectorAll('.cc-lane');
                ccLaneElements.forEach(lane => {
                    const canvas = lane.querySelector('.cc-canvas');
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        canvas.width = canvas.offsetWidth;
                        canvas.height = canvas.offsetHeight;
                        
                        function drawCCLane() {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            const ccNum = parseInt(lane.dataset.cc);
                            const state = window.editorStates?.['piano-roll'];
                            if (!state || !state.data.ccData || !state.data.ccData[ccNum]) return;
                            
                            ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            
                            const ccData = state.data.ccData[ccNum];
                            ccData.forEach((point, i) => {
                                const x = (point.time / (state.data.length || 1)) * canvas.width;
                                const y = canvas.height - (point.value / 127) * canvas.height;
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            });
                            ctx.stroke();
                        }
                        
                        drawCCLane();
                    }
                });
            }
            
            // Timeline Controls
            function initTimelineControls() {
                const trackHeight = document.getElementById('track-height');
                const trackButtons = document.querySelectorAll('.track-btn-compact');
                const trackFaders = document.querySelectorAll('.track-volume');
                
                if (trackHeight) {
                    trackHeight.addEventListener('input', function() {
                        const height = parseInt(this.value);
                        const state = window.editorStates?.timeline;
                        if (state) {
                            state.timelineSettings.trackHeight = height;
                            state.saveState();
                            if (window.updateTimelineCanvas) window.updateTimelineCanvas();
                        }
                        document.querySelectorAll('.track-lane-compact').forEach(lane => {
                            lane.style.minHeight = height + 'px';
                        });
                    });
                }
                
                trackButtons.forEach(btn => {
                    btn.addEventListener('click', function() {
                        const action = this.dataset.action;
                        const trackIndex = parseInt(this.closest('.timeline-track')?.dataset.track || 0);
                        const isActive = this.classList.contains('active');
                        
                        this.classList.toggle('active');
                        
                        sendToMax(`track_${action}`, trackIndex, !isActive);
                        showNotification(`Track ${trackIndex + 1} ${action}: ${!isActive ? 'ON' : 'OFF'}`);
                    });
                });
                
                trackFaders.forEach(fader => {
                    fader.addEventListener('input', function() {
                        const trackIndex = parseInt(this.closest('.timeline-track')?.dataset.track || 0);
                        const value = parseInt(this.value);
                        sendToMax('set_track_volume', trackIndex, value / 100);
                    });
                });
            }
            
            // Preview Controls
            function initPreviewControls() {
                const previewPlay = document.getElementById('preview-play');
                const previewStop = document.getElementById('preview-stop');
                const previewLoop = document.getElementById('preview-loop');
                
                let isPlaying = false;
                let isLooping = false;
                
                if (previewPlay) {
                    previewPlay.addEventListener('click', function() {
                        if (!isPlaying) {
                            isPlaying = true;
                            this.classList.add('active');
                            previewStop?.classList.remove('active');
                            sendToMax('preview_play');
                            showNotification('Preview playing');
                        }
                    });
                }
                
                if (previewStop) {
                    previewStop.addEventListener('click', function() {
                        isPlaying = false;
                        previewPlay?.classList.remove('active');
                        this.classList.add('active');
                        sendToMax('preview_stop');
                        showNotification('Preview stopped');
                    });
                }
                
                if (previewLoop) {
                    previewLoop.addEventListener('change', function() {
                        isLooping = this.checked;
                        this.classList.toggle('active', isLooping);
                        sendToMax('preview_loop', isLooping);
                        showNotification(`Preview loop: ${isLooping ? 'ON' : 'OFF'}`);
                    });
                }
            }
            
            // Clip Properties
            function initClipProperties() {
                const launchMode = document.getElementById('launch-mode');
                const launchQuantization = document.getElementById('launch-quantization');
                const followAction = document.getElementById('follow-action');
                
                if (launchMode) {
                    launchMode.addEventListener('change', function() {
                        const state = window.editorStates?.waveform;
                        if (state) {
                            state.clipProperties.launch.mode = this.value;
                            state.saveState();
                            sendToMax('set_launch_mode', this.value);
                        }
                    });
                }
                
                if (launchQuantization) {
                    launchQuantization.addEventListener('change', function() {
                        const state = window.editorStates?.waveform;
                        if (state) {
                            state.clipProperties.launch.quantization = this.value;
                            state.saveState();
                            sendToMax('set_launch_quantization', this.value);
                        }
                    });
                }
                
                if (followAction) {
                    followAction.addEventListener('change', function() {
                        const state = window.editorStates?.waveform;
                        if (state) {
                            state.clipProperties.launch.followAction = this.value;
                            state.saveState();
                            sendToMax('set_follow_action', this.value);
                        }
                    });
                }
            }
            
            // Helper Functions
            function updateClipInfo() {
                const state = window.editorStates?.waveform;
                if (!state) return;
                
                const bpmEl = document.getElementById('clip-info-bpm');
                const keyEl = document.getElementById('clip-info-key');
                const lengthEl = document.getElementById('clip-info-length');
                
                if (bpmEl) bpmEl.textContent = state.clipProperties.bpm || 120;
                if (keyEl) keyEl.textContent = state.clipProperties.key || 'C';
                if (lengthEl) {
                    const bars = Math.round((state.data.length || 0) / 4);
                    lengthEl.textContent = bars + ' bars';
                }
            }
            
            function getScaleNotes(scale) {
                const scales = {
                    major: [0, 2, 4, 5, 7, 9, 11],
                    minor: [0, 2, 3, 5, 7, 8, 10],
                    dorian: [0, 2, 3, 5, 7, 9, 10],
                    mixolydian: [0, 2, 4, 5, 7, 9, 10]
                };
                const base = scales[scale] || scales.major;
                const notes = [];
                for (let octave = 0; octave < 8; octave++) {
                    base.forEach(offset => {
                        notes.push(octave * 12 + offset);
                    });
                }
                return notes;
            }
            
            function getNoteName(pitch) {
                const names = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                return names[pitch % 12] + Math.floor(pitch / 12);
            }
            
            function sendToMax(command, ...args) {
                if (window.maxComms || window.maxCommunication) {
                    const maxComms = window.maxComms || window.maxCommunication;
                    maxComms.sendCommand(command, args);
                } else {
                    console.log('Max command:', command, args);
                }
            }
            
            function showNotification(message, type = 'info') {
                if (window.showNotification) {
                    window.showNotification(message, type);
                } else {
                    console.log(`[${type}] ${message}`);
                }
            }
            
            // Initialize on DOM ready
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:6880',message:'DOM ready check',data:{readyState:document.readyState,libraryTabExists:!!document.querySelector('[data-main-tab="library"]')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
            // #endregion
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initAbletonWorkflowControls);
            } else {
                initAbletonWorkflowControls();
            }
            
            // #region agent log
            setTimeout(() => {
                const clipHeader = document.querySelector('.clip-header');
                const previewPanel = document.querySelector('.preview-controls-panel');
                const clipHeaderStyle = clipHeader ? window.getComputedStyle(clipHeader) : null;
                fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:6890',message:'Post-init visibility check',data:{clipHeaderExists:!!clipHeader,previewPanelExists:!!previewPanel,clipHeaderDisplay:clipHeaderStyle?.display,clipHeaderVisibility:clipHeaderStyle?.visibility,clipHeaderHeight:clipHeaderStyle?.height},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
            }, 1000);
            // #endregion
            
            // Expose functions globally
            window.initAbletonWorkflowControls = initAbletonWorkflowControls;
            window.getScaleNotes = getScaleNotes;
            window.getNoteName = getNoteName;
            window.updateClipInfo = updateClipInfo;
        })();
        
        // ============================================================================
        // Library Tab Media Management System
        // ============================================================================
        // NOTE: Inline implementations commented out - using imported modules instead
        /*
        // MediaLoader Class - Handle loading media into editors (COMMENTED OUT - using imported module)
        (function() {
            'use strict';
            
            class MediaLoader {
                constructor() {
                    this.currentMedia = null;
                    this.mediaHistory = [];
                    this.loadedMedia = new Map(); // Cache loaded media
                    this.mediaCache = new Map(); // Media data cache
                }
                
                async loadMediaIntoEditor(mediaId, editorType = 'auto') {
                    try {
                        const media = this.getMediaById(mediaId);
                        if (!media) {
                            console.error('[MediaLoader] Media not found:', mediaId);
                            return;
                        }
                        
                        // Determine editor type if auto
                        if (editorType === 'auto') {
                            editorType = media.type === 'audio' ? 'waveform' : 'piano-roll';
                        }
                        
                        // Update visual state
                        this.updateMediaItemState(mediaId, 'loading');
                        
                        // Load media data
                        const data = await this.fetchMediaData(media);
                        
                        // Update editor state
                        const state = window.editorStates[editorType];
                        if (state) {
                            if (editorType === 'waveform') {
                                state.data.waveform = data.samples || null;
                                state.data.length = data.duration || 0;
                                if (data.bpm) state.clipProperties.bpm = data.bpm;
                                if (data.key) state.clipProperties.key = data.key;
                                if (data.sampleRate) state.clipProperties.sampleRate = data.sampleRate;
                            } else if (editorType === 'piano-roll') {
                                state.data.notes = data.notes || [];
                                state.data.length = data.length || 4;
                            }
                            
                            // Update current media reference
                            state.currentMedia = {
                                id: media.id,
                                name: media.name,
                                path: media.path,
                                type: media.type,
                                metadata: data.metadata || {}
                            };
                            
                            // Update UI
                            if (window.updateWaveformCanvas) window.updateWaveformCanvas();
                            if (window.updatePianoRollCanvas) window.updatePianoRollCanvas();
                            if (window.updateTimelineCanvas) window.updateTimelineCanvas();
                            if (window.updateClipInfo) window.updateClipInfo();
                            
                            // Send to Max for Live
                            if (window.maxComms || window.maxCommunication) {
                                const maxComms = window.maxComms || window.maxCommunication;
                                try {
                                    maxComms.sendCommand('load_sample', editorType, media.path || media.name);
                                } catch (error) {
                                    console.error('[MediaLoader] Error sending to Max:', error);
                                }
                            } else {
                                console.log('[MediaLoader] Max command: load_sample', editorType, media.path || media.name);
                            }
                            
                            // Add to history
                            this.mediaHistory.push(mediaId);
                            this.currentMedia = mediaId;
                            
                            // Update visual state
                            this.updateMediaItemState(mediaId, 'loaded');
                            
                            // Remove loading state from all items
                            document.querySelectorAll('.browser-item').forEach(item => {
                                item.classList.remove('loading');
                            });
                            
                            console.log('[MediaLoader] Media loaded:', mediaId, editorType);
                        }
                    } catch (error) {
                        console.error('[MediaLoader] Error loading media:', error);
                        this.updateMediaItemState(mediaId, 'error');
                    }
                }
                
                async preloadMedia(mediaId) {
                    const media = this.getMediaById(mediaId);
                    if (!media) return;
                    
                    if (!this.mediaCache.has(mediaId)) {
                        const data = await this.fetchMediaData(media);
                        this.mediaCache.set(mediaId, data);
                    }
                }
                
                async fetchMediaData(media) {
                    // Check cache first
                    if (this.mediaCache.has(media.id)) {
                        return this.mediaCache.get(media.id);
                    }
                    
                    // Simulate fetching media data
                    // In real implementation, this would fetch from Max for Live or API
                    const data = {
                        samples: null, // Audio samples
                        notes: [], // MIDI notes
                        duration: media.duration || 4,
                        length: media.duration || 4,
                        bpm: media.bpm || 120,
                        key: media.key || 'C',
                        sampleRate: media.sampleRate || 44100,
                        metadata: {
                            bpm: media.bpm,
                            key: media.key,
                            genre: media.genre
                        }
                    };
                    
                    // Cache it
                    this.mediaCache.set(media.id, data);
                    return data;
                }
                
                getMediaById(mediaId) {
                    // Get media from DOM or media list
                    const item = document.querySelector(`[data-media-id="${mediaId}"]`);
                    if (!item) return null;
                    
                    return {
                        id: mediaId,
                        name: item.querySelector('.item-name')?.textContent || 'Unknown',
                        type: item.dataset.mediaType || 'audio',
                        path: item.dataset.mediaPath || null,
                        duration: this.parseDuration(item.querySelector('.item-time')?.textContent),
                        bpm: item.dataset.bpm ? parseInt(item.dataset.bpm) : null,
                        key: item.dataset.key || null
                    };
                }
                
                parseDuration(timeStr) {
                    // Parse "0:04" to seconds
                    if (!timeStr) return 0;
                    const parts = timeStr.split(':');
                    if (parts.length === 2) {
                        return parseInt(parts[0]) * 60 + parseInt(parts[1]);
                    }
                    return parseFloat(timeStr) || 0;
                }
                
                updateMediaItemState(mediaId, state) {
                    const item = document.querySelector(`[data-media-id="${mediaId}"]`);
                    if (!item) return;
                    
                    // Remove all state classes
                    item.classList.remove('selected', 'loaded', 'playing', 'loading', 'error');
                    
                    // Add new state
                    if (state) {
                        item.classList.add(state);
                    }
                }
                
                sendToMax(command, ...args) {
                    if (window.maxComms || window.maxCommunication) {
                        const maxComms = window.maxComms || window.maxCommunication;
                        maxComms.sendCommand(command, ...args);
                    } else {
                        console.log('[MediaLoader] Max command:', command, args);
                    }
                }
            }
            
            // Initialize MediaLoader
            window.mediaLoader = new MediaLoader();
        })();
        */
        
        // MediaItemInteraction Class - Handle click interactions (COMMENTED OUT - using imported module)
        /*
        (function() {
            'use strict';
            
            class MediaItemInteraction {
                constructor() {
                    this.clickTimeout = null;
                    this.selectedItem = null;
                    this.setupInteractions();
                }
                
                setupInteractions() {
                    // Use event delegation for media items
                    const mediaList = document.getElementById('media-list');
                    if (!mediaList) return;
                    
                    mediaList.addEventListener('click', (e) => {
                        const item = e.target.closest('.browser-item');
                        if (!item || e.target.closest('.item-actions')) return;
                        
                        const mediaId = item.dataset.mediaId;
                        if (!mediaId) return;
                        
                        let clickCount = 0;
                        
                        if (this.clickTimeout) {
                            clearTimeout(this.clickTimeout);
                            clickCount = 2; // Double click
                        } else {
                            clickCount = 1; // Single click
                            this.clickTimeout = setTimeout(() => {
                                // Single click: Select and preview
                                this.selectMedia(mediaId);
                                this.previewMedia(mediaId, 500);
                                this.clickTimeout = null;
                            }, 250);
                            return;
                        }
                        
                        // Double click: Load into editor
                        clearTimeout(this.clickTimeout);
                        this.clickTimeout = null;
                        this.loadMediaIntoEditor(mediaId);
                    });
                    
                    // Hover feedback
                    mediaList.addEventListener('mouseenter', (e) => {
                        const item = e.target.closest('.browser-item');
                        if (item) item.classList.add('hover');
                    }, true);
                    
                    mediaList.addEventListener('mouseleave', (e) => {
                        const item = e.target.closest('.browser-item');
                        if (item) item.classList.remove('hover');
                    }, true);
                }
                
                selectMedia(mediaId) {
                    // Remove previous selection
                    document.querySelectorAll('.browser-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    
                    // Add selection
                    const item = document.querySelector(`[data-media-id="${mediaId}"]`);
                    if (item) {
                        item.classList.add('selected');
                        this.selectedItem = mediaId;
                    }
                }
                
                async previewMedia(mediaId, duration = 500) {
                    const item = document.querySelector(`[data-media-id="${mediaId}"]`);
                    if (!item) return;
                    
                    item.classList.add('playing');
                    
                    // Simulate preview
                    setTimeout(() => {
                        item.classList.remove('playing');
                    }, duration);
                }
                
                async loadMediaIntoEditor(mediaId) {
                    if (window.mediaLoader) {
                        await window.mediaLoader.loadMediaIntoEditor(mediaId);
                        this.showFeedback('Media loaded', 'success');
                    }
                }
                
                showFeedback(message, type = 'info') {
                    // Use existing notification system
                    if (window.showNotification) {
                        window.showNotification(message, type);
                    } else {
                        console.log(`[${type}] ${message}`);
                    }
                }
            }
            
            // Initialize MediaItemInteraction
            window.mediaItemInteraction = new MediaItemInteraction();
        })();
        */
        
        // MediaKeyboardNavigation Class - Keyboard shortcuts for media navigation (COMMENTED OUT - using imported module)
        /*
        (function() {
            'use strict';
            
            class MediaKeyboardNavigation {
                constructor() {
                    this.currentIndex = -1;
                    this.mediaItems = [];
                    this.setupKeyboardNav();
                }
                
                setupKeyboardNav() {
                    document.addEventListener('keydown', (e) => {
                        // Only in Library tab
                        if (!document.querySelector('#tab-section-library.active')) return;
                        
                        // If search is focused, don't intercept
                        if (document.activeElement.tagName === 'INPUT' || 
                            document.activeElement.tagName === 'TEXTAREA') return;
                        
                        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                        const modKey = isMac ? e.metaKey : e.ctrlKey;
                        
                        switch(e.key) {
                            case 'ArrowDown':
                                e.preventDefault();
                                this.navigateNext();
                                break;
                            case 'ArrowUp':
                                e.preventDefault();
                                this.navigatePrevious();
                                break;
                            case 'Enter':
                                e.preventDefault();
                                this.loadSelected();
                                break;
                            case ' ':
                                e.preventDefault();
                                this.previewSelected();
                                break;
                            case 'ArrowLeft':
                                if (modKey) {
                                    e.preventDefault();
                                    this.loadPreviousMedia();
                                }
                                break;
                            case 'ArrowRight':
                                if (modKey) {
                                    e.preventDefault();
                                    this.loadNextMedia();
                                }
                                break;
                            case 'r':
                                if (modKey) {
                                    e.preventDefault();
                                    this.loadRandomMedia();
                                }
                                break;
                        }
                    });
                    
                    // Update media items list when Library tab is activated
                    document.addEventListener('click', () => {
                        if (document.querySelector('#tab-section-library.active')) {
                            this.updateMediaItemsList();
                        }
                    });
                }
                
                updateMediaItemsList() {
                    this.mediaItems = Array.from(document.querySelectorAll('.browser-item[data-media-id]'));
                }
                
                navigateNext() {
                    this.updateMediaItemsList();
                    if (this.mediaItems.length === 0) return;
                    
                    this.currentIndex = Math.min(this.currentIndex + 1, this.mediaItems.length - 1);
                    this.updateSelection();
                }
                
                navigatePrevious() {
                    this.updateMediaItemsList();
                    if (this.mediaItems.length === 0) return;
                    
                    this.currentIndex = Math.max(this.currentIndex - 1, 0);
                    this.updateSelection();
                }
                
                updateSelection() {
                    this.mediaItems.forEach((item, index) => {
                        item.classList.toggle('selected', index === this.currentIndex);
                    });
                    
                    // Scroll into view
                    if (this.mediaItems[this.currentIndex]) {
                        this.mediaItems[this.currentIndex].scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest'
                        });
                    }
                }
                
                loadSelected() {
                    if (this.currentIndex >= 0 && this.mediaItems[this.currentIndex]) {
                        const mediaId = this.mediaItems[this.currentIndex].dataset.mediaId;
                        if (mediaId && window.mediaLoader) {
                            window.mediaLoader.loadMediaIntoEditor(mediaId);
                        }
                    }
                }
                
                previewSelected() {
                    if (this.currentIndex >= 0 && this.mediaItems[this.currentIndex]) {
                        const mediaId = this.mediaItems[this.currentIndex].dataset.mediaId;
                        if (mediaId && window.mediaItemInteraction) {
                            window.mediaItemInteraction.previewMedia(mediaId, 500);
                        }
                    }
                }
                
                loadPreviousMedia() {
                    if (window.mediaLoader && window.mediaLoader.mediaHistory.length > 1) {
                        const history = window.mediaLoader.mediaHistory;
                        const currentIndex = history.indexOf(window.mediaLoader.currentMedia);
                        if (currentIndex > 0) {
                            const prevId = history[currentIndex - 1];
                            window.mediaLoader.loadMediaIntoEditor(prevId);
                        }
                    }
                }
                
                loadNextMedia() {
                    if (window.mediaLoader && window.mediaLoader.mediaHistory.length > 1) {
                        const history = window.mediaLoader.mediaHistory;
                        const currentIndex = history.indexOf(window.mediaLoader.currentMedia);
                        if (currentIndex < history.length - 1) {
                            const nextId = history[currentIndex + 1];
                            window.mediaLoader.loadMediaIntoEditor(nextId);
                        }
                    }
                }
                
                loadRandomMedia() {
                    this.updateMediaItemsList();
                    if (this.mediaItems.length === 0) return;
                    
                    const randomIndex = Math.floor(Math.random() * this.mediaItems.length);
                    const mediaId = this.mediaItems[randomIndex].dataset.mediaId;
                    if (mediaId && window.mediaLoader) {
                        window.mediaLoader.loadMediaIntoEditor(mediaId);
                    }
                }
            }
            
            // Initialize MediaKeyboardNavigation
            window.mediaKeyboardNavigation = new MediaKeyboardNavigation();
        })();
        */
        
        // MediaDragDrop Class - Enable drag-and-drop from browser to editors
        (function() {
            'use strict';
            
            class MediaDragDrop {
                constructor() {
                    this.setupDragDrop();
                }
                
                setupDragDrop() {
                    // Make media items draggable
                    document.addEventListener('dragstart', (e) => {
                        const item = e.target.closest('.browser-item[data-media-id]');
                        if (item) {
                            const mediaId = item.dataset.mediaId;
                            e.dataTransfer.setData('media-id', mediaId);
                            e.dataTransfer.effectAllowed = 'copy';
                            
                            // Visual feedback
                            item.classList.add('dragging');
                            
                            // Create drag image
                            const dragImage = item.cloneNode(true);
                            dragImage.style.opacity = '0.8';
                            dragImage.style.position = 'absolute';
                            dragImage.style.top = '-1000px';
                            document.body.appendChild(dragImage);
                            e.dataTransfer.setDragImage(dragImage, 0, 0);
                            setTimeout(() => document.body.removeChild(dragImage), 0);
                        }
                    });
                    
                    document.addEventListener('dragend', (e) => {
                        document.querySelectorAll('.browser-item').forEach(item => {
                            item.classList.remove('dragging');
                        });
                        document.querySelectorAll('.editor-content').forEach(editor => {
                            editor.classList.remove('drop-zone-active');
                        });
                    });
                    
                    // Make editors drop zones
                    document.querySelectorAll('.editor-content').forEach(editor => {
                        editor.addEventListener('dragover', (e) => {
                            e.preventDefault();
                            e.dataTransfer.dropEffect = 'copy';
                            editor.classList.add('drop-zone-active');
                        });
                        
                        editor.addEventListener('dragleave', (e) => {
                            // Only remove if leaving the editor entirely
                            if (!editor.contains(e.relatedTarget)) {
                                editor.classList.remove('drop-zone-active');
                            }
                        });
                        
                        editor.addEventListener('drop', async (e) => {
                            e.preventDefault();
                            editor.classList.remove('drop-zone-active');
                            
                            const mediaId = e.dataTransfer.getData('media-id');
                            if (mediaId && window.mediaLoader) {
                                const editorType = editor.id.replace('editor-', '');
                                await window.mediaLoader.loadMediaIntoEditor(mediaId, editorType);
                            }
                        });
                    });
                }
            }
            
            // Initialize MediaDragDrop
            window.mediaDragDrop = new MediaDragDrop();
        })();
        
        // Setup Media Navigation UI
        (function() {
            'use strict';
            
            function updateMediaCounter() {
                const items = document.querySelectorAll('.browser-item[data-media-id]');
                const currentIndex = Array.from(items).findIndex(item => 
                    item.classList.contains('selected') || item.classList.contains('loaded')
                );
                
                const currentEl = document.getElementById('current-media-index');
                const totalEl = document.getElementById('total-media-count');
                
                if (currentEl) currentEl.textContent = currentIndex >= 0 ? (currentIndex + 1) : '-';
                if (totalEl) totalEl.textContent = items.length;
            }
            
            // Update counter when media list changes
            const observer = new MutationObserver(updateMediaCounter);
            const mediaList = document.getElementById('media-list');
            if (mediaList) {
                observer.observe(mediaList, { childList: true, subtree: true });
            }
            
            // Update counter on selection changes
            document.addEventListener('click', () => {
                setTimeout(updateMediaCounter, 100);
            });
            
            // Navigation buttons
            const prevBtn = document.getElementById('prev-media');
            const nextBtn = document.getElementById('next-media');
            const randomBtn = document.getElementById('random-media');
            
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (window.mediaKeyboardNavigation) {
                        window.mediaKeyboardNavigation.loadPreviousMedia();
                    }
                });
            }
            
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    if (window.mediaKeyboardNavigation) {
                        window.mediaKeyboardNavigation.loadNextMedia();
                    }
                });
            }
            
            if (randomBtn) {
                randomBtn.addEventListener('click', () => {
                    if (window.mediaKeyboardNavigation) {
                        window.mediaKeyboardNavigation.loadRandomMedia();
                    }
                });
            }
            
            // Initial update
            updateMediaCounter();
        })();
        
        // MediaBatchSelection Class - Multi-select and batch operations
        (function() {
            'use strict';
            
            class MediaBatchSelection {
                constructor() {
                    this.selectedIds = new Set();
                    this.lastSelectedIndex = -1;
                    this.setupBatchSelection();
                }
                
                setupBatchSelection() {
                    const mediaList = document.getElementById('media-list');
                    if (!mediaList) return;
                    
                    mediaList.addEventListener('click', (e) => {
                        const item = e.target.closest('.browser-item[data-media-id]');
                        if (!item) return;
                        
                        const mediaId = item.dataset.mediaId;
                        if (!mediaId) return;
                        
                        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                        const modKey = isMac ? e.metaKey : e.ctrlKey;
                        
                        if (modKey) {
                            // Multi-select
                            e.preventDefault();
                            e.stopPropagation();
                            this.toggleSelection(mediaId);
                        } else if (e.shiftKey) {
                            // Range select
                            e.preventDefault();
                            e.stopPropagation();
                            this.rangeSelect(mediaId);
                        } else {
                            // Single select
                            this.clearSelection();
                            this.select(mediaId);
                        }
                    });
                }
                
                toggleSelection(mediaId) {
                    if (this.selectedIds.has(mediaId)) {
                        this.deselect(mediaId);
                    } else {
                        this.select(mediaId);
                    }
                }
                
                select(mediaId) {
                    this.selectedIds.add(mediaId);
                    const item = document.querySelector(`[data-media-id="${mediaId}"]`);
                    if (item) {
                        item.classList.add('selected');
                        this.lastSelectedIndex = Array.from(document.querySelectorAll('.browser-item[data-media-id]')).indexOf(item);
                    }
                    this.updateBatchToolbar();
                }
                
                deselect(mediaId) {
                    this.selectedIds.delete(mediaId);
                    const item = document.querySelector(`[data-media-id="${mediaId}"]`);
                    if (item) item.classList.remove('selected');
                    this.updateBatchToolbar();
                }
                
                clearSelection() {
                    this.selectedIds.forEach(id => {
                        const item = document.querySelector(`[data-media-id="${id}"]`);
                        if (item) item.classList.remove('selected');
                    });
                    this.selectedIds.clear();
                    this.updateBatchToolbar();
                }
                
                rangeSelect(mediaId) {
                    const items = Array.from(document.querySelectorAll('.browser-item[data-media-id]'));
                    const targetIndex = items.findIndex(item => item.dataset.mediaId === mediaId);
                    
                    if (targetIndex === -1 || this.lastSelectedIndex === -1) {
                        this.select(mediaId);
                        return;
                    }
                    
                    const start = Math.min(this.lastSelectedIndex, targetIndex);
                    const end = Math.max(this.lastSelectedIndex, targetIndex);
                    
                    for (let i = start; i <= end; i++) {
                        const id = items[i].dataset.mediaId;
                        if (id) this.select(id);
                    }
                }
                
                async batchLoad() {
                    const ids = Array.from(this.selectedIds);
                    const total = ids.length;
                    let completed = 0;
                    
                    // Show progress
                    this.showBatchProgress('Loading', completed, total);
                    
                    for (const id of ids) {
                        if (window.mediaLoader) {
                            await window.mediaLoader.loadMediaIntoEditor(id);
                            completed++;
                            this.showBatchProgress('Loading', completed, total);
                        }
                    }
                    
                    this.hideBatchProgress();
                }
                
                batchAddToVariable(variableName) {
                    const mediaIds = Array.from(this.selectedIds);
                    if (window.variableSystem) {
                        window.variableSystem.createVariable(variableName, mediaIds);
                        this.showFeedback(`${mediaIds.length} items added to variable "${variableName}"`, 'success');
                    }
                }
                
                batchDelete() {
                    if (!confirm(`Delete ${this.selectedIds.size} selected items?`)) return;
                    
                    const ids = Array.from(this.selectedIds);
                    ids.forEach(id => {
                        const item = document.querySelector(`[data-media-id="${id}"]`);
                        if (item) {
                            item.remove();
                        }
                    });
                    
                    this.clearSelection();
                    this.showFeedback(`${ids.length} items deleted`, 'success');
                }
                
                showBatchProgress(operation, completed, total) {
                    let progressEl = document.getElementById('batch-progress');
                    if (!progressEl) {
                        progressEl = document.createElement('div');
                        progressEl.id = 'batch-progress';
                        progressEl.className = 'batch-progress';
                        document.body.appendChild(progressEl);
                    }
                    
                    const percent = Math.round((completed / total) * 100);
                    progressEl.textContent = `${operation}: ${completed}/${total} (${percent}%)`;
                    progressEl.style.display = 'block';
                }
                
                hideBatchProgress() {
                    const progressEl = document.getElementById('batch-progress');
                    if (progressEl) {
                        setTimeout(() => {
                            progressEl.style.display = 'none';
                        }, 1000);
                    }
                }
                
                showFeedback(message, type = 'info') {
                    if (window.showNotification) {
                        window.showNotification(message, type);
                    } else {
                        console.log(`[${type}] ${message}`);
                    }
                }
                
                updateBatchToolbar() {
                    const toolbar = document.getElementById('quick-action-toolbar');
                    if (toolbar) {
                        if (this.selectedIds.size > 0) {
                            toolbar.classList.add('visible');
                            toolbar.dataset.count = this.selectedIds.size;
                        } else {
                            toolbar.classList.remove('visible');
                        }
                    }
                }
            }
            
            // Initialize MediaBatchSelection
            window.mediaBatchSelection = new MediaBatchSelection();
            
            // Setup quick action toolbar buttons
            document.addEventListener('click', (e) => {
                const btn = e.target.closest('.quick-action-toolbar-btn');
                if (!btn) return;
                
                const action = btn.dataset.action;
                const batch = window.mediaBatchSelection;
                
                switch(action) {
                    case 'load':
                        batch.batchLoad();
                        break;
                    case 'preview':
                        batch.selectedIds.forEach(id => {
                            if (window.mediaItemInteraction) {
                                window.mediaItemInteraction.previewMedia(id, 500);
                            }
                        });
                        break;
                    case 'add-to-variable':
                        if (window.variableSystem) {
                            const name = prompt('Variable name:');
                            if (name) batch.batchAddToVariable(name);
                        }
                        break;
                    case 'duplicate':
                        // Batch duplicate
                        batch.selectedIds.forEach(id => {
                            // TODO: Implement duplicate logic
                            console.log('[Batch] Duplicating:', id);
                        });
                        break;
                    case 'clear':
                        batch.clearSelection();
                        break;
                    case 'delete':
                        batch.batchDelete();
                        break;
                }
            });
        })();
        
        // Add drop zone styles
        (function() {
            const style = document.createElement('style');
            style.textContent = `
                .editor-content.drop-zone-active {
                    border: 2px dashed var(--accent-cyan) !important;
                    background: rgba(0, 212, 170, 0.1) !important;
                }
            `;
            document.head.appendChild(style);
        })();
        
        // Ableton Native Hotkey System
        (function() {
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const modKey = isMac ? 'Meta' : 'Ctrl';
            
            class AbletonHotkeySystem {
                constructor() {
                    this.hotkeys = new Map();
                    this.contextHotkeys = new Map(); // Context-specific hotkeys
                    this.customMappings = new Map();
                    this.enabled = true;
                    this.init();
                }
                
                init() {
                    this.setupDefaultHotkeys();
                    this.loadCustomMappings();
                    this.attachEventListeners();
                }
                
                setupDefaultHotkeys() {
                    // Navigation
                    this.register('ArrowLeft', () => this.nudgeLeft());
                    this.register('ArrowRight', () => this.nudgeRight());
                    this.register('ArrowUp', () => this.nudgeUp());
                    this.register('ArrowDown', () => this.nudgeDown());
                    this.register('Home', () => this.goToStart());
                    this.register('End', () => this.goToEnd());
                    this.register('PageUp', () => this.pageUp());
                    this.register('PageDown', () => this.pageDown());
                    
                    // Transport
                    this.register('Space', (e) => {
                        e.preventDefault();
                        this.togglePlay();
                    });
                    this.register('Enter', (e) => {
                        e.preventDefault();
                        this.toggleRecord();
                    });
                    this.register('Tab', (e) => {
                        e.preventDefault();
                        this.backToArrangement();
                    });
                    this.register('.', () => this.stopAllClips());
                    this.register(',', () => this.playSelection());
                    
                    // Editing
                    this.register(`${modKey}+z`, (e) => {
                        e.preventDefault();
                        this.undo();
                    });
                    this.register(`${modKey}+Shift+Z`, (e) => {
                        e.preventDefault();
                        this.redo();
                    });
                    this.register('Delete', () => this.deleteSelection());
                    this.register('Backspace', () => this.deleteSelection());
                    
                    // Selection
                    this.register(`${modKey}+a`, (e) => {
                        e.preventDefault();
                        this.selectAll();
                    });
                    this.register(`${modKey}+d`, (e) => {
                        e.preventDefault();
                        this.duplicate();
                    });
                    this.register('Escape', () => this.deselect());
                    
                    // Quantize
                    this.register(`${modKey}+u`, (e) => {
                        e.preventDefault();
                        this.quantize();
                    });
                    this.register(`${modKey}+Shift+U`, (e) => {
                        e.preventDefault();
                        this.quantizeTriplets();
                    });
                    
                    // Zoom
                    this.register(`${modKey}+=`, (e) => {
                        e.preventDefault();
                        this.zoomIn();
                    });
                    this.register(`${modKey}+-`, (e) => {
                        e.preventDefault();
                        this.zoomOut();
                    });
                    this.register(`${modKey}+0`, (e) => {
                        e.preventDefault();
                        this.fitToWindow();
                    });
                    
                    // Clip Operations
                    this.register(`${modKey}+e`, (e) => {
                        e.preventDefault();
                        this.split();
                    });
                    this.register(`${modKey}+j`, (e) => {
                        e.preventDefault();
                        this.consolidate();
                    });
                    
                    // Context-specific hotkeys for editors
                    this.registerContext('waveform', `${modKey}+c`, (e) => {
                        e.preventDefault();
                        this.copy();
                    });
                    this.registerContext('waveform', `${modKey}+v`, (e) => {
                        e.preventDefault();
                        this.paste();
                    });
                    this.registerContext('waveform', `${modKey}+x`, (e) => {
                        e.preventDefault();
                        this.cut();
                    });
                    
                    this.registerContext('piano-roll', `${modKey}+c`, (e) => {
                        e.preventDefault();
                        this.copy();
                    });
                    this.registerContext('piano-roll', `${modKey}+v`, (e) => {
                        e.preventDefault();
                        this.paste();
                    });
                    this.registerContext('piano-roll', `${modKey}+x`, (e) => {
                        e.preventDefault();
                        this.cut();
                    });
                }
                
                register(key, handler, context = null) {
                    const keyStr = this.normalizeKey(key);
                    if (context) {
                        if (!this.contextHotkeys.has(context)) {
                            this.contextHotkeys.set(context, new Map());
                        }
                        this.contextHotkeys.get(context).set(keyStr, handler);
                    } else {
                        this.hotkeys.set(keyStr, handler);
                    }
                }
                
                registerContext(context, key, handler) {
                    this.register(key, handler, context);
                }
                
                normalizeKey(key) {
                    return key.toLowerCase().replace(/\s+/g, '');
                }
                
                attachEventListeners() {
                    document.addEventListener('keydown', (e) => {
                        if (!this.enabled) return;
                        if (this.isInputFocused(e.target)) {
                            // Allow some hotkeys in inputs
                            if (e.key === 'Escape' || (e.key === 'Enter' && (e.ctrlKey || e.metaKey))) {
                                // Allow these
                            } else {
                                return;
                            }
                        }
                        this.handleKeyDown(e);
                    });
                }
                
                isInputFocused(target) {
                    return target.tagName === 'INPUT' || 
                           target.tagName === 'TEXTAREA' || 
                           target.isContentEditable;
                }
                
                handleKeyDown(e) {
                    const keyStr = this.buildKeyString(e);
                    const context = this.getCurrentContext();
                    
                    // Check context-specific hotkeys first
                    if (context && this.contextHotkeys.has(context)) {
                        const contextMap = this.contextHotkeys.get(context);
                        if (contextMap.has(keyStr)) {
                            e.preventDefault();
                            contextMap.get(keyStr)(e);
                            this.showHotkeyFeedback(keyStr);
                            return;
                        }
                    }
                    
                    // Check global hotkeys
                    if (this.hotkeys.has(keyStr)) {
                        e.preventDefault();
                        this.hotkeys.get(keyStr)(e);
                        this.showHotkeyFeedback(keyStr);
                        return;
                    }
                    
                    // Check custom mappings
                    if (this.customMappings.has(keyStr)) {
                        e.preventDefault();
                        this.customMappings.get(keyStr)(e);
                        this.showHotkeyFeedback(keyStr);
                        return;
                    }
                }
                
                buildKeyString(e) {
                    const parts = [];
                    if (e.ctrlKey) parts.push('ctrl');
                    if (e.metaKey) parts.push('meta');
                    if (e.shiftKey) parts.push('shift');
                    if (e.altKey) parts.push('alt');
                    
                    let key = e.key.toLowerCase();
                    if (key === ' ') key = 'space';
                    if (key === '.') key = '.';
                    if (key === ',') key = ',';
                    if (key.length === 1) {
                        parts.push(key);
                    } else {
                        parts.push(key);
                    }
                    
                    return parts.join('+');
                }
                
                getCurrentContext() {
                    const activeEditor = document.querySelector('.editor-content.active');
                    if (!activeEditor) return null;
                    
                    if (activeEditor.id === 'editor-waveform') return 'waveform';
                    if (activeEditor.id === 'editor-piano-roll') return 'piano-roll';
                    if (activeEditor.id === 'editor-timeline') return 'timeline';
                    return null;
                }
                
                showHotkeyFeedback(keyStr) {
                    // Visual feedback for hotkey actions
                    const feedback = document.createElement('div');
                    feedback.className = 'hotkey-feedback';
                    feedback.textContent = keyStr;
                    feedback.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--bg-panel); border: 1px solid var(--accent-cyan); border-radius: 4px; padding: 8px 16px; color: var(--accent-cyan); font-size: 12px; z-index: 10003; pointer-events: none; opacity: 0; transition: opacity 0.2s;';
                    document.body.appendChild(feedback);
                    
                    setTimeout(() => {
                        feedback.style.opacity = '1';
                    }, 10);
                    
                    setTimeout(() => {
                        feedback.style.opacity = '0';
                        setTimeout(() => feedback.remove(), 200);
                    }, 800);
                }
                
                // Action implementations
                nudgeLeft() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        state.viewport.x = Math.max(0, state.viewport.x - 0.1);
                        updateEditorCanvas(state);
                    }
                }
                
                nudgeRight() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        state.viewport.x += 0.1;
                        updateEditorCanvas(state);
                    }
                }
                
                nudgeUp() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        state.viewport.y = Math.max(0, state.viewport.y - 0.1);
                        updateEditorCanvas(state);
                    }
                }
                
                nudgeDown() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        state.viewport.y += 0.1;
                        updateEditorCanvas(state);
                    }
                }
                
                goToStart() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        state.viewport.x = 0;
                        updateEditorCanvas(state);
                    }
                }
                
                goToEnd() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        // TODO: Calculate end position
                        updateEditorCanvas(state);
                    }
                }
                
                pageUp() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        state.viewport.y = Math.max(0, state.viewport.y - 1);
                        updateEditorCanvas(state);
                    }
                }
                
                pageDown() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        state.viewport.y += 1;
                        updateEditorCanvas(state);
                    }
                }
                
                togglePlay() {
                    if (window.maxCommunication && window.maxCommunication.isConnected()) {
                        window.maxCommunication.sendCommand('transport_play');
                    }
                    showNotification('Play/Stop');
                }
                
                toggleRecord() {
                    if (window.maxCommunication && window.maxCommunication.isConnected()) {
                        window.maxCommunication.sendCommand('transport_record');
                    }
                    showNotification('Record');
                }
                
                backToArrangement() {
                    // Arrange tab removed - function disabled
                    // Could switch to library or create tab instead if needed
                }
                
                stopAllClips() {
                    if (window.maxCommunication && window.maxCommunication.isConnected()) {
                        window.maxCommunication.sendCommand('stop_all_clips');
                    }
                    showNotification('Stop All Clips');
                }
                
                playSelection() {
                    // Play selected region
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state && state.hasSelection()) {
                        // TODO: Implement play selection
                        showNotification('Play Selection');
                    }
                }
                
                undo() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state && state.undo()) {
                        updateEditorCanvas(state);
                        showNotification('Undo');
                    }
                }
                
                redo() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state && state.redo()) {
                        updateEditorCanvas(state);
                        showNotification('Redo');
                    }
                }
                
                deleteSelection() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        handleDelete(state);
                    }
                }
                
                selectAll() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        handleSelectAll(state);
                    }
                }
                
                duplicate() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        handleDuplicate(state);
                    }
                }
                
                deselect() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        state.clearSelection();
                        updateEditorCanvas(state);
                    }
                }
                
                quantize() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state && state.editorType === 'piano-roll') {
                        handleQuantize(state, '1/16');
                    }
                }
                
                quantizeTriplets() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state && state.editorType === 'piano-roll') {
                        handleQuantize(state, 'triplet');
                    }
                }
                
                zoomIn() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        handleZoomIn(state);
                    }
                }
                
                zoomOut() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        handleZoomOut(state);
                    }
                }
                
                fitToWindow() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        handleFitAll(state);
                    }
                }
                
                split() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        handleSplit(state);
                    }
                }
                
                consolidate() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        handleConsolidate(state);
                    }
                }
                
                copy() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        handleCopy(state);
                    }
                }
                
                paste() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        handlePaste(state);
                    }
                }
                
                cut() {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        handleCut(state);
                    }
                }
                
                loadCustomMappings() {
                    try {
                        const stored = localStorage.getItem('sergik_hotkey_mappings');
                        if (stored) {
                            const mappings = JSON.parse(stored);
                            Object.entries(mappings).forEach(([key, handler]) => {
                                this.customMappings.set(key, new Function('e', handler));
                            });
                        }
                    } catch (e) {
                        console.warn('Failed to load custom hotkey mappings:', e);
                    }
                }
                
                saveCustomMappings() {
                    const mappings = {};
                    this.customMappings.forEach((handler, key) => {
                        mappings[key] = handler.toString();
                    });
                    localStorage.setItem('sergik_hotkey_mappings', JSON.stringify(mappings));
                }
                
                remap(oldKey, newKey) {
                    const handler = this.hotkeys.get(this.normalizeKey(oldKey));
                    if (handler) {
                        this.hotkeys.delete(this.normalizeKey(oldKey));
                        this.hotkeys.set(this.normalizeKey(newKey), handler);
                        this.saveCustomMappings();
                    }
                }
            }
            
            window.abletonHotkeys = new AbletonHotkeySystem();
        })();
        
        // Magic Mouse and Trackpad Gesture System
        (function() {
            class MagicMouseHandler {
                constructor() {
                    this.isMagicMouse = false;
                    this.swipeThreshold = 50;
                    this.swipeTimeout = 300;
                    this.lastSwipeTime = 0;
                    this.swipeStartX = 0;
                    this.swipeStartY = 0;
                    this.isSwiping = false;
                    this.momentum = { x: 0, y: 0 };
                    this.init();
                }
                
                init() {
                    this.detectDevice();
                    this.attachEventListeners();
                }
                
                detectDevice() {
                    // Detect Magic Mouse by checking for wheel events with momentum
                    // Magic Mouse typically has smooth scrolling
                    let wheelEventCount = 0;
                    let lastWheelTime = 0;
                    
                    document.addEventListener('wheel', (e) => {
                        const now = Date.now();
                        if (now - lastWheelTime < 50) {
                            wheelEventCount++;
                        } else {
                            wheelEventCount = 1;
                        }
                        lastWheelTime = now;
                        
                        // Magic Mouse typically generates many rapid wheel events
                        if (wheelEventCount > 3) {
                            this.isMagicMouse = true;
                        }
                    }, { passive: true });
                }
                
                attachEventListeners() {
                    // Wheel events for scrolling
                    document.addEventListener('wheel', (e) => {
                        this.handleWheel(e);
                    }, { passive: false });
                    
                    // Mouse move for swipe detection
                    document.addEventListener('mousemove', (e) => {
                        this.handleMouseMove(e);
                    });
                    
                    document.addEventListener('mousedown', (e) => {
                        this.handleMouseDown(e);
                    });
                    
                    document.addEventListener('mouseup', (e) => {
                        this.handleMouseUp(e);
                    });
                }
                
                handleWheel(e) {
                    const deltaX = e.deltaX;
                    const deltaY = e.deltaY;
                    const deltaZ = e.deltaZ || 0;
                    
                    // Horizontal scroll - timeline scrub
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        e.preventDefault();
                        this.scrubTimeline(deltaX);
                    }
                    // Vertical scroll - zoom
                    else if (Math.abs(deltaY) > 0) {
                        e.preventDefault();
                        if (e.ctrlKey || e.metaKey) {
                            // Zoom with modifier
                            this.zoom(deltaY);
                        } else {
                            // Pan/scroll
                            this.scroll(deltaY);
                        }
                    }
                    // Z-axis scroll (if supported)
                    if (deltaZ !== 0) {
                        this.zoom(deltaZ);
                    }
                }
                
                handleMouseDown(e) {
                    this.swipeStartX = e.clientX;
                    this.swipeStartY = e.clientY;
                    this.isSwiping = false;
                }
                
                handleMouseMove(e) {
                    if (this.swipeStartX === 0 && this.swipeStartY === 0) return;
                    
                    const deltaX = e.clientX - this.swipeStartX;
                    const deltaY = e.clientY - this.swipeStartY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    if (distance > this.swipeThreshold && !this.isSwiping) {
                        this.isSwiping = true;
                        this.detectSwipe(deltaX, deltaY);
                    }
                }
                
                handleMouseUp(e) {
                    if (this.isSwiping) {
                        const deltaX = e.clientX - this.swipeStartX;
                        const deltaY = e.clientY - this.swipeStartY;
                        this.finishSwipe(deltaX, deltaY);
                    }
                    this.swipeStartX = 0;
                    this.swipeStartY = 0;
                    this.isSwiping = false;
                }
                
                detectSwipe(deltaX, deltaY) {
                    const absX = Math.abs(deltaX);
                    const absY = Math.abs(deltaY);
                    
                    if (absX > absY) {
                        // Horizontal swipe
                        if (deltaX > 0) {
                            this.onSwipeRight();
                        } else {
                            this.onSwipeLeft();
                        }
                    } else {
                        // Vertical swipe
                        if (deltaY > 0) {
                            this.onSwipeDown();
                        } else {
                            this.onSwipeUp();
                        }
                    }
                }
                
                finishSwipe(deltaX, deltaY) {
                    // Handle momentum
                    this.momentum.x = deltaX * 0.1;
                    this.momentum.y = deltaY * 0.1;
                    
                    // Apply momentum scrolling
                    if (Math.abs(this.momentum.x) > 1 || Math.abs(this.momentum.y) > 1) {
                        this.applyMomentum();
                    }
                }
                
                applyMomentum() {
                    const apply = () => {
                        if (Math.abs(this.momentum.x) > 1) {
                            this.scrubTimeline(this.momentum.x);
                            this.momentum.x *= 0.9;
                            requestAnimationFrame(apply);
                        } else if (Math.abs(this.momentum.y) > 1) {
                            this.scroll(this.momentum.y);
                            this.momentum.y *= 0.9;
                            requestAnimationFrame(apply);
                        }
                    };
                    apply();
                }
                
                scrubTimeline(delta) {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        state.viewport.x += delta * 0.01;
                        updateEditorCanvas(state);
                    }
                }
                
                zoom(delta) {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        const zoomFactor = delta > 0 ? 1.1 : 0.9;
                        state.zoom.horizontal *= zoomFactor;
                        state.zoom.vertical *= zoomFactor;
                        updateEditorCanvas(state);
                    }
                }
                
                scroll(delta) {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        state.viewport.y += delta * 0.01;
                        updateEditorCanvas(state);
                    }
                }
                
                onSwipeLeft() {
                    // Timeline scrub backward
                    this.scrubTimeline(-100);
                }
                
                onSwipeRight() {
                    // Timeline scrub forward
                    this.scrubTimeline(100);
                }
                
                onSwipeUp() {
                    // Track navigation up
                    // TODO: Navigate to previous track
                }
                
                onSwipeDown() {
                    // Track navigation down
                    // TODO: Navigate to next track
                }
            }
            
            window.magicMouseHandler = new MagicMouseHandler();
        })();
        
        // Trackpad Gesture Handler
        (function() {
            class TrackpadGestureHandler {
                constructor() {
                    this.isTrackpad = false;
                    this.touches = new Map();
                    this.gestures = {
                        pinch: { distance: 0, center: { x: 0, y: 0 } },
                        rotate: { angle: 0, startAngle: 0 },
                        swipe: { start: { x: 0, y: 0 }, direction: null }
                    };
                    this.pinchThreshold = 10;
                    this.rotateThreshold = 5;
                    this.swipeThreshold = 30;
                    this.init();
                }
                
                init() {
                    this.detectTrackpad();
                    this.attachEventListeners();
                }
                
                detectTrackpad() {
                    // Detect trackpad by checking for multi-touch events
                    // or pointer events with multiple pointers
                    let touchCount = 0;
                    
                    document.addEventListener('touchstart', () => {
                        touchCount++;
                        if (touchCount >= 2) {
                            this.isTrackpad = true;
                        }
                    }, { passive: true });
                    
                    // Also check for pointer events
                    document.addEventListener('pointerdown', (e) => {
                        if (e.pointerType === 'touch' || e.pointerType === 'pen') {
                            this.isTrackpad = true;
                        }
                    }, { passive: true });
                }
                
                attachEventListeners() {
                    // Pointer Events API (preferred)
                    if (window.PointerEvent) {
                        document.addEventListener('pointerdown', (e) => this.handlePointerDown(e));
                        document.addEventListener('pointermove', (e) => this.handlePointerMove(e));
                        document.addEventListener('pointerup', (e) => this.handlePointerUp(e));
                        document.addEventListener('pointercancel', (e) => this.handlePointerUp(e));
                    }
                    
                    // Touch Events (fallback)
                    document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                    document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                    document.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                    document.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
                    
                    // Wheel events for trackpad scrolling
                    document.addEventListener('wheel', (e) => {
                        if (e.ctrlKey || e.metaKey) {
                            // Pinch zoom simulation
                            this.handlePinchZoom(e.deltaY);
                        }
                    }, { passive: false });
                }
                
                handlePointerDown(e) {
                    this.touches.set(e.pointerId, {
                        x: e.clientX,
                        y: e.clientY,
                        time: Date.now()
                    });
                    
                    if (this.touches.size === 1) {
                        // Single touch - prepare for tap
                        this.gestures.swipe.start = { x: e.clientX, y: e.clientY };
                    } else if (this.touches.size === 2) {
                        // Two touches - prepare for pinch/rotate
                        this.initPinchRotate();
                    }
                }
                
                handlePointerMove(e) {
                    if (!this.touches.has(e.pointerId)) return;
                    
                    const touch = this.touches.get(e.pointerId);
                    const deltaX = e.clientX - touch.x;
                    const deltaY = e.clientY - touch.y;
                    
                    touch.x = e.clientX;
                    touch.y = e.clientY;
                    
                    if (this.touches.size === 1) {
                        // Single touch move
                        this.handleSwipe(deltaX, deltaY);
                    } else if (this.touches.size === 2) {
                        // Two touch move
                        this.handlePinchRotate();
                    } else if (this.touches.size === 3) {
                        // Three touch move
                        this.handleThreeFingerSwipe(deltaX, deltaY);
                    }
                }
                
                handlePointerUp(e) {
                    const touch = this.touches.get(e.pointerId);
                    if (touch) {
                        const duration = Date.now() - touch.time;
                        const distance = Math.sqrt(
                            Math.pow(e.clientX - this.gestures.swipe.start.x, 2) +
                            Math.pow(e.clientY - this.gestures.swipe.start.y, 2)
                        );
                        
                        if (duration < 300 && distance < 10) {
                            // Tap
                            this.handleTap(e.clientX, e.clientY, e.detail || 1);
                        }
                    }
                    
                    this.touches.delete(e.pointerId);
                    
                    if (this.touches.size === 0) {
                        this.resetGestures();
                    }
                }
                
                handleTouchStart(e) {
                    e.preventDefault();
                    for (let i = 0; i < e.touches.length; i++) {
                        const touch = e.touches[i];
                        this.touches.set(touch.identifier, {
                            x: touch.clientX,
                            y: touch.clientY,
                            time: Date.now()
                        });
                    }
                    
                    if (e.touches.length === 1) {
                        this.gestures.swipe.start = {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY
                        };
                    } else if (e.touches.length === 2) {
                        this.initPinchRotate();
                    }
                }
                
                handleTouchMove(e) {
                    e.preventDefault();
                    if (e.touches.length === 1) {
                        const touch = e.touches[0];
                        const stored = this.touches.get(touch.identifier);
                        if (stored) {
                            const deltaX = touch.clientX - stored.x;
                            const deltaY = touch.clientY - stored.y;
                            this.handleSwipe(deltaX, deltaY);
                            stored.x = touch.clientX;
                            stored.y = touch.clientY;
                        }
                    } else if (e.touches.length === 2) {
                        this.handlePinchRotate();
                    } else if (e.touches.length === 3) {
                        const deltaX = e.touches[0].clientX - this.gestures.swipe.start.x;
                        const deltaY = e.touches[0].clientY - this.gestures.swipe.start.y;
                        this.handleThreeFingerSwipe(deltaX, deltaY);
                    }
                }
                
                handleTouchEnd(e) {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touch = e.changedTouches[i];
                        this.touches.delete(touch.identifier);
                    }
                    
                    if (this.touches.size === 0) {
                        this.resetGestures();
                    }
                }
                
                initPinchRotate() {
                    const touches = Array.from(this.touches.values());
                    if (touches.length >= 2) {
                        const dx = touches[1].x - touches[0].x;
                        const dy = touches[1].y - touches[0].y;
                        this.gestures.pinch.distance = Math.sqrt(dx * dx + dy * dy);
                        this.gestures.pinch.center = {
                            x: (touches[0].x + touches[1].x) / 2,
                            y: (touches[0].y + touches[1].y) / 2
                        };
                        this.gestures.rotate.startAngle = Math.atan2(dy, dx);
                    }
                }
                
                handlePinchRotate() {
                    const touches = Array.from(this.touches.values());
                    if (touches.length < 2) return;
                    
                    const dx = touches[1].x - touches[0].x;
                    const dy = touches[1].y - touches[0].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    
                    // Pinch zoom
                    const pinchDelta = distance - this.gestures.pinch.distance;
                    if (Math.abs(pinchDelta) > this.pinchThreshold) {
                        this.handlePinchZoom(pinchDelta);
                        this.gestures.pinch.distance = distance;
                    }
                    
                    // Rotate
                    const rotateDelta = angle - this.gestures.rotate.startAngle;
                    if (Math.abs(rotateDelta) > this.rotateThreshold) {
                        this.handleRotate(rotateDelta);
                        this.gestures.rotate.startAngle = angle;
                    }
                }
                
                handlePinchZoom(delta) {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        const zoomFactor = delta > 0 ? 1.05 : 0.95;
                        state.zoom.horizontal *= zoomFactor;
                        state.zoom.vertical *= zoomFactor;
                        updateEditorCanvas(state);
                        this.showGestureFeedback('Pinch Zoom');
                    }
                }
                
                handleRotate(delta) {
                    // Rotate view or adjust parameter
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        // TODO: Implement rotation
                        this.showGestureFeedback('Rotate');
                    }
                }
                
                handleSwipe(deltaX, deltaY) {
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    if (distance < this.swipeThreshold) return;
                    
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Horizontal swipe - pan
                        this.handlePan(deltaX, 0);
                    } else {
                        // Vertical swipe - scroll
                        this.handlePan(0, deltaY);
                    }
                }
                
                handleThreeFingerSwipe(deltaX, deltaY) {
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (deltaX > 0) {
                            // Swipe right - next tab
                            this.switchToNextTab();
                        } else {
                            // Swipe left - previous tab
                            this.switchToPreviousTab();
                        }
                    } else {
                        if (deltaY > 0) {
                            // Swipe down - show menu
                            this.showQuickMenu();
                        } else {
                            // Swipe up - hide menu
                            this.hideQuickMenu();
                        }
                    }
                }
                
                handlePan(deltaX, deltaY) {
                    const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                    if (state) {
                        state.viewport.x += deltaX * 0.01;
                        state.viewport.y += deltaY * 0.01;
                        updateEditorCanvas(state);
                    }
                }
                
                handleTap(x, y, count) {
                    if (count === 1) {
                        // Single tap - select
                        // Handled by existing click handlers
                    } else if (count === 2) {
                        // Double tap - zoom to fit
                        const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                        if (state) {
                            handleFitAll(state);
                        }
                    } else if (count === 3) {
                        // Triple tap - context menu
                        this.showContextMenu(x, y);
                    }
                }
                
                switchToNextTab() {
                    const tabs = Array.from(document.querySelectorAll('.main-tab-btn'));
                    const activeIndex = tabs.findIndex(t => t.classList.contains('active'));
                    const nextIndex = (activeIndex + 1) % tabs.length;
                    tabs[nextIndex]?.click();
                }
                
                switchToPreviousTab() {
                    const tabs = Array.from(document.querySelectorAll('.main-tab-btn'));
                    const activeIndex = tabs.findIndex(t => t.classList.contains('active'));
                    const prevIndex = (activeIndex - 1 + tabs.length) % tabs.length;
                    tabs[prevIndex]?.click();
                }
                
                showQuickMenu() {
                    // Show quick actions menu
                    // TODO: Implement quick menu
                }
                
                hideQuickMenu() {
                    // Hide quick actions menu
                    // TODO: Implement
                }
                
                showContextMenu(x, y) {
                    // Trigger context menu at position
                    const event = new MouseEvent('contextmenu', {
                        bubbles: true,
                        cancelable: true,
                        clientX: x,
                        clientY: y
                    });
                    document.elementFromPoint(x, y)?.dispatchEvent(event);
                }
                
                resetGestures() {
                    this.gestures.pinch.distance = 0;
                    this.gestures.rotate.angle = 0;
                    this.gestures.swipe.direction = null;
                }
                
                showGestureFeedback(message) {
                    // Visual feedback for gestures
                    const feedback = document.createElement('div');
                    feedback.className = 'gesture-feedback';
                    feedback.textContent = message;
                    feedback.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: var(--bg-panel); border: 1px solid var(--accent-cyan); border-radius: 4px; padding: 8px 16px; color: var(--accent-cyan); font-size: 12px; z-index: 10003; pointer-events: none; opacity: 0; transition: opacity 0.2s;';
                    document.body.appendChild(feedback);
                    
                    setTimeout(() => {
                        feedback.style.opacity = '1';
                    }, 10);
                    
                    setTimeout(() => {
                        feedback.style.opacity = '0';
                        setTimeout(() => feedback.remove(), 200);
                    }, 1000);
                }
            }
            
            window.trackpadGestureHandler = new TrackpadGestureHandler();
            
            // Gesture Settings
            class GestureSettings {
                constructor() {
                    this.settings = {
                        sensitivity: 1.0,
                        swipeThreshold: 50,
                        pinchThreshold: 10,
                        rotateThreshold: 5,
                        invertScroll: false,
                        enabledGestures: {
                            swipe: true,
                            pinch: true,
                            rotate: true,
                            tap: true
                        }
                    };
                    this.loadSettings();
                }
                
                loadSettings() {
                    try {
                        const stored = localStorage.getItem('sergik_gesture_settings');
                        if (stored) {
                            this.settings = { ...this.settings, ...JSON.parse(stored) };
                            this.applySettings();
                        }
                    } catch (e) {
                        console.warn('Failed to load gesture settings:', e);
                    }
                }
                
                saveSettings() {
                    localStorage.setItem('sergik_gesture_settings', JSON.stringify(this.settings));
                }
                
                applySettings() {
                    if (window.magicMouseHandler) {
                        window.magicMouseHandler.swipeThreshold = this.settings.swipeThreshold;
                    }
                    if (window.trackpadGestureHandler) {
                        window.trackpadGestureHandler.swipeThreshold = this.settings.swipeThreshold;
                        window.trackpadGestureHandler.pinchThreshold = this.settings.pinchThreshold;
                        window.trackpadGestureHandler.rotateThreshold = this.settings.rotateThreshold;
                    }
                }
                
                setSensitivity(value) {
                    this.settings.sensitivity = Math.max(0.1, Math.min(2.0, value));
                    this.saveSettings();
                    this.applySettings();
                }
                
                setSwipeThreshold(value) {
                    this.settings.swipeThreshold = Math.max(10, Math.min(200, value));
                    this.saveSettings();
                    this.applySettings();
                }
                
                setInvertScroll(invert) {
                    this.settings.invertScroll = invert;
                    this.saveSettings();
                }
                
                toggleGesture(gesture, enabled) {
                    if (this.settings.enabledGestures.hasOwnProperty(gesture)) {
                        this.settings.enabledGestures[gesture] = enabled;
                        this.saveSettings();
                    }
                }
            }
            
            window.gestureSettings = new GestureSettings();
        })();
        
        // Context Menu System
        (function() {
            let contextMenu = null;
            let currentContext = null;
            let focusedIndex = -1;
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            
            // Create context menu element
            function getContextMenu() {
                if (!contextMenu) {
                    contextMenu = document.getElementById('context-menu');
                }
                return contextMenu;
            }
            
            // Format shortcut for platform
            function formatShortcut(shortcut) {
                if (!shortcut) return '';
                if (isMac) {
                    return shortcut.replace(/Ctrl\+/g, 'Cmd+').replace(/Alt\+/g, 'Option+');
                }
                return shortcut;
            }
            
            // Create menu item HTML
            function createMenuItem(item) {
                const itemEl = document.createElement('div');
                itemEl.className = 'context-menu-item';
                if (item.disabled) itemEl.classList.add('disabled');
                if (item.submenu) itemEl.classList.add('has-submenu');
                if (item.action) itemEl.setAttribute('data-action', item.action);
                
                let html = '';
                if (item.icon) {
                    html += `<span class="menu-icon">${item.icon}</span>`;
                } else {
                    html += '<span class="menu-icon"></span>';
                }
                html += `<span class="menu-label">${item.label}</span>`;
                if (item.shortcut) {
                    html += `<span class="menu-shortcut">${formatShortcut(item.shortcut)}</span>`;
                }
                if (item.submenu) {
                    html += '<span class="menu-arrow"></span>';
                }
                
                itemEl.innerHTML = html;
                
                // Add submenu if exists
                if (item.submenu) {
                    const submenu = document.createElement('div');
                    submenu.className = 'context-submenu';
                    item.submenu.forEach(subItem => {
                        submenu.appendChild(createMenuItem(subItem));
                    });
                    itemEl.appendChild(submenu);
                }
                
                // Add click handler
                if (!item.disabled && item.action) {
                    itemEl.addEventListener('click', function(e) {
                        e.stopPropagation();
                        executeMenuAction(item.action, currentContext);
                        hideContextMenu();
                    });
                }
                
                return itemEl;
            }
            
            // Show context menu
            function showContextMenu(x, y, items) {
                const menu = getContextMenu();
                if (!menu) return;
                
                // Clear existing items
                menu.innerHTML = '';
                
                // Add menu items
                items.forEach(item => {
                    if (item === 'separator') {
                        const sep = document.createElement('div');
                        sep.className = 'context-menu-separator';
                        menu.appendChild(sep);
                    } else {
                        menu.appendChild(createMenuItem(item));
                    }
                });
                
                // Position menu
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const scrollX = window.scrollX || window.pageXOffset;
                const scrollY = window.scrollY || window.pageYOffset;
                
                let left = x + scrollX;
                let top = y + scrollY;
                
                // Adjust if would overflow viewport
                menu.style.left = left + 'px';
                menu.style.top = top + 'px';
                menu.classList.add('visible');
                
                // Adjust after rendering to get actual size
                setTimeout(() => {
                    const menuRect = menu.getBoundingClientRect();
                    const menuWidth = menuRect.width;
                    const menuHeight = menuRect.height;
                    
                    if (left + menuWidth > viewportWidth) {
                        left = viewportWidth - menuWidth - 10;
                    }
                    if (top + menuHeight > viewportHeight) {
                        top = viewportHeight - menuHeight - 10;
                    }
                    
                    menu.style.left = left + 'px';
                    menu.style.top = top + 'px';
                }, 0);
                
                focusedIndex = -1;
            }
            
            // Hide context menu
            function hideContextMenu() {
                const menu = getContextMenu();
                if (menu) {
                    menu.classList.remove('visible');
                    menu.innerHTML = '';
                }
                focusedIndex = -1;
                currentContext = null;
            }
            
            // Handle keyboard navigation
            function handleKeyboardNavigation(event) {
                const menu = getContextMenu();
                if (!menu || !menu.classList.contains('visible')) return;
                
                const items = menu.querySelectorAll('.context-menu-item:not(.disabled)');
                if (items.length === 0) return;
                
                switch(event.key) {
                    case 'ArrowDown':
                        event.preventDefault();
                        focusedIndex = (focusedIndex + 1) % items.length;
                        updateFocus(items);
                        break;
                    case 'ArrowUp':
                        event.preventDefault();
                        focusedIndex = (focusedIndex - 1 + items.length) % items.length;
                        updateFocus(items);
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        const focused = items[focusedIndex];
                        if (focused && focused.classList.contains('has-submenu')) {
                            const submenu = focused.querySelector('.context-submenu');
                            if (submenu) submenu.style.display = 'block';
                        }
                        break;
                    case 'Enter':
                        event.preventDefault();
                        if (focusedIndex >= 0 && focusedIndex < items.length) {
                            const item = items[focusedIndex];
                            if (!item || typeof item.getAttribute !== 'function') return;
                            const action = item.getAttribute('data-action');
                            if (action) {
                                executeMenuAction(action, currentContext);
                                hideContextMenu();
                            }
                        }
                        break;
                    case 'Escape':
                        event.preventDefault();
                        hideContextMenu();
                        break;
                }
            }
            
            function updateFocus(items) {
                items.forEach((item, index) => {
                    if (index === focusedIndex) {
                        item.classList.add('focused');
                    } else {
                        item.classList.remove('focused');
                    }
                });
            }
            
            // Get current editor state
            function getCurrentEditorState() {
                const activeEditor = document.querySelector('.editor-content.active');
                if (!activeEditor) return null;
                
                if (!window.editorStates) {
                    console.warn('[EditorState] editorStates not initialized');
                    return null;
                }
                
                if (activeEditor.id === 'editor-waveform') {
                    return window.editorStates.waveform;
                } else if (activeEditor.id === 'editor-piano-roll') {
                    return window.editorStates['piano-roll'];
                } else if (activeEditor.id === 'editor-timeline') {
                    return window.editorStates.timeline;
                }
                return null;
            }
            
            // Expose globally for toolbar buttons and other code
            window.getCurrentEditorState = getCurrentEditorState;
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/1a0fb566-a809-4ec8-acf1-755116941527',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'SERGIK_AI_Controller_Preview.html:11031',message:'getCurrentEditorState exposed',data:{exposed:typeof window.getCurrentEditorState === 'function',editorStatesExists:!!window.editorStates},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
            // #endregion
            
            // Validate selection
            function validateSelection(state, action) {
                if (!state) {
                    throw new Error('No active editor');
                }
                if (action !== 'select-all' && action !== 'paste' && !state.hasSelection()) {
                    throw new Error('No selection');
                }
                return true;
            }
            
            // Validate bounds
            function validateBounds(state, start, end) {
                if (state.editorType === 'waveform' && state.data.waveform) {
                    if (start < 0 || end > state.data.waveform.length || start >= end) {
                        throw new Error('Invalid selection bounds');
                    }
                }
                return true;
            }
            
            // Execute menu action
            function executeMenuAction(action, context) {
                const state = window.getCurrentEditorState ? window.getCurrentEditorState() : null;
                if (!state) {
                    console.warn('No active editor state');
                    showNotification('No active editor', 'error');
                    return;
                }
                
                try {
                    // Validate before action
                    if (action !== 'select-all' && action !== 'paste' && action !== 'zoom-in' && action !== 'zoom-out' && action !== 'fit-all') {
                        validateSelection(state, action);
                    }
                    
                    state.saveState();
                    
                    switch(action) {
                        case 'cut':
                            handleCut(state);
                            break;
                        case 'copy':
                            handleCopy(state);
                            break;
                        case 'paste':
                            handlePaste(state);
                            break;
                        case 'delete':
                            handleDelete(state);
                            break;
                        case 'duplicate':
                            handleDuplicate(state);
                            break;
                        case 'select-all':
                            handleSelectAll(state);
                            break;
                    case 'invert-selection':
                        handleInvertSelection(state);
                        break;
                    case 'reverse':
                        handleReverse(state);
                        break;
                    case 'fade-in':
                        // TODO: Implement fade in
                        break;
                    case 'fade-out':
                        // TODO: Implement fade out
                        break;
                    case 'normalize':
                        // TODO: Implement normalize
                        break;
                    case 'time-stretch':
                        // TODO: Implement time stretch
                        break;
                    case 'pitch-shift':
                        // TODO: Implement pitch shift
                        break;
                    case 'zoom-in':
                        // TODO: Implement zoom in
                        break;
                    case 'zoom-out':
                        // TODO: Implement zoom out
                        break;
                    case 'fit-selection':
                        // TODO: Implement fit selection
                        break;
                    case 'fit-all':
                        // TODO: Implement fit all
                        break;
                    // Quantize actions
                    case 'quantize-32':
                    case 'quantize-16':
                    case 'quantize-8':
                    case 'quantize-4':
                    case 'quantize-2':
                    case 'quantize-whole':
                    case 'quantize-triplet':
                    case 'quantize-swing':
                        // TODO: Implement quantize
                        break;
                    // Transpose actions
                    case 'transpose-up-1':
                    case 'transpose-up-12':
                    case 'transpose-down-1':
                    case 'transpose-down-12':
                        // TODO: Implement transpose
                        break;
                    // Velocity actions
                    case 'velocity-set':
                    case 'velocity-scale':
                    case 'velocity-random':
                        // TODO: Implement velocity
                        break;
                    // Time shift actions
                    case 'time-shift-left':
                    case 'time-shift-right':
                        // TODO: Implement time shift
                        break;
                    case 'make-legato':
                        // TODO: Implement make legato
                        break;
                    case 'remove-overlaps':
                        // TODO: Implement remove overlaps
                        break;
                    case 'split':
                        // TODO: Implement split
                        break;
                    case 'consolidate':
                        // TODO: Implement consolidate
                        break;
                    case 'loop':
                        // TODO: Implement loop
                        break;
                    case 'unloop':
                        // TODO: Implement unloop
                        break;
                    // Snap actions
                    case 'snap-grid':
                    case 'snap-zero':
                    case 'snap-off':
                    case 'snap-relative':
                        // TODO: Implement snap
                        break;
                    // Track actions
                    case 'track-mute':
                    case 'track-solo':
                    case 'track-arm':
                    case 'track-freeze':
                        // TODO: Implement track actions
                        break;
                    // Toolbar actions
                    case 'switch-waveform':
                        document.querySelector('[data-tool="waveform"]')?.click();
                        break;
                    case 'switch-piano':
                        document.querySelector('[data-tool="piano"]')?.click();
                        break;
                    case 'switch-timeline':
                        document.querySelector('[data-tool="timeline"]')?.click();
                        break;
                    default:
                        console.warn('Unknown action:', action);
                }
                } catch (error) {
                    console.error('Error executing action:', action, error);
                    showNotification('Error: ' + error.message, 'error');
                }
            }
            
            // Cut operation
            function handleCut(state) {
                if (!validateSelection(state, 'cut')) return;
                if (state.editorType === 'waveform') {
                    validateBounds(state, state.selection.start, state.selection.end);
                }
                
                // Copy to clipboard
                handleCopy(state);
                
                // Remove from editor
                if (state.editorType === 'waveform') {
                    const start = state.selection.start;
                    const end = state.selection.end;
                    if (state.data.waveform) {
                        state.data.waveform = [
                            ...state.data.waveform.slice(0, start),
                            ...state.data.waveform.slice(end)
                        ];
                    }
                } else if (state.editorType === 'piano-roll') {
                    const selectedSet = new Set(state.selection.items);
                    state.data.notes = state.data.notes.filter(note => !selectedSet.has(note));
                } else if (state.editorType === 'timeline') {
                    const selectedSet = new Set(state.selection.items);
                    state.data.clips = state.data.clips.filter(clip => !selectedSet.has(clip));
                }
                
                state.clearSelection();
                updateEditorCanvas(state);
                showNotification('Cut');
            }
            
            // Copy operation
            function handleCopy(state) {
                if (!state.hasSelection()) return;
                
                if (state.editorType === 'waveform') {
                    const start = state.selection.start;
                    const end = state.selection.end;
                    window.editorClipboard = {
                        type: 'waveform',
                        data: state.data.waveform ? state.data.waveform.slice(start, end) : null
                    };
                } else if (state.editorType === 'piano-roll') {
                    window.editorClipboard = {
                        type: 'notes',
                        data: state.selection.items.map(note => ({...note}))
                    };
                } else if (state.editorType === 'timeline') {
                    window.editorClipboard = {
                        type: 'clips',
                        data: state.selection.items.map(clip => ({...clip}))
                    };
                }
                
                showNotification('Copied to clipboard');
            }
            
            // Paste operation
            function handlePaste(state) {
                if (!window.editorClipboard.data) return;
                
                const clipboard = window.editorClipboard;
                const cursorPos = state.selection.start || 0;
                
                if (clipboard.type === 'waveform' && state.editorType === 'waveform') {
                    if (state.data.waveform) {
                        state.data.waveform = [
                            ...state.data.waveform.slice(0, cursorPos),
                            ...clipboard.data,
                            ...state.data.waveform.slice(cursorPos)
                        ];
                    } else {
                        state.data.waveform = [...clipboard.data];
                    }
                } else if (clipboard.type === 'notes' && state.editorType === 'piano-roll') {
                    const offset = cursorPos;
                    const pastedNotes = clipboard.data.map(note => ({
                        ...note,
                        start: note.start + offset
                    }));
                    state.data.notes = [...state.data.notes, ...pastedNotes].sort((a, b) => a.start - b.start);
                    state.selection.items = pastedNotes;
                } else if (clipboard.type === 'clips' && state.editorType === 'timeline') {
                    const offset = cursorPos;
                    const pastedClips = clipboard.data.map(clip => ({
                        ...clip,
                        start: clip.start + offset,
                        end: clip.end + offset
                    }));
                    state.data.clips = [...state.data.clips, ...pastedClips].sort((a, b) => a.start - b.start);
                    state.selection.items = pastedClips;
                } else if (clipboard.type === 'notes' && state.editorType === 'timeline') {
                    const offset = cursorPos;
                    const newClip = {
                        track: 0,
                        start: offset,
                        end: offset + Math.max(...clipboard.data.map(n => n.start + n.duration)),
                        loop: false,
                        notes: clipboard.data.map(note => ({
                            ...note,
                            start: note.start + offset
                        }))
                    };
                    state.data.clips.push(newClip);
                    state.selection.items = [newClip];
                }
                
                updateEditorCanvas(state);
                showNotification('Pasted');
            }
            
            // Delete operation
            function handleDelete(state) {
                if (!state.hasSelection()) return;
                
                if (state.editorType === 'waveform') {
                    const start = state.selection.start;
                    const end = state.selection.end;
                    if (state.data.waveform) {
                        state.data.waveform = [
                            ...state.data.waveform.slice(0, start),
                            ...state.data.waveform.slice(end)
                        ];
                    }
                } else if (state.editorType === 'piano-roll') {
                    const selectedSet = new Set(state.selection.items);
                    state.data.notes = state.data.notes.filter(note => !selectedSet.has(note));
                } else if (state.editorType === 'timeline') {
                    const selectedSet = new Set(state.selection.items);
                    state.data.clips = state.data.clips.filter(clip => !selectedSet.has(clip));
                }
                
                state.clearSelection();
                updateEditorCanvas(state);
                showNotification('Deleted');
            }
            
            // Duplicate operation
            function handleDuplicate(state) {
                if (!state.hasSelection()) return;
                
                if (state.editorType === 'waveform') {
                    const start = state.selection.start;
                    const end = state.selection.end;
                    const duplicated = state.data.waveform ? state.data.waveform.slice(start, end) : [];
                    if (state.data.waveform) {
                        state.data.waveform = [
                            ...state.data.waveform.slice(0, end),
                            ...duplicated,
                            ...state.data.waveform.slice(end)
                        ];
                    }
                    state.selection.start = end;
                    state.selection.end = end + duplicated.length;
                } else if (state.editorType === 'piano-roll') {
                    const maxStart = Math.max(...state.selection.items.map(n => n.start + n.duration));
                    const duplicated = state.selection.items.map(note => ({
                        ...note,
                        start: note.start + maxStart
                    }));
                    state.data.notes = [...state.data.notes, ...duplicated].sort((a, b) => a.start - b.start);
                    state.selection.items = duplicated;
                } else if (state.editorType === 'timeline') {
                    const maxEnd = Math.max(...state.selection.items.map(c => c.end));
                    const duplicated = state.selection.items.map(clip => ({
                        ...clip,
                        start: clip.start + (maxEnd - clip.start),
                        end: clip.end + (maxEnd - clip.start)
                    }));
                    state.data.clips = [...state.data.clips, ...duplicated].sort((a, b) => a.start - b.start);
                    state.selection.items = duplicated;
                }
                
                updateEditorCanvas(state);
                showNotification('Duplicated');
            }
            
            // Select All operation
            function handleSelectAll(state) {
                state.selectAll();
                updateEditorCanvas(state);
            }
            
            // Invert Selection operation
            function handleInvertSelection(state) {
                state.invertSelection();
                updateEditorCanvas(state);
            }
            
            // Show notification
            function showNotification(message, type = 'info') {
                let notification = document.getElementById('editor-notification');
                if (!notification) {
                    notification = document.createElement('div');
                    notification.id = 'editor-notification';
                    notification.style.cssText = 'position: fixed; top: 20px; right: 20px; padding: 12px 20px; background: var(--bg-panel); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px; z-index: 10002; box-shadow: 0 4px 12px rgba(0,0,0,0.5);';
                    document.body.appendChild(notification);
                }
                
                notification.textContent = message;
                notification.style.display = 'block';
                if (type === 'error') {
                    notification.style.borderColor = 'var(--accent-red)';
                } else {
                    notification.style.borderColor = 'var(--border-color)';
                }
                
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 2000);
            }
            
            // Update editor canvas (placeholder - will be fully implemented)
            function updateEditorCanvas(state) {
                if (state.editorType === 'waveform') {
                    updateWaveformCanvas();
                    updateWaveformInfoBar(state);
                } else if (state.editorType === 'piano-roll') {
                    updatePianoRollCanvas();
                    updatePianoRollInfoBar(state);
                } else if (state.editorType === 'timeline') {
                    updateTimelineCanvas();
                }
            }
            
            // Update info bars
            function updateWaveformInfoBar(state) {
                const lengthEl = document.getElementById('waveform-length');
                const selectionEl = document.getElementById('waveform-selection-time');
                if (lengthEl && state.data.waveform) {
                    const length = state.data.waveform.length;
                    lengthEl.textContent = formatTime(length);
                }
                if (selectionEl && state.hasSelection()) {
                    const duration = state.selection.end - state.selection.start;
                    selectionEl.textContent = formatTime(duration);
                }
            }
            
            function updatePianoRollInfoBar(state) {
                const velocityEl = document.getElementById('velocity-value');
                if (velocityEl && state.selection.items.length > 0) {
                    const avgVel = state.selection.items.reduce((sum, n) => sum + n.velocity, 0) / state.selection.items.length;
                    velocityEl.textContent = Math.round(avgVel);
                }
            }
            
            function formatTime(samples) {
                // Simplified time formatting
                const seconds = samples / 44100; // Assuming 44.1kHz
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Enhanced canvas update functions with Ableton-native features
            function updateWaveformCanvas() {
                const canvas = document.getElementById('waveform-canvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const state = window.editorStates?.waveform;
                if (!state) return;
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw waveform
                if (state.data.waveform) {
                    ctx.strokeStyle = state.clipProperties?.color || '#00d4aa';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    
                    const samples = state.data.waveform;
                    const step = canvas.width / samples.length;
                    
                    for (let i = 0; i < samples.length; i++) {
                        const x = i * step;
                        const y = (canvas.height / 2) + (samples[i] * canvas.height / 2);
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                } else {
                    // Placeholder line
                    ctx.strokeStyle = state.clipProperties?.color || '#00d4aa';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height / 2);
                    ctx.lineTo(canvas.width, canvas.height / 2);
                    ctx.stroke();
                }
                
                // Draw selection
                if (state.hasSelection()) {
                    ctx.fillStyle = 'rgba(0, 212, 170, 0.2)';
                    const startX = (state.selection.start / (state.data.length || 1)) * canvas.width;
                    const endX = (state.selection.end / (state.data.length || 1)) * canvas.width;
                    ctx.fillRect(startX, 0, endX - startX, canvas.height);
                }
                
                // Draw loop brace
                if (state.clipProperties?.loop?.enabled) {
                    const loopBrace = document.getElementById('loop-brace');
                    if (loopBrace) {
                        loopBrace.style.display = 'block';
                        const startX = (state.clipProperties.loop.start / (state.data.length || 1)) * canvas.width;
                        const endX = (state.clipProperties.loop.end / (state.data.length || 1)) * canvas.width;
                        loopBrace.style.left = startX + 'px';
                        loopBrace.style.width = (endX - startX) + 'px';
                    }
                } else {
                    const loopBrace = document.getElementById('loop-brace');
                    if (loopBrace) loopBrace.style.display = 'none';
                }
                
                // Draw warp markers
                if (state.clipProperties?.warp?.enabled && state.clipProperties.warp.markers.length > 0) {
                    ctx.fillStyle = '#ff6b35';
                    state.clipProperties.warp.markers.forEach(marker => {
                        const x = (marker.time / (state.data.length || 1)) * canvas.width;
                        ctx.fillRect(x - 2, 0, 4, canvas.height);
                    });
                }
                
                // Update info displays
                if (window.updateClipInfo) window.updateClipInfo();
                const bpmEl = document.getElementById('waveform-bpm');
                const srEl = document.getElementById('waveform-sr');
                if (bpmEl && state.clipProperties) bpmEl.textContent = state.clipProperties.bpm || 120;
                if (srEl && state.clipProperties) srEl.textContent = state.clipProperties.sampleRate || 44100;
            }
            
            function updatePianoRollCanvas() {
                const canvas = document.getElementById('piano-roll-canvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const state = window.editorStates?.['piano-roll'];
                if (!state) return;
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const settings = state.pianoRollSettings || {};
                const noteHeight = canvas.height / 88; // 88 keys
                
                // Draw grid
                if (settings.showGrid) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    const gridSize = state.snap.gridSize || 1/16;
                    const beats = state.data.length || 4;
                    const gridSteps = beats * (1 / gridSize);
                    
                    for (let i = 0; i <= gridSteps; i++) {
                        const x = (i / gridSteps) * canvas.width;
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    // Horizontal lines (octaves)
                    for (let i = 0; i <= 88; i += 12) {
                        const y = (i / 88) * canvas.height;
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                }
                
                // Draw scale highlight
                if (settings.scaleHighlight && window.getScaleNotes) {
                    const scaleNotes = window.getScaleNotes(settings.scale);
                    ctx.fillStyle = 'rgba(0, 212, 170, 0.1)';
                    scaleNotes.forEach(noteNum => {
                        const y = ((88 - noteNum) / 88) * canvas.height;
                        ctx.fillRect(0, y, canvas.width, noteHeight);
                    });
                }
                
                // Draw notes
                if (state.data.notes) {
                    state.data.notes.forEach(note => {
                        const isSelected = state.selection.items.includes(note);
                        const x = (note.start / (state.data.length || 1)) * canvas.width;
                        const width = (note.duration / (state.data.length || 1)) * canvas.width;
                        const y = ((88 - note.pitch) / 88) * canvas.height;
                        
                        // Note color based on velocity
                        const velocityAlpha = note.velocity / 127;
                        ctx.fillStyle = isSelected 
                            ? `rgba(255, 107, 53, ${velocityAlpha})` 
                            : `rgba(0, 212, 170, ${velocityAlpha})`;
                        ctx.fillRect(x, y, width, noteHeight);
                        
                        // Note border
                        ctx.strokeStyle = isSelected ? '#ff6b35' : '#00d4aa';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, width, noteHeight);
                        
                        // Note names
                        if (settings.showNoteNames && window.getNoteName) {
                            ctx.fillStyle = '#1a1a1a';
                            ctx.font = '8px JetBrains Mono';
                            ctx.fillText(window.getNoteName(note.pitch), x + 2, y + noteHeight - 2);
                        }
                    });
                }
                
                // Update velocity lane
                const velocityCanvas = document.getElementById('velocity-canvas');
                if (velocityCanvas) {
                    const vCtx = velocityCanvas.getContext('2d');
                    velocityCanvas.width = velocityCanvas.offsetWidth;
                    velocityCanvas.height = velocityCanvas.offsetHeight;
                    vCtx.clearRect(0, 0, velocityCanvas.width, velocityCanvas.height);
                    
                    if (state.data.notes) {
                        vCtx.fillStyle = 'rgba(0, 212, 170, 0.6)';
                        state.data.notes.forEach(note => {
                            if (state.selection.items.includes(note)) {
                                const x = (note.start / (state.data.length || 1)) * velocityCanvas.width;
                                const width = (note.duration / (state.data.length || 1)) * velocityCanvas.width;
                                const height = (note.velocity / 127) * velocityCanvas.height;
                                vCtx.fillRect(x, velocityCanvas.height - height, width, height);
                            }
                        });
                    }
                }
                
                // Update CC lanes
                const ccLanes = document.getElementById('cc-lanes');
                if (ccLanes) {
                    const ccLaneElements = ccLanes.querySelectorAll('.cc-lane');
                    ccLaneElements.forEach(lane => {
                        const ccCanvas = lane.querySelector('.cc-canvas');
                        if (ccCanvas) {
                            const ccCtx = ccCanvas.getContext('2d');
                            ccCanvas.width = ccCanvas.offsetWidth;
                            ccCanvas.height = ccCanvas.offsetHeight;
                            ccCtx.clearRect(0, 0, ccCanvas.width, ccCanvas.height);
                            
                            const ccNum = parseInt(lane.dataset.cc);
                            if (state.data.ccData && state.data.ccData[ccNum]) {
                                ccCtx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                                ccCtx.lineWidth = 2;
                                ccCtx.beginPath();
                                
                                const ccData = state.data.ccData[ccNum];
                                ccData.forEach((point, i) => {
                                    const x = (point.time / (state.data.length || 1)) * ccCanvas.width;
                                    const y = ccCanvas.height - (point.value / 127) * ccCanvas.height;
                                    if (i === 0) {
                                        ccCtx.moveTo(x, y);
                                    } else {
                                        ccCtx.lineTo(x, y);
                                    }
                                });
                                ccCtx.stroke();
                            }
                        }
                    });
                }
            }
            
            function updateTimelineCanvas() {
                const tracksContainer = document.getElementById('timeline-tracks');
                if (!tracksContainer) return;
                
                const state = window.editorStates?.timeline;
                if (!state) return;
                
                // Update track heights
                const trackHeight = state.timelineSettings?.trackHeight || 80;
                document.querySelectorAll('.track-lane-compact').forEach(lane => {
                    lane.style.minHeight = trackHeight + 'px';
                });
                
                // Render clips
                if (state.data.clips) {
                    state.data.clips.forEach(clip => {
                        const trackElement = tracksContainer.querySelector(`[data-track="${clip.track}"]`);
                        if (trackElement) {
                            const lane = trackElement.querySelector('.track-lane-compact');
                            if (lane) {
                                // Create or update clip element
                                let clipElement = lane.querySelector(`[data-clip-id="${clip.id}"]`);
                                if (!clipElement) {
                                    clipElement = document.createElement('div');
                                    clipElement.className = 'clip-region-compact';
                                    clipElement.dataset.clipId = clip.id;
                                    lane.appendChild(clipElement);
                                }
                                
                                clipElement.style.left = (clip.start * 10) + 'px';
                                clipElement.style.width = ((clip.end - clip.start) * 10) + 'px';
                                clipElement.style.background = clip.color || '#00d4aa';
                                clipElement.innerHTML = `<div class="clip-label-compact">${clip.name || 'Clip'}</div>`;
                            }
                        }
                    });
                }
                
                // Update track count
                const trackCountEl = document.getElementById('timeline-track-count');
                if (trackCountEl) {
                    trackCountEl.textContent = state.data.clips ? 
                        new Set(state.data.clips.map(c => c.track)).size : 0;
                }
                
                const clipCountEl = document.getElementById('timeline-clip-count');
                if (clipCountEl) {
                    clipCountEl.textContent = state.data.clips ? state.data.clips.length : 0;
                }
                
                // Render automation curves
                const automationLanes = tracksContainer.querySelectorAll('.automation-lane-compact');
                automationLanes.forEach(lane => {
                    const canvas = lane.querySelector('.automation-canvas-compact');
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        canvas.width = canvas.offsetWidth;
                        canvas.height = canvas.offsetHeight;
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        const param = lane.dataset.param;
                        if (state.data.automation && state.data.automation[param]) {
                            ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            
                            const automationData = state.data.automation[param];
                            automationData.forEach((point, i) => {
                                const x = (point.time / (state.data.length || 1)) * canvas.width;
                                const y = canvas.height - (point.value * canvas.height);
                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            });
                            ctx.stroke();
                        }
                    }
                });
            }
            
            // Get editor type from element
            function getEditorType(element) {
                if (element.id === 'waveform-canvas' || element.closest('#editor-waveform')) {
                    return 'waveform';
                }
                if (element.id === 'piano-roll-canvas' || element.closest('#editor-piano-roll')) {
                    return 'piano-roll';
                }
                if (element.id === 'timeline-ruler' || element.closest('#editor-timeline') || element.closest('.timeline-compact')) {
                    return 'timeline';
                }
                if (element.classList.contains('toolbar-btn')) {
                    return 'toolbar';
                }
                return 'unknown';
            }
            
            // Build menu items based on context
            function buildMenuItems(context) {
                switch(context.editor) {
                    case 'waveform':
                        return buildWaveformMenu(context);
                    case 'piano-roll':
                        return buildPianoRollMenu(context);
                    case 'timeline':
                        return buildTimelineMenu(context);
                    case 'toolbar':
                        return buildToolbarMenu(context);
                    default:
                        return [];
                }
            }
            
            // Build waveform editor menu
            function buildWaveformMenu(context) {
                return [
                    { label: 'Cut', icon: '', action: 'cut', shortcut: 'Ctrl+X' },
                    { label: 'Copy', icon: '', action: 'copy', shortcut: 'Ctrl+C' },
                    { label: 'Paste', icon: '', action: 'paste', shortcut: 'Ctrl+V' },
                    'separator',
                    { label: 'Delete', icon: '', action: 'delete', shortcut: 'Del' },
                    { label: 'Duplicate', icon: '', action: 'duplicate', shortcut: 'Ctrl+D' },
                    { label: 'Select All', icon: '', action: 'select-all', shortcut: 'Ctrl+A' },
                    'separator',
                    { label: 'Reverse', icon: '', action: 'reverse', disabled: !hasSel },
                    { label: 'Fade In', icon: '', action: 'fade-in', disabled: !hasSel },
                    { label: 'Fade Out', icon: '', action: 'fade-out', disabled: !hasSel },
                    { label: 'Normalize', icon: '', action: 'normalize', disabled: !hasSel },
                    { label: 'Time Stretch', icon: '', action: 'time-stretch', disabled: !hasSel },
                    { label: 'Pitch Shift', icon: '', action: 'pitch-shift', disabled: !hasSel },
                    'separator',
                    { 
                        label: 'Snap', icon: '', submenu: [
                            { label: 'Snap to Grid', action: 'snap-grid' },
                            { label: 'Snap to Zero Crossing', action: 'snap-zero' },
                            { label: 'Snap Off', action: 'snap-off' }
                        ]
                    },
                    'separator',
                    { label: 'Zoom In', icon: '+', action: 'zoom-in', shortcut: 'Ctrl+=' },
                    { label: 'Zoom Out', icon: '-', action: 'zoom-out', shortcut: 'Ctrl+-' },
                    { label: 'Fit Selection', icon: '', action: 'fit-selection', disabled: !hasSel },
                    { label: 'Fit All', icon: '', action: 'fit-all' },
                    'separator',
                    { label: 'Export Selection', icon: '', action: 'export-selection', disabled: !hasSel },
                    { label: 'Export as New File', icon: '', action: 'export-new' }
                ];
            }
            
            // Build piano roll editor menu
            function buildPianoRollMenu(context) {
                const hasSel = hasSelection(context);
                return [
                    { label: 'Cut', icon: '', action: 'cut', shortcut: 'Ctrl+X', disabled: !hasSel },
                    { label: 'Copy', icon: '', action: 'copy', shortcut: 'Ctrl+C', disabled: !hasSel },
                    { label: 'Paste', icon: '', action: 'paste', shortcut: 'Ctrl+V' },
                    'separator',
                    { label: 'Delete', icon: '', action: 'delete', shortcut: 'Del', disabled: !hasSel },
                    { label: 'Duplicate', icon: '', action: 'duplicate', shortcut: 'Ctrl+D', disabled: !hasSel },
                    { label: 'Select All', icon: '', action: 'select-all', shortcut: 'Ctrl+A' },
                    { label: 'Invert Selection', icon: '', action: 'invert-selection', disabled: !hasSel },
                    'separator',
                    {
                        label: 'Quantize', icon: '', disabled: !hasSel, submenu: [
                            { label: '1/32', action: 'quantize-32', disabled: !hasSel },
                            { label: '1/16', action: 'quantize-16', disabled: !hasSel },
                            { label: '1/8', action: 'quantize-8', disabled: !hasSel },
                            { label: '1/4', action: 'quantize-4', disabled: !hasSel },
                            { label: '1/2', action: 'quantize-2', disabled: !hasSel },
                            { label: 'Whole Note', action: 'quantize-whole', disabled: !hasSel },
                            'separator',
                            { label: 'Triplet', action: 'quantize-triplet', disabled: !hasSel },
                            { label: 'Swing', action: 'quantize-swing', disabled: !hasSel }
                        ]
                    },
                    'separator',
                    {
                        label: 'Transpose', icon: '', disabled: !hasSel, submenu: [
                            {
                                label: 'Up', disabled: !hasSel, submenu: [
                                    { label: 'Semitone', action: 'transpose-up-1', disabled: !hasSel },
                                    { label: 'Octave', action: 'transpose-up-12', disabled: !hasSel }
                                ]
                            },
                            {
                                label: 'Down', disabled: !hasSel, submenu: [
                                    { label: 'Semitone', action: 'transpose-down-1', disabled: !hasSel },
                                    { label: 'Octave', action: 'transpose-down-12', disabled: !hasSel }
                                ]
                            }
                        ]
                    },
                    {
                        label: 'Velocity', icon: '', disabled: !hasSel, submenu: [
                            { label: 'Set...', action: 'velocity-set', disabled: !hasSel },
                            { label: 'Scale...', action: 'velocity-scale', disabled: !hasSel },
                            { label: 'Randomize', action: 'velocity-random', disabled: !hasSel }
                        ]
                    },
                    {
                        label: 'Time Shift', icon: '', disabled: !hasSel, submenu: [
                            { label: 'Left', action: 'time-shift-left', disabled: !hasSel },
                            { label: 'Right', action: 'time-shift-right', disabled: !hasSel }
                        ]
                    },
                    'separator',
                    { label: 'Make Legato', icon: '', action: 'make-legato', disabled: !hasSel },
                    { label: 'Remove Overlaps', icon: '', action: 'remove-overlaps', disabled: !hasSel },
                    'separator',
                    { label: 'Zoom In', icon: '+', action: 'zoom-in', shortcut: 'Ctrl+=' },
                    { label: 'Zoom Out', icon: '-', action: 'zoom-out', shortcut: 'Ctrl+-' },
                    { label: 'Fit Selection', icon: '', action: 'fit-selection', disabled: !hasSel },
                    { label: 'Fit All', icon: '', action: 'fit-all' },
                    { label: 'Show Velocity', icon: '', action: 'show-velocity' },
                    { label: 'Show Release', icon: '', action: 'show-release' }
                ];
            }
            
            // Build timeline editor menu
            function buildTimelineMenu(context) {
                const hasSel = hasSelection(context);
                return [
                    { label: 'Cut', icon: '', action: 'cut', shortcut: 'Ctrl+X', disabled: !hasSel },
                    { label: 'Copy', icon: '', action: 'copy', shortcut: 'Ctrl+C', disabled: !hasSel },
                    { label: 'Paste', icon: '', action: 'paste', shortcut: 'Ctrl+V' },
                    'separator',
                    { label: 'Delete', icon: '', action: 'delete', shortcut: 'Del', disabled: !hasSel },
                    { label: 'Duplicate', icon: '', action: 'duplicate', shortcut: 'Ctrl+D', disabled: !hasSel },
                    { label: 'Split', icon: '', action: 'split', shortcut: 'Ctrl+E', disabled: !hasSel },
                    { label: 'Consolidate', icon: '', action: 'consolidate', shortcut: 'Ctrl+J', disabled: !hasSel },
                    'separator',
                    { label: 'Time Stretch', icon: '', action: 'time-stretch', disabled: !hasSel },
                    { label: 'Loop', icon: '', action: 'loop', disabled: !hasSel },
                    { label: 'Unloop', icon: '', action: 'unloop', disabled: !hasSel },
                    { label: 'Reverse', icon: '', action: 'reverse', disabled: !hasSel },
                    'separator',
                    {
                        label: 'Snap', icon: '', submenu: [
                            { label: 'Snap to Grid', action: 'snap-grid' },
                            { label: 'Snap Off', action: 'snap-off' },
                            { label: 'Snap Relative', action: 'snap-relative' }
                        ]
                    },
                    'separator',
                    { label: 'Zoom In', icon: '+', action: 'zoom-in', shortcut: 'Ctrl+=' },
                    { label: 'Zoom Out', icon: '-', action: 'zoom-out', shortcut: 'Ctrl+-' },
                    { label: 'Fit Selection', icon: '', action: 'fit-selection', disabled: !hasSel },
                    { label: 'Fit All', icon: '', action: 'fit-all' },
                    'separator',
                    {
                        label: 'Track', icon: '', submenu: [
                            { label: 'Mute', action: 'track-mute' },
                            { label: 'Solo', action: 'track-solo' },
                            { label: 'Arm', action: 'track-arm' },
                            { label: 'Freeze', action: 'track-freeze' }
                        ]
                    }
                ];
            }
            
            // Build toolbar button menu
            function buildToolbarMenu(context) {
                if (!context || !context.element || typeof context.element.getAttribute !== 'function') {
                    return [];
                }
                const tool = context.element.getAttribute('data-tool');
                
                switch(tool) {
                    case 'select':
                        return [
                            { label: 'Select All', icon: '', action: 'select-all', shortcut: 'Ctrl+A' },
                            { label: 'Invert Selection', icon: '', action: 'invert-selection' },
                            { label: 'Select by Region', icon: '', action: 'select-region' }
                        ];
                    case 'cut':
                        return [
                            { label: 'Cut at Cursor', icon: '', action: 'cut-cursor', shortcut: 'Ctrl+X' },
                            { label: 'Cut Selection', icon: '', action: 'cut-selection' },
                            { label: 'Cut Loop', icon: '', action: 'cut-loop' }
                        ];
                    case 'fade':
                        return [
                            { label: 'Fade In', icon: '', action: 'fade-in' },
                            { label: 'Fade Out', icon: '', action: 'fade-out' },
                            { label: 'Crossfade', icon: '', action: 'crossfade' },
                            { label: 'Remove Fades', icon: '', action: 'remove-fades' }
                        ];
                    case 'waveform':
                        return [
                            { label: 'Switch to Waveform', icon: 'W', action: 'switch-waveform' },
                            { label: 'Waveform Settings', icon: '', action: 'waveform-settings' }
                        ];
                    case 'piano':
                        return [
                            { label: 'Switch to Piano Roll', icon: 'P', action: 'switch-piano' },
                            { label: 'Piano Roll Settings', icon: '', action: 'piano-settings' }
                        ];
                    case 'timeline':
                        return [
                            { label: 'Switch to Timeline', icon: 'T', action: 'switch-timeline' },
                            { label: 'Timeline Settings', icon: '', action: 'timeline-settings' }
                        ];
                    default:
                        return [];
                }
            }
            
            // Initialize context menu system
            function initContextMenuSystem() {
                // Hide menu on click outside
                document.addEventListener('click', function(e) {
                    if (!e.target.closest('.context-menu')) {
                        hideContextMenu();
                    }
                });
                
                // Handle keyboard navigation
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape') {
                        hideContextMenu();
                    } else {
                        handleKeyboardNavigation(e);
                    }
                });
                
                // Attach context menu to editor elements
                function attachContextMenu(element) {
                    element.addEventListener('contextmenu', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        currentContext = {
                            element: element,
                            x: e.clientX,
                            y: e.clientY,
                            editor: getEditorType(element)
                        };
                        
                        const menuItems = buildMenuItems(currentContext);
                        if (menuItems.length > 0) {
                            showContextMenu(e.clientX, e.clientY, menuItems);
                        }
                    });
                }
                
                // Attach to editor canvases and containers
                const editorSelectors = [
                    '#waveform-canvas',
                    '#piano-roll-canvas',
                    '#timeline-ruler',
                    '.timeline-compact',
                    '.waveform-compact',
                    '.piano-roll-compact',
                    '.editor-content',
                    '.toolbar-btn'
                ];
                
                editorSelectors.forEach(selector => {
                    document.querySelectorAll(selector).forEach(el => {
                        attachContextMenu(el);
                    });
                });
                
                // Also attach to dynamically created elements
                const observer = new MutationObserver(function(mutations) {
                    mutations.forEach(function(mutation) {
                        mutation.addedNodes.forEach(function(node) {
                            if (node.nodeType === 1) {
                                editorSelectors.forEach(selector => {
                                    if (node.matches && node.matches(selector)) {
                                        attachContextMenu(node);
                                    }
                                    if (node.querySelectorAll) {
                                        node.querySelectorAll(selector).forEach(el => {
                                            attachContextMenu(el);
                                        });
                                    }
                                });
                            }
                        });
                    });
                });
                
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            }
            
            // Initialize on DOM ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initContextMenuSystem);
            } else {
                initContextMenuSystem();
            }
        })();
    </script>
    
    <!-- CRITICAL: Non-module script to ensure basic functionality works even if modules fail -->
    <script>
        // This script runs immediately and ensures basic clicks work
        (function() {
            'use strict';
            
            console.log('[App] Initializing critical event listeners...');
            
            // Wire main tabs immediately on DOM ready
            function initCriticalListeners() {
                try {
                    // Main tab switching - MUST work
                    const mainTabBtns = document.querySelectorAll('.main-tab-btn');
                    const tabSections = document.querySelectorAll('.tab-section');
                    
                    console.log('[Critical] Found', mainTabBtns.length, 'main tab buttons');
                    
                    mainTabBtns.forEach((btn, index) => {
                        // Remove old listener
                        if (btn._criticalTabHandler) {
                            btn.removeEventListener('click', btn._criticalTabHandler);
                        }
                        
                        // Create critical handler
                        btn._criticalTabHandler = function(e) {
                            try {
                                const tabId = this.dataset.mainTab;
                                console.log('[Critical] Tab clicked:', tabId);
                                
                                if (!tabId) return;
                                
                                // Update UI
                                mainTabBtns.forEach(b => b.classList.remove('active'));
                                tabSections.forEach(s => s.classList.remove('active'));
                                
                                this.classList.add('active');
                                const targetSection = document.getElementById('tab-section-' + tabId);
                                if (targetSection) {
                                    targetSection.classList.add('active');
                                }
                                
                                // Call module handler if it exists
                                if (btn._mainTabClickHandler) {
                                    btn._mainTabClickHandler.call(this, e);
                                }
                            } catch (err) {
                                console.error('[Critical] Error in tab handler:', err);
                            }
                        };
                        
                        btn.addEventListener('click', btn._criticalTabHandler);
                        console.log('[Critical] Wired tab', index, ':', tabId);
                    });
                    
                    console.log('[Critical] Critical listeners wired successfully');
                } catch (err) {
                    console.error('[Critical] Failed to wire critical listeners:', err);
                }
            }
            
            // Run immediately if DOM ready, otherwise wait
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initCriticalListeners);
            } else {
                initCriticalListeners();
            }
            
            // Also try after a short delay to catch late-loading elements
            setTimeout(initCriticalListeners, 100);
            setTimeout(initCriticalListeners, 500);
        })();
    </script>
    
    <!-- CRITICAL: Non-module script to ensure basic functionality works even if modules fail -->
    <script>
        // This script runs immediately and ensures basic clicks work
        (function() {
            'use strict';
            
            console.log('[Critical] Initializing critical event listeners...');
            
            // Wire main tabs immediately on DOM ready
            function initCriticalListeners() {
                try {
                    // Main tab switching - MUST work
                    const mainTabBtns = document.querySelectorAll('.main-tab-btn');
                    const tabSections = document.querySelectorAll('.tab-section');
                    
                    console.log('[Critical] Found', mainTabBtns.length, 'main tab buttons');
                    
                    if (mainTabBtns.length === 0) {
                        console.warn('[Critical] No main tab buttons found, retrying...');
                        return;
                    }
                    
                    mainTabBtns.forEach((btn, index) => {
                        // Remove old listener
                        if (btn._criticalTabHandler) {
                            btn.removeEventListener('click', btn._criticalTabHandler);
                        }
                        
                        // Create critical handler
                        btn._criticalTabHandler = function(e) {
                            try {
                                const tabId = this.dataset.mainTab;
                                console.log('[Critical] Tab clicked:', tabId);
                                
                                if (!tabId) {
                                    console.error('[Critical] Tab button has no data-main-tab');
                                    return;
                                }
                                
                                // Update UI immediately
                                mainTabBtns.forEach(b => b.classList.remove('active'));
                                tabSections.forEach(s => s.classList.remove('active'));
                                
                                this.classList.add('active');
                                const targetSection = document.getElementById('tab-section-' + tabId);
                                if (targetSection) {
                                    targetSection.classList.add('active');
                                    console.log('[Critical] Activated tab:', tabId);
                                } else {
                                    console.warn('[Critical] Tab section not found:', 'tab-section-' + tabId);
                                }
                                
                                // Call module handler if it exists (for additional functionality)
                                if (btn._mainTabClickHandler) {
                                    try {
                                        btn._mainTabClickHandler.call(this, e);
                                    } catch (err) {
                                        console.warn('[Critical] Module handler failed:', err);
                                    }
                                }
                            } catch (err) {
                                console.error('[Critical] Error in tab handler:', err);
                            }
                        };
                        
                        btn.addEventListener('click', btn._criticalTabHandler);
                        console.log('[Critical] Wired tab', index, ':', btn.dataset.mainTab);
                    });
                    
                    console.log('[Critical] Critical listeners wired successfully');
                } catch (err) {
                    console.error('[Critical] Failed to wire critical listeners:', err);
                }
            }
            
            // Run immediately if DOM ready, otherwise wait
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initCriticalListeners);
            } else {
                initCriticalListeners();
            }
            
            // Also try after delays to catch late-loading elements
            setTimeout(initCriticalListeners, 100);
            setTimeout(initCriticalListeners, 500);
            setTimeout(initCriticalListeners, 1000);
        })();
    </script>
    
    <!-- Quick Actions Floating Bar -->
    <div class="quick-actions-bar">
        <button class="quick-action-btn" data-quick-tab="generate" title="Generate (Ctrl+1)" data-info-title="Quick: Generate" data-info-desc="Quick access to Generate tab" data-info-shortcut="Ctrl+1">
            <span>&#127929;</span>
        </button>
        <button class="quick-action-btn" data-quick-tab="analyze" title="Analyze (Ctrl+2)" data-info-title="Quick: Analyze" data-info-desc="Quick access to Analyze tab" data-info-shortcut="Ctrl+2">
            <span>&#129516;</span>
        </button>
        <button class="quick-action-btn" data-quick-tab="media" title="Media (Ctrl+3)" data-info-title="Quick: Media" data-info-desc="Quick access to Media/Library tab" data-info-shortcut="Ctrl+3">
            <span>&#127916;</span>
        </button>
    </div>
    
    <!-- Context Menu -->
    <div class="context-menu" id="context-menu"></div>
</body>
</html>
